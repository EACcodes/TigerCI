! Copyright (c) 1998-2004, University of California, Los Angeles, Emily A. Carter
!                       2004-2016, Princeton University, Emily A. Carter
! All rights reserved.
!
! Redistribution and use in source and binary forms, with or without modification, are
! permitted provided that the following conditions are met:
!
! 1. Redistributions of source code must retain the above copyright notice, this list of
!     conditions and the following disclaimer.
!
! 2. Redistributions in binary form must reproduce the above copyright notice, this list
!     of conditions and the following disclaimer in the documentation and/or other
!     materials provided with the distribution.
!
! 3. Neither the name of the copyright holder nor the names of its contributors may be
!     used to endorse or promote products derived from this software without specific
!     prior written permission.
!
! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
! CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
! INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
! MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
! DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
! CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
! SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
! NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
! CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
! STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
! ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
! OF THE POSSIBILITY OF SUCH DAMAGE.
!*******************************************************************
! START AUTOGENERATED INITIALIZATION 
! END AUTOGENERATED INITIALIZATION 
  !> \brief THIS MODULE IS THE FOUR SEGMENT MODULE THAT MAKES
  !> USE OF SEPARATION OF THE EXTERNAL SPACE.
  !>
  !>  HERE WE TREAT THE FOLLOWING:
  !>     - FOUR SEGMENT LOOPS WHICH RESIDE ENTIRELY IN THE INTERNAL SPACE,
  !>     - FOUR SEGMENT LOOPS WITH THREE SEGMENTS IN THE INTERNAL SPACE
  !>     - FOUR SEGMENT LOOPS WITH TWO SEGMENTS IN THE INTERNAL SPACE
  !>     - WE TREAT THE THREE SEGMENT LOOPS WHICH HAVE THEIR J AND I
  !>       SEGMENTS IN THE INTERNAL SPACE.
  !>
  !> \date 2000
  !> \author Derek Walter
  !> \author Arun Venkatnathan
!*****************************************************************

! To reduce symbol size the following abbreviations are made
! David Krisiloff 12/22/2010
!
! coefficients --> coeff
! coupling     --> coupl
! external     --> extern
! internal     --> intern
! complement   --> compl
  
module three_and_four_seg_mod_2
  
  use graph_var_mod
  use global_var_mod
  use molecule_var_mod
  use integral_storage_mod
  use get_integrals_mod
  use ci_utilities_mod
  use decider_symbols
  use new_tree_search_mod
  use tree_search_mod
  use locist_mod
  use scepmaker_mod
  use io_unit_numbers
  use three_four_seg_var_mod
  use two_seg_info_replacement
  use spin_mod,only:contracted_cycle_stateless
  use pseudo_seg_info_mod
  use cholesky_structs
  use sgga_helpers
  use blocked_locks_mod
  use fortran_timing
  use IOBuffer
  use make_all_integrals
  use arraylist_integer
#ifdef TIGER_USE_OMP
  use omp_lib
#endif

  implicit none

  private
  
#ifdef TIGER_USE_SLOW_OMP
  public :: three_and_four_seg_driver_2,two_intern_seg_compl_vec_lmo,three_intern_seg_compl_vec_lmo,omp_offsets_four_icount,omp_offsets_four_nodecount
#else
  public :: three_and_four_seg_driver_2,two_intern_seg_compl_vec_lmo,three_intern_seg_compl_vec_lmo
#endif
  
  !// LOOPS (THESE ARE BASICALLY PARAMETERS AS IN THE THREE-FOUR-SEG-MOD-1)
  integer,private,dimension(8,6,4,2)::full_loops
  integer,private,dimension(8,3,3,2)::partial_loops3_vec
  integer,private,dimension(8,2,2)  ::partial_loops2
  integer,private,dimension(4,2,2)  ::two_seg_ijaj_loops
  
#ifdef TIGER_USE_OMP
  !// THESE ARRAYS ARE *ONLY* USED TO COMMUNICATE INFORMATION (OFFSETS ETC)
  !// IN THE OPENMP CASE WITHIN THIS MODULE. DO NOT USE FOR ANYTHING ELSE!
  !// ALSO, DO NOT PUT ANY OTHER GLOBAL MODULE VARIABLES HERE WITHOUT 
  !// PROPER JUSTIFICATION!
  integer,dimension(:),allocatable,private::omp_offsets_two_rec
  integer,dimension(:),allocatable,private::omp_offsets_two_icount
  integer,dimension(:),allocatable,private::omp_offsets_two_icount2
#endif
#ifdef TIGER_USE_SLOW_OMP
  type(arrayContent_integer)::omp_offsets_four_nodecount
  type(arrayContent_integer)::omp_offsets_four_icount
#endif
  
  type twoIntScr
     real(real8),dimension(:,:),allocatable::scep_integral_EX
     real(real8),dimension(:,:),allocatable::Px,Py
     real(real8),dimension(:,:),allocatable::scep_ci_1,scep_sigma_1
     real(real8),dimension(:,:),allocatable::ia_mo_vecs,jb_mo_vecs
     real(real8),dimension(:),allocatable::ij_vec
     real(real8),dimension(:),allocatable::scep_integral_C
     integer,dimension(:),allocatable::virt_lam_allow,virt_mu_allow
  end type twoIntScr
  
  type threeIntScr
     integer::loop_type,rt_loop_weight
     integer,dimension(:,:),allocatable::constraints
     integer,dimension(:),allocatable::virt_lam_allow,virt_mu_allow
     real(real8),dimension(:,:),allocatable::Px,Py,aijk_buf
     real(real8),dimension(:),allocatable::iajk_int,ikaj_int,ijka_int
     real(real8),dimension(:,:),allocatable::ka_vecs
     real(real8),dimension(:),allocatable::tmp_vec
  end type threeIntScr
  
  type fourIntScr
     integer::weight,rt_loop_weight
     real(real8),dimension(3)::integrals
     integer,dimension(:),allocatable::virt_lam_allow,virt_mu_allow
     integer,dimension(:,:),allocatable::constraints
     real(real8),dimension(:,:),allocatable::Px,Py
  end type fourIntScr
  
  contains
  
!*****************************************************************
subroutine three_and_four_seg_driver_2(civec, sigmavec, iteration,cho_data,loc_scr,mod2vars)
  
  !// THIS IS THE MAIN DRIVER ROUTINE FOR THE TREATMENT OF THE FOUR SEGMENT
  !// LOOPS USING SEPARATION OF THE EXTERNAL SPACE.  
  use time_var_mod
  use utilities_mod
  use cholesky_structs
  use locist_var_mod,only:locist_scratch
  use two_seg_var_mod
  
  !!!!!!!!!!!!!!!!!!!!!!!!!!!  VARIABLE DECLARATION !!!!!!!!!!!!!!!!!!!!!!!!!!!
  implicit none
  
  type(cholesky_data),intent(in)::cho_data
  type(orbital_path)::lambda_path
  type(locist_scratch)::loc_scr
  type(threefourmod2vars)::mod2vars
  type(clock) :: timer
  type(blockedLockVectorType) :: civec, sigmavec
  
  integer::allocatestatus    !// FOR DYNAMIC MEMORY ALLOCATION
  integer::deallocatestatus
  integer::iteration         !// KEEPS TRACK OF THE ITERATION WE ARE ON
  
  
  !!!!!!!!!!!!!!!!!!!!!!! VARIABLE INITIALIZATION !!!!!!!!!!!!!!!!!!!!!!!!!!!!
  
  !// MAIN INITIALIZATION IS THE DERIVED TYPE ARRAYS
  allocate(lambda_path%arc_weights(0:num_orbitals), stat=allocatestatus)
  call allocatecheck(allocatestatus,"%2sg_wei")
  lambda_path%arc_weights = 0
  
  allocate(lambda_path%occupations(0:num_orbitals), stat=allocatestatus)
  call allocatecheck(allocatestatus,"%lam_occ")
  lambda_path%occupations = 0
  
  allocate(lambda_path%singles(0:num_orbitals), stat=allocatestatus)
  call allocatecheck(allocatestatus,"%lam_sin")
  lambda_path%singles = 0
  
  allocate(lambda_path%constraints(3,6), stat=allocatestatus)
  call allocatecheck(allocatestatus,"%lam_con")
  lambda_path%constraints = 0
  
  allocate(lambda_path%encountered(3), stat=allocatestatus)
  call allocatecheck(allocatestatus,"%lam_enc")
  lambda_path%encountered = .false.

  ! allocate and zero mod2vars
  call allocMod2Vars(mod2vars,num_external,fsn(open_shells))
  call zeroMod2Vars(mod2vars)
           
  !!!!!!!!!!!!!!!!!!!!!!!!!!! START OF ROUTINE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  !// CALL A ROUTINE TO SET THE LOOPS.  THIS IS TO WORK AROUND A BUG IN THE
  !// SHITTY COMPAQ COMPILER
  call set_loops
 
  !!!!!!!!!!!!!!!!
  !//
  !// FOUR SEGMENT LOOPS WITH TWO 
  !// SEGMENTS IN THE INTERNAL SPACE
  !//
  !!!!!!!!!!!!!!!!
 
  mod2vars%iter_count = iteration
 
  call start_clock(timer)
  if (valence_ci_flag .ne. 1 .and. reference_ci_flag .ne. 1) then
     if (num_internal >= 2) then
        call two_internal_seg_direct_cho(cho_data, civec, sigmavec, iteration,lambda_path,mod2vars)
     endif
  endif 

  abij_time = abij_time + get_clock_wall_time(timer)
  call print_clock(timer, "  + two internal")
  call flush(ioOutput)
  
  
  !!!!!!!!!!!!!!!!
  !//
  !// FOUR SEGMENT LOOPS WHICH
  !// RESIDE ENTIRELY IN THE
  !// INTERNAL SPACE
  !//
  !!!!!!!!!!!!!!!!
  
  call start_clock(timer)
  if (num_internal >=4) call four_i_seg_loopdrv(civec, sigmavec, cho_data,lambda_path,iteration)
  ijkl_time = ijkl_time + get_clock_wall_time(timer)
  call print_clock(timer, "  + four internal")
  call flush(ioOutput)
  

  !!!!!!!!!!!!!!!!
  !//
  !// FOUR SEGMENT LOOPS HAVING
  !// THREE SEGMENTS IN THE
  !// INTERNAL SPACE
  !//
  !!!!!!!!!!!!!!!!  

  call start_clock(timer)
  if (valence_ci_flag .ne. 1 .and. reference_ci_flag .ne. 1) then
    if(num_internal >=3) call three_i_seg_loopdrv(civec, sigmavec, lambda_path,mod2vars,cho_data)
  endif

  aijk_time = aijk_time + get_clock_wall_time(timer)
  call print_clock(timer, "  + three internal(II)")
  call flush(ioOutput)

  !!!!!!!!!!!!!!!!!!!!!!!!
  !//
  !// THREE SEGMENT LOOPS HAVING
  !// TWO SEGMENTS IN THE INTERNAL 
  !// SPACE
  !//
  !!!!!!!!!!!!!!!!!!!!!!!!    
  
  call start_clock(timer)
  if (valence_ci_flag .ne. 1 .and. reference_ci_flag .ne. 1) then
      if (num_internal >= 2) call two_internal_seg_ijaj_cho(civec, sigmavec, cho_data,lambda_path,loc_scr,mod2vars)
  endif
  ijaj_time = ijaj_time + get_clock_wall_time(timer)
  call print_clock(timer, "  + two internal(II)")
  call flush(ioOutput)


  !// CLEAN UP BEFORE QUITTING.
  deallocate(lambda_path%arc_weights, stat = deallocatestatus)
  call deallocatecheck(deallocatestatus, "%2la_wei")
  
  deallocate(lambda_path%occupations, stat = deallocatestatus)
  call deallocatecheck(deallocatestatus, "%2la_occ")
    
  deallocate(lambda_path%singles, stat = deallocatestatus)
  call deallocatecheck(deallocatestatus, "%2la_sin")
  
  deallocate(lambda_path%constraints, stat = deallocatestatus)
  call deallocatecheck(deallocatestatus, "%2la_con")
  
  deallocate(lambda_path%encountered, stat = deallocatestatus)
  call deallocatecheck(deallocatestatus, "encounte")
  
  !// DEALLOCATE INTEGRAL STORAGE ARRAYS
  if (allocated(integral_buffer)) deallocate(integral_buffer, stat = deallocatestatus)
  call deallocatecheck(deallocatestatus, "integral")
  
  ! deallocate the arrays in our temp object
  call deallocMod2Vars(mod2vars)
 
end subroutine three_and_four_seg_driver_2
  
  
!*****************************************************************
!*****************************************************************
subroutine four_i_seg_loopdrv(civec, sigmavec, cho_data,lambda_path,iter_count)

  use locist_var_mod,only:locist_scratch
  use two_seg_var_mod

  implicit none

  integer,intent(in)::iter_count
  type(cholesky_data)::cho_data
  type(orbital_path)::lambda_path
  type(graph_search_state)::graph
  type(blockedLockVectorType) :: civec, sigmavec 
  type(fourIntScr),dimension(:),allocatable::scr
  integer::status,i
  integer::nextIJKLRecord,nodeCounter
#ifdef TIGER_USE_OMP
  integer::numthreads
  numthreads = numberOfThreads
#else
  integer,parameter::numthreads=1
#endif
#ifdef TIGER_USE_SLOW_OMP
  integer::pos
#endif
  
  write(*,*) "INFO: Direct four internal kernel is ",directFourInternal
  
  allocate(scr(numthreads),stat=status)
  call allocatecheck(status,"four_i_seg_loopdrv_SCR")
  do i=1,numthreads
     allocate(scr(i)%virt_lam_allow(num_external),scr(i)%virt_mu_allow(num_external),scr(i)%Px(fsn(open_shells),fsn(open_shells)), &
     scr(i)%Py(fsn(open_shells),fsn(open_shells)),scr(i)%constraints(3,6),stat=status)
     call allocatecheck(status,"four_i_seg_loopdrv_SCR_II")
  enddo
  
  
  !!!!!!!!!!!!!!!!!!!!!!! VARIABLE INITIALIZATION !!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !// INITIALIZE DERIVED TYPES
  lambda_path%occupations = 0
  lambda_path%singles = 0
  lambda_path%arc_weights = 0
  lambda_path%constraints = -1
  do i=1,numthreads
     scr(i)%constraints = -1
  enddo
  lambda_path%encountered = .false.
  lambda_path%num_singles = 0


  !!!!!!!!!!!!!!!!!!!!!!!!!!! START OF ROUTINE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  nextIJKLRecord = 1
  nodeCounter = 0

  !// LOOP OVER SETS OF INTERNAL ORBITALS. IN THE FOLLOWING I>J>K>L
#ifdef TIGER_USE_SLOW_OMP
   if(.not. fullyIntegralDirect .and. .not. integralDirect .and. .not. directFourInternal .and. iter_count == 1) then
     ! init our arraylist
     call construct(omp_offsets_four_icount,num_orbitals)
     call construct(omp_offsets_four_nodecount,num_orbitals)
     ! why num_orbitals? I want something that scales with system size and this seems simple enough
   else if(.not. fullyIntegralDirect .and. .not. integralDirect .and. iter_count /= 1) then
     call resetIterator(omp_offsets_four_nodecount)
   endif
#endif
  
  call init_tree_search(graph, 0, 0, num_internal, num_elec-2)
  if(integralDirect .or. fullyIntegralDirect .or. directFourInternal) then
   do while ( get_internal_path(lambda_path, graph))
      call fouriseg4s_fully(civec, sigmavec, cho_data,lambda_path,scr)
   end do
  else
   do while ( get_internal_path(lambda_path, graph))
#ifdef TIGER_USE_SLOW_OMP
      if(iter_count == 1) then
        pos = append(omp_offsets_four_nodecount,nodeCounter)
      else
        nodeCounter = getNext(omp_offsets_four_nodecount)
      endif
#endif
      call fouriseg4s(civec, sigmavec, cho_data,lambda_path,scr,iter_count,nextIJKLRecord,nodeCounter)
   end do
  endif
  
  !// INITIALIZE DERIVED TYPES
  lambda_path%occupations = 0
  lambda_path%singles = 0
  lambda_path%arc_weights = 0
  lambda_path%constraints = -1
  do i=1,numthreads
     scr(i)%constraints = -1
  enddo
  lambda_path%encountered = .false.
  lambda_path%num_singles = 0

  call init_tree_search(graph, 0, 0, num_internal, num_elec-1)
  if(integralDirect .or. fullyIntegralDirect .or. directFourInternal) then
   do while ( get_internal_path(lambda_path, graph))
      call fouriseg4s_fully(civec, sigmavec, cho_data,lambda_path,scr)
   end do
  else
   do while ( get_internal_path(lambda_path, graph))
#ifdef TIGER_USE_SLOW_OMP
      if(iter_count == 1) then
        pos = append(omp_offsets_four_nodecount,nodeCounter)
      else
        nodeCounter = getNext(omp_offsets_four_nodecount)
      endif
#endif
      call fouriseg4s(civec, sigmavec, cho_data,lambda_path,scr,iter_count,nextIJKLRecord,nodeCounter)
   end do
  endif
  
  !// RE-INITIALIZE DERIVED TYPES
  lambda_path%occupations = 0
  lambda_path%singles = 0
  lambda_path%arc_weights = 0
  lambda_path%constraints = -1
  do i=1,numthreads
     scr(i)%constraints = -1
  enddo
  lambda_path%encountered = .false.
  lambda_path%num_singles = 0

  call init_tree_search(graph, 0, 0, num_internal, num_elec)
  if(integralDirect .or. fullyIntegralDirect .or. directFourInternal) then
   do while ( get_internal_path(lambda_path, graph))
      call fouriseg4s_fully(civec, sigmavec, cho_data,lambda_path,scr)
   end do
  else
   do while ( get_internal_path(lambda_path, graph))
#ifdef TIGER_USE_SLOW_OMP
      if(iter_count == 1) then
        pos = append(omp_offsets_four_nodecount,nodeCounter)
      else
        nodeCounter = getNext(omp_offsets_four_nodecount)
      endif
#endif
      call fouriseg4s(civec, sigmavec, cho_data,lambda_path,scr,iter_count,nextIJKLRecord,nodeCounter)
   end do
  endif
  
  ! we rely on automatic deallocation of scratch space

end subroutine four_i_seg_loopdrv
!****************************************************************************************
subroutine get_4_orbital_indices(ibar,jbar,kbar,lbar,chain,constraints,occupations)

  implicit none
  
  !!!!!!!!!!!!!!!!!!!!!!!!!!!  VARIABLE DECLARATION !!!!!!!!!!!!!!!!!!!!!!!!!!!
  
  integer,dimension(:),intent(in)::occupations
  integer,dimension(:,:),intent(in)::constraints
  integer,intent(in)::chain                  !// LOOP CHAIN
  integer,intent(out)::ibar,jbar,kbar,lbar    !// ORBITAL POSITION INDICES
  integer::s1,s2,s3,s4            !// NUMBER OF SINGLES IN EACH SEGMENT OF THE LOOP.
                                  !//   I.E. S1 IS THE NUMBER OF SINGLES FROM THE HEAD
                                  !//   OF THE GRAPH UP TO AND INCLUDING THE FIRST LOOP
                                  !//   SEGMENT
  integer::singles_count          !// TEMPORARY STORAGE OF THE NUMBER OF SINGLES                                 
  integer::constraint_count       !// KEEPS TRACK OF THE LOOP LEVELS
  integer::internal_orbital       !// LOOP VARIABLE FOR LOOPING OVER INTERNAL ORBITALS

  !!!!!!!!!!!!!!!!!!!!!!! VARIABLE INITIALIZATION !!!!!!!!!!!!!!!!!!!!!!!!!!!!
  singles_count = 0
  constraint_count = 1
  
  !!!!!!!!!!!!!!!!!!!!!!!!!!! START OF ROUTINE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !// LOOP OVER THE ORBITALS AND COUNT UP THE NUMBER OF SINGLES
  
  do internal_orbital = 1, constraints(2,4)
  
      ! took me hours to figure out
      ! we need +1 here, as occupations are allocated from 0:num_orbitals
      ! that info is lost when we hand array over (f***** inconsistent fortran)
      ! -> we must increment by one to be correct
      if (occupations(internal_orbital+1)==1) then
          singles_count = singles_count + 1
      endif
      
      if (constraints(2,constraint_count)==internal_orbital) then
          if (constraint_count == 1) then
              s1 = singles_count
              singles_count = 0
              constraint_count = constraint_count + 1
          elseif (constraint_count == 2) then
              s2 = singles_count
              singles_count = 0
              constraint_count = constraint_count + 1
          elseif (constraint_count == 3) then
              s3 = singles_count
              singles_count = 0
              constraint_count = constraint_count + 1
          elseif (constraint_count == 4) then
              s4 = singles_count
              singles_count = 0
              constraint_count = constraint_count + 1
          endif
      endif
  enddo
  
  !// NOW CONVERT THE SINGLES TO IBAR, JBAR, KBAR, LBAR    
  if (chain == 1) then
      
      !// C1 IBAR>JBAR>KBAR>LBAR
      ibar = s1 + s2 + s3 + s4
      jbar = s1 + s2 + s3
      kbar = s1 + s2 + 2
      lbar = s1 + 1
      
  elseif (chain == 2) then    
  
      !// C2 IBAR>KBAR>JBAR>LBAR
      ibar = s1 + s2 + s3 + s4
      jbar = s1 + s2 
      kbar = s1 + s2 + s3 + 1
      lbar = s1 + 1
      
  elseif (chain == 3) then    
  
      !// C3 KBAR>IBAR>JBAR>LBAR
      ibar = s1 + s2 + s3
      jbar = s1 + s2 
      kbar = s1 + s2 + s3 + s4
      lbar = s1 + 1
      
  elseif (chain == 4) then    
  
      !// C8 IBAR>JBAR>KBAR>LBAR
      ibar = s1 + s2 + s3 +s4
      jbar = s1 + s2 + s3
      kbar = s1 + s2
      lbar = s1     
      
  elseif (chain == 5) then    
  
      !// C4 IBAR>JBAR>KBAR>LBAR
      ibar = s1 + s2 + s3 +s4
      jbar = s1 + s2 + s3
      kbar = s1 + s2
      lbar = s1 + 1
      
  elseif (chain == 6) then    
  
      !// C5 IBAR>JBAR>LBAR>KBAR
      ibar = s1 + s2 + s3 +s4
      jbar = s1 + s2 + s3
      kbar = s1 
      lbar = s1 + s2 
      
  elseif (chain == 7) then    
  
      !// C6 KBAR>JBAR>LBAR>IBAR
      ibar = s1 + s2 + s3 +s4
      jbar = s1 + s2
      kbar = s1 
      lbar = s1 + s2 + s3 - 1
      
  elseif (chain == 8) then    
  
      !// C7 KBAR>JBAR>IBAR>LBAR
      ibar = s1 + s2 + s3
      jbar = s1 + s2
      kbar = s1 
      lbar = s1 + s2 + s3 + s4 - 2
      
  endif    
      
end subroutine get_4_orbital_indices
  
subroutine sort_integrals(integrals, chain, j1, j2, j3)

  implicit none
  
  !!!!!!!!!!!!!!!!!!!!!!!!!!!  VARIABLE DECLARATION !!!!!!!!!!!!!!!!!!!!!!!!!!!
  real(real8),dimension(3),intent(inout)::integrals
  integer,intent(in)::chain                  !// LOOP CHAIN
  
  real(real8),intent(in)::j1, j2, j3         !// THE INTEGRALS
  
  !!!!!!!!!!!!!!!!!!!!!!!!!!! START OF ROUTINE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  if (chain == 1.or.&
      chain == 4.or.&
      chain == 5) then
      
      !// C1,C8 AND C4 LOOPS
      integrals(1) = j1
      integrals(2) = j2
      integrals(3) = j3
      
  elseif (chain == 2) then    
  
      !// C2 LOOPS
      integrals(1) = j3
      integrals(2) = j2
      integrals(3) = j1
      
  elseif (chain == 3) then
  
      !// C3 LOOPS
      integrals(1) = j2
      integrals(2) = j3
      integrals(3) = j1
      
  elseif (chain == 6) then
      
      !// C5 LOOPS
      integrals(1) = j1
      integrals(2) = j3
      integrals(3) = j2
  
  elseif (chain == 7) then
  
      !// C6 LOOPS
      integrals(1) = j3
      integrals(2) = j1
      integrals(3) = j2
  
  elseif (chain == 8) then
  
      !// C7 LOOPS
      integrals(1) = j2
      integrals(2) = j1
      integrals(3) = j3
  
  endif
  
end subroutine sort_integrals
    
!*****************************************************************
!*****************************************************************
!*****************************************************************
!*****************************************************************
subroutine compute_coupling_coefficients(chain, member,&
                                           ibar,jbar,kbar,lbar,&
                                           lambda_singles,mu_singles,&
                                           Px,Py,size)
                                           
  use spin_var_mod,only:cycles,sft,spin_matrix
  
  implicit none
                                           
  !// THIS SUBROUTINE COMPUTES COUPLING COEFFICIENTS, STORING THEM
  !// IN Px AND Py AS APPROPRIATE.
  
  !!!!!!!!!!!!!!!!!!!!!!!!!!!  VARIABLE DECLARATION !!!!!!!!!!!!!!!!!!!!!!!!!!!                                         
  integer,intent(in)::chain                      !// THE LOOP CHAIN
  integer,intent(in)::member                     !// THE MEMBER WITHIN THE CHAIN
  integer,intent(in)::ibar,jbar,kbar,lbar        !// ORBITAL INDICES
  integer,intent(in)::lambda_singles             !// SINGLES IN LAMBDA AND MU PATHS
  integer,intent(in)::mu_singles
  integer,intent(in)::size                       !// DIMENSION OF COUPLING COEFFICIENT MATRIX
  
  real(real8),dimension(size,size),intent(inout)::Px,Py   !// COUPLING COEFFICIENT MATRICES
  real(real8),dimension(:,:),allocatable::locContracted ! we want a fast to allocate local scratch space
  integer::status
                                           
  !!!!!!!!!!!!!!!!!!!!!!!!!!! START OF ROUTINE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !// write(ioOutput,*) "chain, member: ", chain, member
  !// write(ioOutput,*) "i,j,k,l: ", ibar, jbar, kbar, lbar
  
  allocate(locContracted(size,size),stat=status)
  call allocatecheck(status,"compute_coupling_coefficients")
  
  if (chain <= 3) then
       
       !// C1,C2,C3 LOOPS
       if (member <= 2) then
       
        !// PX = P3, PY = P2
          
        !// FIRST PX
        call contracted_cycle_stateless(kbar,ibar,lbar,jbar,0,0,lambda_singles,mu_singles,Px,cycles,sft,spin_matrix)
          
        !// NOW PY
        call contracted_cycle_stateless(kbar,jbar+1,lbar,ibar,0,0,lambda_singles,mu_singles,Py,cycles,sft,spin_matrix)
  
  
       elseif (member == 3.or.member == 4) then
       
        !// PX = -P3, PY = P1 = P2+P3
        
        !// FIRST PX
        call contracted_cycle_stateless(kbar,ibar,lbar,jbar,0,0,lambda_singles,mu_singles,Px,cycles,sft,spin_matrix)
        Px = -Px
        
        !// NOW PY
        call contracted_cycle_stateless(kbar,jbar+1,lbar,ibar,0,0,lambda_singles,mu_singles,Py,cycles,sft,spin_matrix)
        
        call contracted_cycle_stateless(kbar,ibar,lbar,jbar,0,0,lambda_singles,mu_singles,locContracted,cycles,sft,spin_matrix)
        Py = Py + locContracted
       
       elseif (member >= 5) then
       
       
        !// PX = -P2, PY = P1 = P2+P3
        
        !// FIRST PX
        call contracted_cycle_stateless(kbar,jbar+1,lbar,ibar,0,0,lambda_singles,mu_singles,Px,cycles,sft,spin_matrix)
        Px = -Px
        
        !// NOW PY
        call contracted_cycle_stateless(kbar,jbar+1,lbar,ibar,0,0,lambda_singles,mu_singles,Py,cycles,sft,spin_matrix)
        
        call contracted_cycle_stateless(kbar,ibar,lbar,jbar,0,0,lambda_singles,mu_singles,locContracted,cycles,sft,spin_matrix)
        Py = Py + locContracted
          
       endif
       
  elseif (chain == 4) then
  
      !// C8 LOOPS
      if (member <= 2) then
       
        !// PX = P1, PY = P3
          
        !// FIRST PX
        call contracted_cycle_stateless(jbar,ibar,lbar,kbar,jbar,lbar,lambda_singles,mu_singles,Px,cycles,sft,spin_matrix)
          
        !// NOW PY
        call contracted_cycle_stateless(kbar+1,ibar,lbar,jbar,kbar+1,lbar,lambda_singles,mu_singles,Py,cycles,sft,spin_matrix)
          
      elseif (member == 3.or.member == 4) then
      
        !// PX = P1, PY = P2
        
        !// FIRST PX
        call contracted_cycle_stateless(jbar,ibar,lbar,kbar,jbar,lbar,lambda_singles,mu_singles,Px,cycles,sft,spin_matrix)
          
        !// NOW PY
        call contracted_cycle_stateless(lbar,ibar,jbar,kbar,jbar,lbar,lambda_singles,mu_singles,Py,cycles,sft,spin_matrix)
        
      elseif (member >= 5) then
       
        !// PX = P3, PY = P2 
        
        !// FIRST PX
        call contracted_cycle_stateless(kbar+1,ibar,lbar,jbar,kbar+1,lbar,lambda_singles,mu_singles,Px,cycles,sft,spin_matrix)
        
        !// NOW PY
        call contracted_cycle_stateless(lbar,ibar,jbar,kbar,jbar,lbar,lambda_singles,mu_singles,Py,cycles,sft,spin_matrix)
        
      endif
  
  elseif (chain == 5) then
  
      !// C4 LOOPS
      if (member == 1) then
      
        !// PX = P1, PY = P2
        
        !// FIRST PX
        call contracted_cycle_stateless(lbar,kbar,jbar,ibar,jbar,0,lambda_singles,mu_singles,Px,cycles,sft,spin_matrix)
        
        !// NOW PY
        call contracted_cycle_stateless(lbar,ibar,kbar,jbar,kbar+1,0,lambda_singles,mu_singles,Py,cycles,sft,spin_matrix)
      
      elseif (member == 2) then
      
        !// PX = -P1, PY = P2' = P1 + P3
        
        !// FIRST PX
        call contracted_cycle_stateless(lbar,kbar,jbar,ibar,jbar,0,lambda_singles,mu_singles,Px,cycles,sft,spin_matrix)
        Px = -Px
        
        !// NOW PY
        call contracted_cycle_stateless(lbar,kbar,jbar,ibar,jbar,0,lambda_singles,mu_singles,Py,cycles,sft,spin_matrix)
        
        call contracted_cycle_stateless(lbar,jbar+1,kbar,ibar,kbar+1,0,lambda_singles,mu_singles,locContracted,cycles,sft,spin_matrix)
        Py = Py + locContracted
      
      elseif (member == 3) then
      
        !// PX = P1, PY = P3
        
        !// FIRST PX
        call contracted_cycle_stateless(lbar,kbar,jbar,ibar,jbar,0,lambda_singles,mu_singles,Px,cycles,sft,spin_matrix)
        
        !// NOW PY
        call contracted_cycle_stateless(lbar,jbar+1,kbar,ibar,kbar+1,0,lambda_singles,mu_singles,Py,cycles,sft,spin_matrix)
  
      elseif (member == 4) then
      
        !// PX = -P1, PY = P3' = P1 + P2
        
        !// FIRST PX
        call contracted_cycle_stateless(lbar,kbar,jbar,ibar,jbar,0,lambda_singles,mu_singles,Px,cycles,sft,spin_matrix)
        Px = -Px
        
        !// NOW PY
        call contracted_cycle_stateless(lbar,kbar,jbar,ibar,jbar,0,lambda_singles,mu_singles,Py,cycles,sft,spin_matrix)
        
        call contracted_cycle_stateless(lbar,ibar,kbar,jbar,kbar+1,0,lambda_singles,mu_singles,locContracted,cycles,sft,spin_matrix)
        Py = Py + locContracted
  
      elseif (member == 5) then
      
        !// PX = P2, PY = P3
        
        !// FIRST PX
        call contracted_cycle_stateless(lbar,ibar,kbar,jbar,kbar+1,0,lambda_singles,mu_singles,Px,cycles,sft,spin_matrix)
        
        !// NOW PY
        call contracted_cycle_stateless(lbar,jbar+1,kbar,ibar,kbar+1,0,lambda_singles,mu_singles,Py,cycles,sft,spin_matrix)
        
      elseif (member == 6) then
      
        !// PX = -P2, PY = P3' = P1+P2
        
        !// FIRST PX
        call contracted_cycle_stateless(lbar,ibar,kbar,jbar,kbar+1,0,lambda_singles,mu_singles,Px,cycles,sft,spin_matrix)
        Px = -Px
        
        !// NOW PY
        call contracted_cycle_stateless(lbar,kbar,jbar,ibar,jbar,0,lambda_singles,mu_singles,Py,cycles,sft,spin_matrix)
        
        call contracted_cycle_stateless(lbar,ibar,kbar,jbar,kbar+1,0,lambda_singles,mu_singles,locContracted,cycles,sft,spin_matrix)
        Py = Py + locContracted
        
      endif
  
  elseif (chain == 6) then
  
      !// C5 LOOPS.  THESE ONES ARE JUST THE SAME AS THE C4 LOOPS EXCEPT IN P2 AND
      !// P3 WE USE D1 = KBAR INSTEAD OF D1 = KBAR + 1.  ADDITIONALLY, WE NEED
      !// TO USE LBAR+2 FOR P2 AND P3.  THIS IS ANOTHER ERRATA IN WLODEK'S PAPER.
      if (member == 1) then
      
        !// PX = P1, PY = P2
        
        !// FIRST PX
        call contracted_cycle_stateless(lbar,kbar,jbar,ibar,jbar,0,lambda_singles,mu_singles,Px,cycles,sft,spin_matrix)
        
        !// NOW PY
        call contracted_cycle_stateless(lbar+2,ibar,kbar,jbar,kbar,0,lambda_singles,mu_singles,Py,cycles,sft,spin_matrix)
        
      elseif (member == 2) then
      
        !// PX = -P1, PY = P2' = P1 + P3
        
        !// FIRST PX
        call contracted_cycle_stateless(lbar,kbar,jbar,ibar,jbar,0,lambda_singles,mu_singles,Px,cycles,sft,spin_matrix)
        Px = -Px
        
        !// NOW PY
        call contracted_cycle_stateless(lbar,kbar,jbar,ibar,jbar,0,lambda_singles,mu_singles,Py,cycles,sft,spin_matrix)
        
        call contracted_cycle_stateless(lbar+2,jbar+1,kbar,ibar,kbar,0,lambda_singles,mu_singles,locContracted,cycles,sft,spin_matrix)
        Py = Py + locContracted
        
      elseif (member == 3) then
      
        !// PX = P1, PY = P3
        
        !// FIRST PX
        call contracted_cycle_stateless(lbar,kbar,jbar,ibar,jbar,0,lambda_singles,mu_singles,Px,cycles,sft,spin_matrix)
        
        !// NOW PY
        call contracted_cycle_stateless(lbar+2,jbar+1,kbar,ibar,kbar,0,lambda_singles,mu_singles,Py,cycles,sft,spin_matrix)
  
      elseif (member == 4) then
      
        !// PX = -P1, PY = P3' = P1 + P2
        
        !// FIRST PX
        call contracted_cycle_stateless(lbar,kbar,jbar,ibar,jbar,0,lambda_singles,mu_singles,Px,cycles,sft,spin_matrix)
        Px = -Px
        
        !// NOW PY
        call contracted_cycle_stateless(lbar,kbar,jbar,ibar,jbar,0,lambda_singles,mu_singles,Py,cycles,sft,spin_matrix)
        
        call contracted_cycle_stateless(lbar+2,ibar,kbar,jbar,kbar,0,lambda_singles,mu_singles,locContracted,cycles,sft,spin_matrix)
        Py = Py + locContracted
  
  
      elseif (member == 5) then
      
        !// PX = P2, PY = P3
        
        !// FIRST PX
        call contracted_cycle_stateless(lbar+2,ibar,kbar,jbar,kbar,0,lambda_singles,mu_singles,Px,cycles,sft,spin_matrix)
        
        !// NOW PY
        call contracted_cycle_stateless(lbar+2,jbar+1,kbar,ibar,kbar,0,lambda_singles,mu_singles,Py,cycles,sft,spin_matrix)
        
      elseif (member == 6) then
      
        !// PX = -P2, PY = P3' = P1+P2
        
        !// FIRST PX
        call contracted_cycle_stateless(lbar+2,ibar,kbar,jbar,kbar,0,lambda_singles,mu_singles,Px,cycles,sft,spin_matrix)
        Px = -Px
        
        !// NOW PY
        call contracted_cycle_stateless(lbar,kbar,jbar,ibar,jbar,0,lambda_singles,mu_singles,Py,cycles,sft,spin_matrix)
        
        call contracted_cycle_stateless(lbar+2,ibar,kbar,jbar,kbar,0,lambda_singles,mu_singles,locContracted,cycles,sft,spin_matrix)
        Py = Py + locContracted
        
      endif
  
  elseif (chain >= 7) then
  
      !// C6, C7 LOOPS
  
      !// SPECIAL NOTE:  IF YOU LOOK AT WLODEK'S PAPER YOU MIGHT
      !// THINK THAT THIS SECTION IS NOT REQUIRED AND THAT IT COULD
      !// BE ABSORBED INTO THE BLOCK ABOVE.  HOWEVER, THERE IS A 
      !// MISPRINT IN HIS PAPER.  FOR THESE LOOPS WE NEED TO USE LBAR+2
      !// IN THE LINE UP PERMUTATIONS INSTEAD OF LBAR.  THUS WE NEED
      !// A SEPARATE BLOCK BECAUSE THE PERMUTATIONS ARE DIFFERENT.  THIS
      !// ERROR IS SIMILAR TO THE ERROR WE SAW FOR THE C5 LOOPS, EXCEPT IN
      !// THIS CASE IT APPLIES TO ALL PERMUTATIONS.  NOT JUST P2 AND P3.  
      if (member == 1) then
      
        !// PX = P1, PY = P2
        
        !// FIRST PX
        call contracted_cycle_stateless(lbar+2,kbar,jbar,ibar,jbar-1,0,lambda_singles,mu_singles,Px,cycles,sft,spin_matrix)
        
        !// NOW PY
        call contracted_cycle_stateless(lbar+2,ibar,kbar,jbar,kbar,0,lambda_singles,mu_singles,Py,cycles,sft,spin_matrix)
      
      elseif (member == 2) then
      
        !// PX = -P1, PY = P2' = P1 + P3
        
        !// FIRST PX
        call contracted_cycle_stateless(lbar+2,kbar,jbar,ibar,jbar-1,0,lambda_singles,mu_singles,Px,cycles,sft,spin_matrix)
        Px = -Px
        
        !// NOW PY
        call contracted_cycle_stateless(lbar+2,kbar,jbar,ibar,jbar-1,0,lambda_singles,mu_singles,Py,cycles,sft,spin_matrix)
        
        call contracted_cycle_stateless(lbar+2,jbar+1,kbar,ibar,kbar,0,lambda_singles,mu_singles,locContracted,cycles,sft,spin_matrix)
        Py = Py + locContracted
      
      elseif (member == 3) then
      
        !// PX = P1, PY = P3
        
        !// FIRST PX
        call contracted_cycle_stateless(lbar+2,kbar,jbar,ibar,jbar-1,0,lambda_singles,mu_singles,Px,cycles,sft,spin_matrix)
        
        !// NOW PY
        call contracted_cycle_stateless(lbar+2,jbar+1,kbar,ibar,kbar,0,lambda_singles,mu_singles,Py,cycles,sft,spin_matrix)
      
      elseif (member == 4) then
      
        !// PX = -P1, PY = P3' = P1 + P2
        
        !// FIRST PX
        call contracted_cycle_stateless(lbar+2,kbar,jbar,ibar,jbar-1,0,lambda_singles,mu_singles,Px,cycles,sft,spin_matrix)
        Px = -Px
        
        !// NOW PY
        call contracted_cycle_stateless(lbar+2,kbar,jbar,ibar,jbar-1,0,lambda_singles,mu_singles,Py,cycles,sft,spin_matrix)
        
        call contracted_cycle_stateless(lbar+2,ibar,kbar,jbar,kbar,0,lambda_singles,mu_singles,locContracted,cycles,sft,spin_matrix)
        Py = Py + locContracted
      
      elseif (member == 5) then
      
        !// PX = P2, PY = P3
        
        !// FIRST PX
        call contracted_cycle_stateless(lbar+2,ibar,kbar,jbar,kbar,0,lambda_singles,mu_singles,Px,cycles,sft,spin_matrix)
        
        !// NOW PY
        call contracted_cycle_stateless(lbar+2,jbar+1,kbar,ibar,kbar,0,lambda_singles,mu_singles,Py,cycles,sft,spin_matrix)
      
      elseif (member == 6) then
      
        !// PX = -P2, PY = P3' = P1+P2
        
        !// FIRST PX
        call contracted_cycle_stateless(lbar+2,ibar,kbar,jbar,kbar,0,lambda_singles,mu_singles,Px,cycles,sft,spin_matrix)
        Px = -Px
        
        !// NOW PY
        call contracted_cycle_stateless(lbar+2,kbar,jbar,ibar,jbar-1,0,lambda_singles,mu_singles,Py,cycles,sft,spin_matrix)
        
        call contracted_cycle_stateless(lbar+2,ibar,kbar,jbar,kbar,0,lambda_singles,mu_singles,locContracted,cycles,sft,spin_matrix)
        Py = Py + locContracted
      
      endif
      
  endif
  
  deallocate(locContracted,stat=status)
  call deallocatecheck(status,"compute_coupling_coefficients")
  
end subroutine compute_coupling_coefficients
!****************************************************************
!*****************************************************************
subroutine two_internal_seg_direct_cho(cho_data, civec, sigmavec, iteration,lambda_path,mod2vars)

  !// THIS ROUTINE IS THE MAIN DRIVER ROUTINE FOR TREATING THE FOUR SEGMENT
  !// LOOPS WHICH HAVE TWO SEGMENTS IN THE INTERNAL SPACE.  ADDITIONALLY,
  !// WE TREAT THE 3 SEGMENT LOOPS WHICH HAVE THEIR J AND I SEGMENTS IN THE
  !// INTERNAL SPACE.

  !!!!!!!!!!!!!!!!!!!!!!!!!!!  VARIABLE DECLARATION !!!!!!!!!!!!!!!!!!!!!!!!!!!

  use cholesky_structs
  use io_unit_numbers
  use locist_var_mod,only:locist_scratch
  use two_seg_var_mod

  implicit none

  type(cholesky_data),intent(in)::cho_data
  type(orbital_path)::lambda_path
  type(threefourmod2vars)::mod2vars
  type(blockedLockVectorType),intent(inout):: civec, sigmavec  

  integer::i,j,x             !// LABELS THE LOOP LEVELS
  integer::loops             !// LABELS THE LOOP, DUH
  integer::allocatestatus    !// FOR DYNAMIC MEMORY ALLOCATION        
  integer::a,b     
  integer::idum,counter,counter2,idumX,nonredlength
  integer::ij_1
  integer::iteration
  integer, parameter::upper=1     !// FOR LOADING UP THE SCEP MATRIX
  integer, parameter::lower=-1
  integer::ijab_rec
  
  type(twoIntScr),dimension(:),allocatable::scr
  real(real8)::int1
  real(real8),dimension(:,:),allocatable::ab_mo_vecs
  
#ifdef TIGER_FINE_TIMES
   type(clock) :: timer
#endif
  
#ifdef TIGER_USE_OMP
  integer::ten_pointer,numthreads
  numthreads = numberOfThreads
  ! also initialize some omp local communication if needed
  if(.not.allocated(omp_offsets_two_rec)) then
     allocate(omp_offsets_two_rec(num_internal),stat=allocatestatus)
     call allocatecheck(allocatestatus,"omp_offsets_two_rec")
  endif
  if(.not.allocated(omp_offsets_two_icount)) then
    allocate(omp_offsets_two_icount(num_internal), stat=allocatestatus)
    call allocatecheck(allocatestatus,"omp_offsets_two_icount")
  endif
  if(.not.allocated(omp_offsets_two_icount2)) then
    allocate(omp_offsets_two_icount2(num_internal), stat=allocatestatus)
    call allocatecheck(allocatestatus,"omp_offsets_two_icount2")
  endif
#else
  integer,parameter::ten_pointer = 1
  integer,parameter::numthreads = 1
#endif

  !!!!!!!!!!!!!!!!!!!!!!! VARIABLE INITIALIZATION !!!!!!!!!!!!!!!!!!!!!!!!!!!!


  !// INITIALIZE DERIVED TYPES
  lambda_path%occupations = 0
  lambda_path%singles = 0
  lambda_path%arc_weights = 0
  lambda_path%constraints = -1
  lambda_path%encountered = .false.

  lambda_path%num_singles = 0

  !!!!!!!!!!!!!!!!!!!!!!!!!!! START OF ROUTINE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  if (.not.allocated(iaja)) then
      allocate(iaja(num_orbitals-num_internal),stat=allocatestatus)
      call allocatecheck(allocatestatus,"iaja    ")
  endif

  if (.not.allocated(ijaa)) then
      allocate(ijaa(num_orbitals-num_internal),stat=allocatestatus)
      call allocatecheck(allocatestatus,"ijaa    ")
  endif

  iaja = 0 
  ijaa = 0
  mod2vars%ijab_rec = 0

  
#ifdef TIGER_FINE_TIMES
  call start_clock(timer)
#endif
  

  if(iteration .eq. 1) then
  
    counter = 0
    counter2 = 0

    ! now do the actual loops
    do i = 1, num_internal
  
  
#ifdef TIGER_USE_OMP
      ! we create the offsets on the fly here
      omp_offsets_two_icount(i) = counter
      omp_offsets_two_icount2(i) = counter2
      omp_offsets_two_rec(i) = mod2vars%ijab_rec
      ten_pointer = OMP_get_thread_num()+1
#endif
     
      do j = 1,i-1


!***************************************************************************************

         if (ignorable_pair(i,j) ) cycle
         mod2vars%ij_ind = i*(i-1)/2+j

#ifdef TIGER_USE_OMP
         if(.not. integralDirect .or. sphere_based_integral_truncations) then
           do a = num_internal+1,num_orbitals
              if (ignorable_pair(a,i) ) cycle
              if (ignorable_pair(a,j) ) cycle

              do b = num_internal+1,num_orbitals

                 if (ignorable_pair(b,i) ) cycle
                 if (ignorable_pair(b,j) ) cycle
                 if (ignorable_pair(b,a) ) cycle

                 counter = counter + 1
              enddo
            enddo

            do a = num_internal+1,num_orbitals
               if (ignorable_pair(a,i) ) cycle
               if (ignorable_pair(a,j) ) cycle

               do b = num_internal+1,a

                  if (ignorable_pair(b,i) ) cycle
                  if (ignorable_pair(b,j) ) cycle
                  if (ignorable_pair(b,a) ) cycle ! Not this

                  counter2 = counter2 + 1
                
               enddo
            enddo
          endif
#endif
          
            do loops = 1,8

              !// INITIALIZE FOR SUPER SAFETY!
              lambda_path%occupations = 0
              lambda_path%singles = 0
              lambda_path%arc_weights = 0
              lambda_path%constraints = -1
              lambda_path%encountered = .false.
              lambda_path%num_singles = 0

              !// STORE THE LOOP TYPE
              lambda_path%loop_type = loops

              !// NOW LOAD CONSTRAINTS UP AND TRY TO BUILD THE LOOPS
              lambda_path%constraints(2,6) = 1  !// CONSTRAINT COUNT

              !// NEXT TASK
              lambda_path%constraints(1,6) = LMO_2_INT_COMP 

              lambda_path%constraints(2,3) = num_internal+1

              !// FOR BUILDING THE MU PATH
              lambda_path%level1 = j

              !// LOOP LEVELS
              lambda_path%constraints(2,1:2) = (/j,i/)

              !// LAMBDA, MU PATHS
              lambda_path%constraints(1,1:2) = &
                  partial_loops2(loops,1:2,1)
              lambda_path%constraints(3,1:2) = &
                  partial_loops2(loops,1:2,2)

              !// NOW DO THE SEARCH
              lambda_path%num_singles = 0
              call broken_constrained_search(lambda_path,0,0,mod2vars=mod2vars)

            enddo

          enddo
       enddo   
       
  endif ! just for the first iteration
  
  ijab_rec = 0
  counter = 0
  counter2 = 0
  
  allocate(scr(numthreads),stat=allocatestatus)
  call allocatecheck(allocatestatus,"two_internal_seg_direct_cho_scr")
  
  nonredlength = num_external*(num_external+1)/2
  do i=1,numthreads
     allocate(scr(i)%scep_integral_C(num_external*(num_external+1)/2), &
        scr(i)%scep_integral_EX(num_external,num_external), &
        scr(i)%virt_lam_allow(num_external), &
        scr(i)%virt_mu_allow(num_external), &
        scr(i)%Px(fsn(open_shells),fsn(open_shells)), &
        scr(i)%Py(fsn(open_shells),fsn(open_shells)), &
        scr(i)%scep_ci_1(num_external,num_external), & 
        scr(i)%scep_sigma_1(num_external,num_external),stat=allocatestatus)
     call allocatecheck(allocatestatus,"two_internal_seg_direct_cho")
     if(integralDirect .and. .not.sphere_based_integral_truncations .and. .not. .false.) then
        allocate(scr(i)%ia_mo_vecs(numcho,num_external),scr(i)%jb_mo_vecs(numcho,num_external), &
        scr(i)%ij_vec(numcho), &
        stat=allocatestatus)
        call allocatecheck(allocatestatus,"two_internal_seg_direct_cho (direct)")
     endif
  enddo
  
  if(integralDirect .and. .not.sphere_based_integral_truncations .and. .not. .false.) then
     ! allocate and populate |ab) here (we do NOT need to do this redundantly and x-times on N threads... ;-) )
     allocate(ab_mo_vecs(numcho,nonredlength),stat=allocatestatus)
     call allocatecheck(allocatestatus,"two_internal_seg_direct_cho (direct II)")
     
     counter = 1
     do a = num_internal+1,num_orbitals
        ! read in all non-redundant |ab)
        do b = num_internal+1,a
           idum = a*(a-1)/2+b
           idum = cho_data%mo_ind_inv(idum)
           if (idum .ne. 0) then
              call for_double_buf_readblock(mo_int_no, idum, ab_mo_vecs(:,counter), 1)
           else
              ab_mo_vecs(:,counter) = 0.0d0
           endif
           counter = counter+1
        enddo
     enddo
  endif
    
  !$omp parallel &
  !$omp default(none) &
  !$omp private(idum,ten_pointer,counter,counter2,int1,ij_1,ijab_rec,idumX) &
  !$omp shared(civec,sigmavec,ignorable_pair,num_internal,num_orbitals,&
  !$omp omp_offsets_two_icount,omp_offsets_two_icount2,omp_offsets_two_rec, &
  !$omp scr,integralDirect,sphere_based_integral_truncations,cho_data, &
  !$omp num_external,numcho,nonredlength,ab_mo_vecs,fullyIntegralDirect,cdVecsInMemory)
 
  !$omp do &
  !$omp schedule(static)
  do i = 1, num_internal
  
#ifdef TIGER_USE_OMP
     ten_pointer = OMP_get_thread_num()+1
     counter = omp_offsets_two_icount(i)
     counter2 = omp_offsets_two_icount2(i)
     ijab_rec = omp_offsets_two_rec(i)
#endif

#ifdef DEBUG_TIGER
     write(*,*) "DEBUG: ten_pointer in relevant cho",ten_pointer
     write(*,*) "DEBUG: inner offsets for i ", i, counter, counter2
#endif

     if(integralDirect .and. .not.sphere_based_integral_truncations .and. .not. .false.) then
       ! read all (ia| in
       do x = num_internal+1,num_orbitals
         ! i and j are always smaller than a and b
         idum = x*(x-1)/2+i
         idum = cho_data%mo_ind_inv(idum)
              
         if (idum .ne. 0) then
           if(cdVecsInMemory) then
             scr(ten_pointer)%ia_mo_vecs(:,x-num_internal) = cho_data%cho_vectors(:,idum)
           else
             call for_double_buf_readblock(mo_int_no, idum, scr(ten_pointer)%ia_mo_vecs(:,x-num_internal), ten_pointer)
           endif
         else
           scr(ten_pointer)%ia_mo_vecs(:,x-num_internal) = 0.0d0
         endif
       enddo
     endif
     
     do j = 1,i-1


!***************************************************************************************
         idumX = i*(i-1)/2+j

         if (ignorable_pair(i,j) ) cycle
         
          if(integralDirect .and. .not.sphere_based_integral_truncations .and. .not. .false.) then
           ! integral direct mode
            
           ! read in this (ij|, j is smaller than i
           idum=i*(i-1)/2+j
           idum = cho_data%mo_ind_inv(idum)
           if (idum .ne. 0) then
              if(cdVecsInMemory) then
                scr(ten_pointer)%ij_vec = cho_data%cho_vectors(:,idum)
              else
                call for_double_buf_readblock(mo_int_no, idum, scr(ten_pointer)%ij_vec, ten_pointer)
              endif
           else
              scr(ten_pointer)%ij_vec(:) = 0.0d0
           endif
           
            
           ! read all |jb) in
           counter = 1
           do x = num_internal+1,num_orbitals
              ! i and j are always smaller than a and b
              
              idum = x*(x-1)/2+j
              idum = cho_data%mo_ind_inv(idum)
              if (idum .ne. 0) then
                if(cdVecsInMemory) then
                  scr(ten_pointer)%jb_mo_vecs(:,x-num_internal) = cho_data%cho_vectors(:,idum)
                else
                  call for_double_buf_readblock(mo_int_no, idum, scr(ten_pointer)%jb_mo_vecs(:,x-num_internal), ten_pointer)
                endif
              else
                scr(ten_pointer)%jb_mo_vecs(:,x-num_internal) = 0.0d0
              endif
              
           enddo
           
           ! do the matrix multiplication (ia| x |jb)
           call dgemm("T","N",num_external,num_external,numcho,1.0d0,scr(ten_pointer)%ia_mo_vecs,numcho, &
                scr(ten_pointer)%jb_mo_vecs,numcho,0.0d0,scr(ten_pointer)%scep_integral_EX,num_external)
           
           ! do the matrix-vector multiplication for (ij| x |ab) -> turns out to be |ab) * (ij|, but so what ;-)
           call dgemv("T",numcho,nonredlength,1.0d0,ab_mo_vecs,numcho, &
                scr(ten_pointer)%ij_vec,1,0.0d0,scr(ten_pointer)%scep_integral_C,1)
                
          else if(integralDirect .and. .false.) then
          
           ! just set in the magic number...
           scr(ten_pointer)%scep_integral_EX = magic_number
           scr(ten_pointer)%scep_integral_C = magic_number

          else
           ! read integrals in
           scr(ten_pointer)%scep_integral_EX = 0.0D0

           do a = num_internal+1,num_orbitals
              if (ignorable_pair(a,i) ) cycle
              if (ignorable_pair(a,j) ) cycle

              do b = num_internal+1,num_orbitals
  
                 if (ignorable_pair(b,i) ) cycle
                 if (ignorable_pair(b,j) ) cycle
                 if (ignorable_pair(b,a) ) cycle

                 counter = counter + 1
                                  
                 call for_double_buf_readElement(cd_iajb_no,counter,scr(ten_pointer)%scep_integral_EX(a-num_internal,b-num_internal),ten_pointer)
                 
              enddo
            enddo

            scr(ten_pointer)%scep_integral_C = 0.0D0
            do a = num_internal+1,num_orbitals
               if (ignorable_pair(a,i) ) cycle
               if (ignorable_pair(a,j) ) cycle

               do b = num_internal+1,a

                  if (ignorable_pair(b,i) ) cycle
                  if (ignorable_pair(b,j) ) cycle
                  if (ignorable_pair(b,a) ) cycle ! Not this

                  counter2 = counter2 + 1
                  call for_double_buf_readElement(cd_ijab_no,counter2,int1,ten_pointer)

                  ! a is always bigger than b, just read the existing non-redundant integrals into one symmetric "matrix"
                  scr(ten_pointer)%scep_integral_C((a-num_internal)*(a-num_internal-1)/2+(b-num_internal)) = int1
               enddo
            enddo
          endif

          !// WE NEED TO PUT THE DIAGONAL ELEMENTS FOR scep_integral_EX
          ! JMD: I have absolutely no idea what above comment refers to.

          ij_1 = idumX
          do while (ij_1 .eq. idumX)
             call two_int_seg_com_lmo_res(civec, sigmavec, ij_1,scr(ten_pointer)%virt_lam_allow,scr(ten_pointer)%virt_mu_allow, &
                                          ijab_rec,scr(ten_pointer)%Px,scr(ten_pointer)%Py,scr(ten_pointer)%scep_integral_C, &
                                          scr(ten_pointer)%scep_integral_EX,scr(ten_pointer)%scep_ci_1, &
                                          scr(ten_pointer)%scep_sigma_1,cho_data,i,j)
          enddo

      enddo
  enddo
  !$omp end do nowait
  !$omp end parallel
  
  ! deallocation is guaranteed by the fortran standard
  
#ifdef TIGER_FINE_TIMES
  write(*,*) "Timing for relevant two_internal_seg_direct_cho:", get_clock_wall_time(timer)
#endif

end subroutine two_internal_seg_direct_cho
!*****************************************************************
subroutine coupling_coefficient_driver_2(  s1,s2,s3,s4,&
                                           loop, time_through,&
                                           three_seg,&
                                           chain,member,&
                                           lambda_singles,mu_singles,&
                                           Px,Py,&
                                           length)
               
  use spin_var_mod,only:cycles,sft,spin_matrix
  use spin_mod,only:contracted_cycle_stateless
  
  implicit none
  
  !// THIS ROUTINE IS THE DRIVER ROUTINE FOR THE COUPLING COEFFICIENTS
  !// WHEN WE ARE BUILDING LOOPS WITH TWO INTERNAL SEGMENTS.  THE MAIN 
  !// PURPOSE OF THIS ROUTINE IS TO HIDE THE LOGIC OF HOW THE COUPLING
  !// COEFFICIENT ROUTINE IS CALLED.
  
  !!!!!!!!!!!!!!!!!!!!!!!!!!!  VARIABLE DECLARATION !!!!!!!!!!!!!!!!!!!!!!!!!!!
  
  integer,intent(in)::s1,s2,s3,s4         !// NUMBER OF SINGLES
  integer::ibar,jbar,kbar,lbar !// ORBITAL INDICES
  integer,intent(in)::loop                !// LABELS ONE OF THE 8 INTERNAL TWO SEGMENT LOOP FRAGMENTS
  integer,intent(out)::chain               !// LABELS LOOP CHAIN
  integer,intent(out)::member              !// LABLES THE MEMBER
  integer,intent(in)::time_through        !// LABELS THE EXTERNAL FRAGMENT WE ARE ADDING (MORE OR LESS)
  integer,intent(inout)::lambda_singles      !// SINGLES IN THE LAMBDA AND MU PATHS
  integer,intent(inout)::mu_singles 
  integer,intent(in)::length                !// SIZE OF MATRIX ELEMENT ARRAY
  integer::temp                !// TEMPORARY VARIABLE TO HOLD INTEGER
  
  logical,intent(in)::three_seg           !// LABELS WHETHER OR NOT WE ARE COMPUTING COUPLING COEFFICIENTS
                               !// FOR A THREE SEGMENT LOOP
  
  real(real8),dimension(length,length),intent(inout)::Px,Py   !// WHAT WE ARE COMPUTING
    
  !!!!!!!!!!!!!!!!!!!!!!!!!!! START OF ROUTINE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  
  !// FIRST TREAT THE CASE OF THE FIRST 4 LOOP SEGMENTS WHICH CAN
  !// ADD EITHER TWO SEGMENTS OR JUST ONE SEGMENT IN THE EXTERNAL SPACE
  if (loop <= 4) then
  
      !// HANDLE THE CASE THAT WE ARE MAKING A THREE SEGMENT LOOP
      if (three_seg) then
          
          !// HERE WE MUST CALL THE ROUTINE TO GET THE COUPLING COEFFICIENTS.
          if (loop == 1) then
          
              call contracted_cycle_stateless(s1+1,s1+s2+2,0,0,s1+1,0,lambda_singles,mu_singles,Px,cycles,sft,spin_matrix)
              return
          
          elseif (loop == 2) then
          
              call contracted_cycle_stateless(s1,s1+s2,0,0,s1,0,lambda_singles,mu_singles,Px,cycles,sft,spin_matrix)
              return
              
          elseif (loop == 3) then
          
              if (s1 /= s1+s2) then
                  
                  Px = cycles(1:fsn(open_shells):1,1:fsn(open_shells):1,index2m1(s1+s2,s1))
                                                      
                  Px = transpose(Px)
                  return
              
              endif
              
              Px = identity_matrix(fsn(open_shells))
              return
              
          elseif (loop == 4) then
          
              if (s1+s2 /= s1+ 1) then
              
                  Px = cycles(1:fsn(open_shells):1,1:fsn(open_shells):1,index2m1(s1+s2,s1+1))
                  Px = transpose(Px)
                  return
                  
              endif
              
              Px = identity_matrix(fsn(open_shells))                
              return
          
          endif
                          
      endif
      
      !// NOW WE ARE HANDLING THE CASE THAT WE ARE MAKING A FOUR
      !// SEGMENT LOOP.  THERE ARE ONLY FOUR CASES HERE, SO INSTEAD
      !// OF CALLING A SEPARATE ROUTINE TO GET ORBITAL INDICES WE SIMPLY
      !// PASS IN COMBINATIONS OF S1,S2,S3, AND S4.
      if (loop == 1) then
      
          !// CHAIN 1 MEMBER 1
          chain = 1
          member = 1
          
          call compute_coupling_coefficients(chain, member,&
                                             s1+s2+s3+s4,&
                                             s1+s2+s3,&
                                             s1+s2+2,&
                                             s1+1,&
                                             lambda_singles,mu_singles,&
                                             Px,Py,length) 
          return                                           
  
      elseif (loop == 2) then                                           
      
          !// CHAIN 8 MEMBER 6, BE SURE TO PASS IN CHAIN == 4
          chain = 4
          member = 6
          
          call compute_coupling_coefficients(chain, member,&
                                             s1+s2+s3+s4,&
                                             s1+s2+s3,&
                                             s1+s2,&
                                             s1,&
                                             lambda_singles,mu_singles,&
                                             Px,Py,length) 
          return                                           
                                             
      elseif (loop == 3) then
          
          !// CHAIN 5 MEMBER 5, BE SURE TO PASS IN CHAIN == 6
          chain = 6
          member = 5
          
          call compute_coupling_coefficients(chain, member,&
                                             s1+s2+s3+s4,&
                                             s1+s2+s3,&
                                             s1,&
                                             s1+s2,&
                                             lambda_singles,mu_singles,&
                                             Px,Py,length)                                            
          return                                           
                                             
      elseif (loop == 4) then
          
          !// CHAIN 4 MEMBER 5, BE SURE TO PASS IN CHAIN == 5
          chain = 5
          member = 5
          
          call compute_coupling_coefficients(5, 5,&
                                             s1+s2+s3+s4,&
                                             s1+s2+s3,&
                                             s1+s2,&
                                             s1+1,&
                                             lambda_singles,mu_singles,&
                                             Px,Py,length) 
          return                                   
                                                     
      endif
      
  endif       
  
  !// NOW WE HAVE THE MORE COMPLICATED CASE THAT WE ARE BUILDING TWO SEGMENT 
  !// LOOPS.  FOR EACH INTERNAL SEGMENT THERE ARE 6 TYPES OF EXTERNAL SEGMENTS
  !// THAT WE ARE GOING TO JOIN UP TO IT (THE BRANCHES OF THE INTERNAL SEGMENTS
  !// ARE ALSO POSSIBLY GETTING SWAPPED AROUND, BUT WE WORRY ABOUT THAT 
  !// ELSEWHERE).  
  if (loop == 5) then
  
      if (time_through == 1) then
      
          !// CHAIN 8 MEMBER 2, BE SURE TO PASS IN CHAIN == 4
          chain = 4
          member = 2
          
      elseif (time_through == 2) then
      
          !// CHAIN 8 MEMBER 4, BE SURE TO PASS IN CHAIN == 4
          chain = 4
          member = 4
          
      elseif (time_through == 3) then
  
          !// CHAIN 6 MEMBER 5, BE SURE TO PASS IN CHAIN == 7
          chain = 7 
          member = 5
      
      elseif (time_through == 4) then
      
          !// CHAIN 7 MEMBER 5, BE SURE TO PASS IN CHAIN == 8
          chain = 8
          member = 5
      
      elseif (time_through == 5) then
      
          !// CHAIN 1 MEMBER 3
          chain = 1
          member = 3
          
          
          !// SWAP THE NUMBER OF SINGLES
          temp = mu_singles
          mu_singles = lambda_singles
          lambda_singles = temp
                                               
      elseif (time_through == 6) then
      
          !// CHAIN 1 MEMBER 5
          chain = 1
          member = 5
          
          !// SWAP THE NUMBER OF SINGLES
          temp = mu_singles
          mu_singles = lambda_singles
          lambda_singles = temp                                     
                                               
      endif
      
  elseif (loop == 6) then
  
      if (time_through == 1) then
          
          !// CHAIN 8 MEMBER 3 BE SURE TO PASS IN CHAIN == 4        
          chain = 4
          member = 3
      
      elseif (time_through == 2) then
      
          !// CHAIN 8 MEMBER 1 BE SURE TO PASS IN CHAIN == 4
          chain = 4 
          member = 1
          
      
      elseif (time_through == 3) then
      
          !// CHAIN 6 MEMBER 1 BE SURE TO PASS IN CHAIN == 7
          chain = 7
          member = 1
      
      elseif (time_through == 4) then
      
          !// CHAIN 7 MEMBER 1 BE SURE TO PASS IN CHAIN == 8
          chain = 8
          member = 1
      
      elseif (time_through == 5) then
      
          !// CHAIN 1 MEMBER 6
          chain = 1
          member = 6
                                       
          !// SWAP THE NUMBER OF SINGLES
          temp = mu_singles
          mu_singles = lambda_singles
          lambda_singles = temp                                                                          
                                               
      elseif (time_through == 6) then
      
          !// CHAIN 1 MEMBER 4
          chain = 1
          member = 4
          
          !// SWAP THE NUMBER OF SINGLES
          temp = mu_singles
          mu_singles = lambda_singles
          lambda_singles = temp                                     
                                       
      endif
  
  elseif (loop == 7) then
  
      if (time_through == 1) then
      
          !// CHAIN 4 MEMBER 3, BE SURE TO PASS IN CHAIN == 5
          chain = 5
          member = 3
      
      elseif (time_through == 2) then
      
          !// CHAIN 4 MEMBER 1, BE SURE TO PASS IN CHAIN == 5
          chain = 5 
          member = 1
      
      elseif (time_through == 3) then
      
          !// CHAIN 2 MEMBER 1
          chain = 2
          member = 1
      
      elseif (time_through == 4) then
      
          !// CHAIN 3 MEMBER 1
          chain = 3
          member = 1
      
      elseif (time_through == 5) then
          
          !// CHAIN 5 MEMBER 1, BE SURE TO PASS IN CHAIN == 6
          chain = 6
          member = 1
                                       
          !// SWAP THE NUMBER OF SINGLES
          temp = mu_singles
          mu_singles = lambda_singles
          lambda_singles = temp                                                
  
      elseif (time_through == 6) then
      
          !// CHAIN 5 MEMBER 3, BE SURE TO PASS IN CHAIN == 6
          chain = 6
          member = 3
          
          !// SWAP THE NUMBER OF SINGLES
          temp = mu_singles
          mu_singles = lambda_singles
          lambda_singles = temp                                                
      
      endif    
  
  elseif (loop == 8) then
  
      if (time_through == 1) then
      
          !// CHAIN 4 MEMBER 2, BE SURE TO PASS IN CHAIN == 5
          chain = 5 
          member = 2
      
      elseif (time_through == 2) then
      
          !// CHAIN 4 MEMBER 4, BE SURE TO PASS IN CHAIN == 5
          chain = 5
          member = 4
      
      elseif (time_through == 3) then
      
          !// CHAIN 2 MEMBER 3
          chain = 2
          member = 3
  
      elseif (time_through == 4) then
      
          !// CHAIN 3 MEMBER 3
          chain = 3
          member = 3
      
      elseif (time_through == 5) then
      
          !// CHAIN 5 MEMBER 4, BE SURE TO PASS IN CHAIN == 6
          chain = 6
          member = 4
                                       
          !// SWAP THE NUMBER OF SINGLES
          temp = mu_singles
          mu_singles = lambda_singles
          lambda_singles = temp                                                                                     
                                               
      elseif (time_through == 6) then
      
          !// CHAIN 5 MEMBER 2, BE SURE TO PASS IN CHAIN == 6
          chain = 6
          member = 2
          
          !// SWAP THE NUMBER OF SINGLES
          temp = mu_singles
          mu_singles = lambda_singles
          lambda_singles = temp
                                               
      endif    
      
  endif  
    
  call singles_to_2seg_indices(chain,s1,s2,s3,s4,&
                               ibar,jbar,kbar,lbar)
  
  call compute_coupling_coefficients(chain, member,&
                                     ibar,jbar,kbar,lbar,&
                                     lambda_singles,mu_singles,&
                                     Px,Py,length) 
  
end subroutine coupling_coefficient_driver_2
          
  
!*****************************************************************                                     
!*****************************************************************
subroutine set_loops
  
  !// THIS SUBROUTINE IS HERE BECAUSE OF A BUG IN THE DEC COMPILERS (THANK YOU
  !// COMPAQ !!).  MAYBE THEY WILL FIX IT ONE DAY AND WE CAN PUT IT BACK THE
  !// WAY IT WAS
  
  implicit none
  
  !!!!!!!!!!!!!!!!!!
  !//
  !// FOUR SEGMENT OPEN LOOPS
  !//
  !!!!!!!!!!!!!!!!!!
  
      !// CHAIN 1
          full_loops(1,1,1:4,1) = (/0,0,1,1/)
          full_loops(1,1,1:4,2) = (/1,1,0,0/)
  
          full_loops(1,2,1:4,1) = (/2,2,1,1/)
          full_loops(1,2,1:4,2) = (/1,1,2,2/)
  
          full_loops(1,3,1:4,1) = (/2,0,1,1/)
          full_loops(1,3,1:4,2) = (/1,1,2,0/)
          
          full_loops(1,4,1:4,1) = (/0,2,1,1/)
          full_loops(1,4,1:4,2) = (/1,1,0,2/)
  
          full_loops(1,5,1:4,1) = (/2,0,1,1/)
          full_loops(1,5,1:4,2) = (/1,1,0,2/)
  
          full_loops(1,6,1:4,1) = (/0,2,1,1/)
          full_loops(1,6,1:4,2) = (/1,1,2,0/)
  
      !// CHAIN 2
          full_loops(2,1,1:4,1) = (/0,1,0,1/)
          full_loops(2,1,1:4,2) = (/1,0,1,0/)
  
          full_loops(2,2,1:4,1) = (/2,1,2,1/)
          full_loops(2,2,1:4,2) = (/1,2,1,2/)
  
          full_loops(2,3,1:4,1) = (/2,1,0,1/)
          full_loops(2,3,1:4,2) = (/1,2,1,0/)
  
          full_loops(2,4,1:4,1) = (/0,1,2,1/)
          full_loops(2,4,1:4,2) = (/1,0,1,2/)
  
          full_loops(2,5,1:4,1) = (/2,1,0,1/)
          full_loops(2,5,1:4,2) = (/1,0,1,2/)
  
          full_loops(2,6,1:4,1) = (/0,1,2,1/)
          full_loops(2,6,1:4,2) = (/1,2,1,0/)
  
      !// CHAIN 3
          full_loops(3,1,1:4,1) = (/0,1,1,0/)
          full_loops(3,1,1:4,2) = (/1,0,0,1/)
  
          full_loops(3,2,1:4,1) = (/2,1,1,2/)
          full_loops(3,2,1:4,2) = (/1,2,2,1/)
  
          full_loops(3,3,1:4,1) = (/2,1,1,0/)
          full_loops(3,3,1:4,2) = (/1,2,0,1/)
  
          full_loops(3,4,1:4,1) = (/0,1,1,2/)
          full_loops(3,4,1:4,2) = (/1,0,2,1/)
  
          full_loops(3,5,1:4,1) = (/2,1,1,0/)
          full_loops(3,5,1:4,2) = (/1,0,2,1/)
  
          full_loops(3,6,1:4,1) = (/0,1,1,2/)
          full_loops(3,6,1:4,2) = (/1,2,0,1/)
  
      !// CHAIN 8
          full_loops(4,1,1:4,1) = (/1,1,1,1/)
          full_loops(4,1,1:4,2) = (/0,2,2,0/)
  
          full_loops(4,2,1:4,1) = (/1,1,1,1/)
          full_loops(4,2,1:4,2) = (/2,0,0,2/)
  
          full_loops(4,3,1:4,1) = (/1,1,1,1/)
          full_loops(4,3,1:4,2) = (/0,2,0,2/)
  
          full_loops(4,4,1:4,1) = (/1,1,1,1/)
          full_loops(4,4,1:4,2) = (/2,0,2,0/)
  
          full_loops(4,5,1:4,1) = (/1,1,1,1/)
          full_loops(4,5,1:4,2) = (/0,0,2,2/)
  
          full_loops(4,6,1:4,1) = (/1,1,1,1/)
          full_loops(4,6,1:4,2) = (/2,2,0,0/)
  
      !// CHAIN = 4
          full_loops(5,1,1:4,1) = (/0,1,1,1/)
          full_loops(5,1,1:4,2) = (/1,0,2,0/)
  
          full_loops(5,2,1:4,1) = (/2,1,1,1/)
          full_loops(5,2,1:4,2) = (/1,2,0,2/)
  
          full_loops(5,3,1:4,1) = (/0,1,1,1/)
          full_loops(5,3,1:4,2) = (/1,0,0,2/)
  
          full_loops(5,4,1:4,1) = (/2,1,1,1/)
          full_loops(5,4,1:4,2) = (/1,2,2,0/)
  
          full_loops(5,5,1:4,1) = (/0,1,1,1/)
          full_loops(5,5,1:4,2) = (/1,2,0,0/)
  
          full_loops(5,6,1:4,1) = (/2,1,1,1/)
          full_loops(5,6,1:4,2) = (/1,0,2,2/)
  
      !// CHAIN = 5
          full_loops(6,1,1:4,1) = (/1,0,1,1/)
          full_loops(6,1,1:4,2) = (/0,1,2,0/)
  
          full_loops(6,2,1:4,1) = (/1,2,1,1/)
          full_loops(6,2,1:4,2) = (/2,1,0,2/)
  
          full_loops(6,3,1:4,1) = (/1,0,1,1/)
          full_loops(6,3,1:4,2) = (/0,1,0,2/)
  
          full_loops(6,4,1:4,1) = (/1,2,1,1/)
          full_loops(6,4,1:4,2) = (/2,1,2,0/)
  
          full_loops(6,5,1:4,1) = (/1,0,1,1/)
          full_loops(6,5,1:4,2) = (/2,1,0,0/)
  
          full_loops(6,6,1:4,1) = (/1,2,1,1/)
          full_loops(6,6,1:4,2) = (/0,1,2,2/)
  
      !// CHAIN = 6
          full_loops(7,1,1:4,1) = (/1,1,0,1/)
          full_loops(7,1,1:4,2) = (/0,2,1,0/)
  
          full_loops(7,2,1:4,1) = (/1,1,2,1/)
          full_loops(7,2,1:4,2) = (/2,0,1,2/)
  
          full_loops(7,3,1:4,1) = (/1,1,0,1/)
          full_loops(7,3,1:4,2) = (/0,0,1,2/)
  
          full_loops(7,4,1:4,1) = (/1,1,2,1/)
          full_loops(7,4,1:4,2) = (/2,2,1,0/)
  
          full_loops(7,5,1:4,1) = (/1,1,0,1/)
          full_loops(7,5,1:4,2) = (/2,0,1,0/)
  
          full_loops(7,6,1:4,1) = (/1,1,2,1/)
          full_loops(7,6,1:4,2) = (/0,2,1,2/)
  
      !// CHAIN = 7
          full_loops(8,1,1:4,1) = (/1,1,1,0/)
          full_loops(8,1,1:4,2) = (/0,2,0,1/)
  
          full_loops(8,2,1:4,1) = (/1,1,1,2/)
          full_loops(8,2,1:4,2) = (/2,0,2,1/)
  
          full_loops(8,3,1:4,1) = (/1,1,1,0/)
          full_loops(8,3,1:4,2) = (/0,0,2,1/)
  
          full_loops(8,4,1:4,1) = (/1,1,1,2/)
          full_loops(8,4,1:4,2) = (/2,2,0,1/)
  
          full_loops(8,5,1:4,1) = (/1,1,1,0/)
          full_loops(8,5,1:4,2) = (/2,0,0,1/)
  
          full_loops(8,6,1:4,1) = (/1,1,1,2/)
          full_loops(8,6,1:4,2) = (/0,2,2,1/)

  !!!!!!!!!!!!!!!!!!
  !//
  !// THREE SEGMENT OPEN LOOPS   VECTORIZED MODE .. SEE CPR PAPER 
  !// BY W. DUCH AND KARWOWSKI.
  !//
  !!!!!!!!!!!!!!!!!!
  
      !// CHAIN 1  (C1')
          partial_loops3_vec(1,1,1:3,1) = (/0,1,1/)
          partial_loops3_vec(1,1,1:3,2) = (/1,0,0/)
  
          partial_loops3_vec(1,2,1:3,1) = (/2,1,1/)
          partial_loops3_vec(1,2,1:3,2) = (/1,2,0/)
  
          partial_loops3_vec(1,3,1:3,1) = (/2,1,1/)
          partial_loops3_vec(1,3,1:3,2) = (/1,0,2/)
  
      !// CHAIN 2 (C2')
          partial_loops3_vec(2,1,1:3,1) = (/1,0,1/)
          partial_loops3_vec(2,1,1:3,2) = (/0,1,0/)
  
          partial_loops3_vec(2,2,1:3,1) = (/1,2,1/)
          partial_loops3_vec(2,2,1:3,2) = (/2,1,0/)
  
          partial_loops3_vec(2,3,1:3,1) = (/1,2,1/)
          partial_loops3_vec(2,3,1:3,2) = (/0,1,2/)
  
      !// CHAIN 3 (C3')
          partial_loops3_vec(3,1,1:3,1) = (/1,1,0/)
          partial_loops3_vec(3,1,1:3,2) = (/0,0,1/)
  
          partial_loops3_vec(3,2,1:3,1) = (/1,1,2/)
          partial_loops3_vec(3,2,1:3,2) = (/2,0,1/)
  
          partial_loops3_vec(3,3,1:3,1) = (/1,1,2/)
          partial_loops3_vec(3,3,1:3,2) = (/0,2,1/)
  
      !// CHAIN 4 (C4') 
  
          partial_loops3_vec(4,1,1:3,1) = (/1,1,1/)
          partial_loops3_vec(4,1,1:3,2) = (/2,0,0/)
  
          partial_loops3_vec(4,2,1:3,1) = (/1,1,1/)
          partial_loops3_vec(4,2,1:3,2) = (/0,2,0/)
  
          partial_loops3_vec(4,3,1:3,1) = (/1,1,1/)
          partial_loops3_vec(4,3,1:3,2) = (/0,0,2/)
  
      !// CHAIN 5 (C1")  
          partial_loops3_vec(5,1,1:3,1) = (/2,1,1/)
          partial_loops3_vec(5,1,1:3,2) = (/1,2,2/)
  
          partial_loops3_vec(5,2,1:3,1) = (/0,1,1/)
          partial_loops3_vec(5,2,1:3,2) = (/1,0,2/)
  
          partial_loops3_vec(5,3,1:3,1) = (/0,1,1/)
          partial_loops3_vec(5,3,1:3,2) = (/1,2,0/)
          
      !// CHAIN 6 (C2")
          partial_loops3_vec(6,1,1:3,1) = (/1,2,1/)
          partial_loops3_vec(6,1,1:3,2) = (/2,1,2/)
  
          partial_loops3_vec(6,2,1:3,1) = (/1,0,1/)
          partial_loops3_vec(6,2,1:3,2) = (/0,1,2/)
  
          partial_loops3_vec(6,3,1:3,1) = (/1,0,1/)
          partial_loops3_vec(6,3,1:3,2) = (/2,1,0/)
  
      !// CHAIN 7 (C3")
          partial_loops3_vec(7,1,1:3,1) = (/1,1,2/)
          partial_loops3_vec(7,1,1:3,2) = (/2,2,1/)
  
          partial_loops3_vec(7,2,1:3,1) = (/1,1,0/)
          partial_loops3_vec(7,2,1:3,2) = (/0,2,1/)
  
          partial_loops3_vec(7,3,1:3,1) = (/1,1,0/)
          partial_loops3_vec(7,3,1:3,2) = (/2,0,1/)
  
      !// CHAIN 8 (C4")
          partial_loops3_vec(8,1,1:3,1) = (/1,1,1/)
          partial_loops3_vec(8,1,1:3,2) = (/0,2,2/)
  
          partial_loops3_vec(8,2,1:3,1) = (/1,1,1/)
          partial_loops3_vec(8,2,1:3,2) = (/2,0,2/)
  
          partial_loops3_vec(8,3,1:3,1) = (/1,1,1/)
          partial_loops3_vec(8,3,1:3,2) = (/2,2,0/)
     
  
  !!!!!!!!!!!!!!!!!!!!!!!!!!!
  !// 
  !// TWO SEGMENT IJAJ LOOPS : 
  !// VECTORIZED MODE : SEE THREE SEGMENT LOOPS CHART  
  !// 
  !!!!!!!!!!!!!!!!!!!!!!!!!!!
  
  
          !// CHAIN 10  B2 - 3  
          two_seg_ijaj_loops(1,1:2,1) = (/1,0/)
          two_seg_ijaj_loops(1,1:2,2) = (/0,2/)
  
          !// CHAIN 11  B2 - 5
          two_seg_ijaj_loops(2,1:2,1) = (/0,1/)
          two_seg_ijaj_loops(2,1:2,2) = (/2,0/)
  
          !// CHAIN 12  B2 - 4
          two_seg_ijaj_loops(3,1:2,1) = (/1,2/)
          two_seg_ijaj_loops(3,1:2,2) = (/2,0/)
  
          !// CHAIN 13  B2 - 6
          two_seg_ijaj_loops(4,1:2,1) = (/2,1/)
          two_seg_ijaj_loops(4,1:2,2) = (/0,2/)
  
  
  !!!!!!!!!!!!!!!!!!
  !//
  !// TWO SEGMENT OPEN LOOPS
  !//
  !!!!!!!!!!!!!!!!!!
      
      !// OPEN LOOPS
          partial_loops2(1,1:2,1) = (/0,0/)
          partial_loops2(1,1:2,2) = (/1,1/)
  
          partial_loops2(2,1:2,1) = (/1,1/)
          partial_loops2(2,1:2,2) = (/2,2/)
  
          partial_loops2(3,1:2,1) = (/1,0/)
          partial_loops2(3,1:2,2) = (/2,1/)
  
          partial_loops2(4,1:2,1) = (/0,1/)
          partial_loops2(4,1:2,2) = (/1,2/)
          
      !// CLOSED LOOPS        
          partial_loops2(5,1:2,1) = (/1,1/)
          partial_loops2(5,1:2,2) = (/2,0/)
  
          partial_loops2(6,1:2,1) = (/1,1/)
          partial_loops2(6,1:2,2) = (/0,2/)
  
          partial_loops2(7,1:2,1) = (/0,1/)
          partial_loops2(7,1:2,2) = (/1,0/)
  
          partial_loops2(8,1:2,1) = (/2,1/)
          partial_loops2(8,1:2,2) = (/1,2/)        
  
  
end subroutine set_loops
  
!*****************************************************************
subroutine get_Jx_Jy_index(member,chain,Jx_index,Jy_index,Jx_mult,Jy_mult)
  
  !// IN INTEGRAL BUFFER OUR INTEGRALS ARE STORED IN COLUMNS WHERE
  !// THE FIRST COLUMN HAS THE (IJ|KL), THE SECOND HAS (IL|JK), AND THE
  !// THIRD IS (IK|JL).  HERE, WE DETERMINE WHICH COLUMN OF INTEGRALS
  !// SHOULD BE COMBINED WITH THE APPROPRIATE COUPLING COEFFICIENT.                                     
  
  !!!!!!!!!!!!!!!!!!!!!!!!!!!  VARIABLE DECLARATION !!!!!!!!!!!!!!!!!!!!!!!!!!!                                   
  implicit none
  
  integer,intent(in)::member         !// LOOP CHAIN
  integer,intent(in)::chain          !// MEMBER WITHIN CHAIN 
  integer,intent(out)::Jx_index       !// COLUMN OF INTEGRALS TO COMBINE WITH Px,Py
  integer,intent(out)::Jy_index
  integer, parameter::ijkl=1      !// ORDER OF INTEGRAL STORAGE: I>J>K>L.
  integer, parameter::iljk=2      !//   THESE ARE THE J_1,J_2, AND J_3
  integer, parameter::ikjl=3
  integer::j1,j2,j3               !// ACTUALLY, SHOULD BE J^1,J^2,J^3
  
  real(real8),intent(out)::Jx_mult,Jy_mult    !// IN CASE INTEGRALS NEED TO BE MULTIPLIED BY +-1
  real(real8),parameter::one=real(1.0,real8)
  j1 = 0
  j2 = 0
  j3 = 0
  
  !!!!!!!!!!!!!!!!!!!!!!!!!!! START OF ROUTINE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  Jx_mult = one
  Jy_mult = one
  
  !// LOOK AT THE CPR PAPER ON THE BOTTOM PART OF PAGE 157.  THIS FIRST PART
  !// TAKES US FROM J_1 TO J^1, ETC.  
  
  if (chain == 1.or.&
      chain == 4.or.&
      chain == 5) then
      
      !// C1,C8 AND C4 LOOPS
      j1 = ijkl
      j2 = iljk
      j3 = ikjl
      
  elseif (chain == 2) then    
  
      !// C2 LOOPS
      j1 = ikjl
      j2 = iljk
      j3 = ijkl
      
  elseif (chain == 3) then
  
      !// C3 LOOPS
      j1 = iljk
      j2 = ikjl
      j3 = ijkl
      
  elseif (chain == 6) then
      
      !// C5 LOOPS
      j1 = ijkl
      j2 = ikjl
      j3 = iljk
  
  elseif (chain == 7) then
  
      !// C6 LOOPS
      j1 = ikjl
      j2 = ijkl
      j3 = iljk
  
  elseif (chain == 8) then
  
      !// C7 LOOPS
      j1 = iljk
      j2 = ijkl
      j3 = ikjl
  
  endif
  
  
  !// NOW, JUST SET JX_INDEX AND JY_INDEX TO THE ONES WE NEED.  THIS MIGHT NOT
  !// BE THE MOST EFFICIENT SORT, BUT IT WILL WORK AND THE OVERHEAD IS MINIMAL    
  if (chain <= 3) then
       
       !// C1,C2,C3 LOOPS
       if (member <= 2) then
          
           Jx_index = j3
           Jy_index = j2
       
       elseif (member == 3.or.member == 4) then
       
           Jx_index = j3
           Jy_index = j1
           
       elseif (member >= 5) then
       
           Jx_index = j2
           Jy_index = j1
           
       endif
       
  elseif (chain == 4) then
  
      !// C8 LOOPS
      if (member <= 2) then
      
           Jx_index = j1
           Jy_index = j3        
       
      elseif (member == 3.or.member == 4) then
      
           Jx_index = j1
           Jy_index = j2
      
      elseif (member >= 5) then
      
           Jx_index = j3
           Jy_index = j2
       
      endif
  
  else 
  
      !// C4, C5, C6, C7 LOOPS
      if (member == 1) then
      
           Jx_index = j1
           Jy_index = j2
           
      elseif (member == 2) then
      
           Jx_index = j1
           Jy_index = j2
           
      elseif (member == 3) then
      
           Jx_index = j1
           Jy_index = j3
           
      elseif (member == 4) then
      
           Jx_index = j1
           Jy_index = j3
           
      elseif (member == 5) then
      
           Jx_index = j2
           Jy_index = j3
      
      elseif (member == 6) then
      
           Jx_index = j2
           Jy_index = j3
           
      endif
      
  endif
  
end subroutine get_Jx_Jy_index
  
  
  
!*****************************************************************
!*****************************************************************
subroutine internal_cc_driver(Px,Py,mat_dim,loop_type,s1,s2,lambda_singles, &
                                mu_singles, doublet_flag)
                                
  use spin_var_mod,only:cycles,sft,spin_matrix
  use spin_mod,only:contracted_cycle_stateless
  
  implicit none
  
  integer,intent(in)::loop_type                    !// TYPE OF LOOP
  integer,intent(in)::s1,s2                        !// SINGLE POSITIONS - USED TO GET IBAR, JBAR
  integer,intent(in)::lambda_singles, mu_singles   !// NUMBERS OF TOTAL SINGLES
  integer::lambda_dim, mu_dim           !// DIMENSIONS OF SPIN SPACE
  integer::ibar, jbar                   !// FOR GETTING CC
  integer::mat_dim                      !// DIMENSIONS OF MATRICES
  integer,intent(in)::doublet_flag                 !// = 1 IF WE HAVE DOUBLET COUPLING IN THE EXTERNAL SPACE
  integer::i,j                          !// VARIABLES
  integer::lambdam2_dim, mum2_dim        !// SPIN SPACE DIMENSIONS WHEN NUMBER OF SPIN FUNCTIONS IS
                                        !//  REDUCED BY TWO
                                        
  real(real8),parameter::sqTwo=sqrt(real(2.0,real8))
  
  real(real8),intent(inout)::Px(mat_dim,mat_dim), Py(mat_dim, mat_dim)
  mu_dim = 0
  lambda_dim = 0
  
  if (loop_type == 8) then
  
      !// {57} LOOP IN THE INTERNAL SPACE
      ibar = s1+s2
      jbar = s1+1
      
      lambda_dim = fsn(lambda_singles)
      mu_dim = fsn(mu_singles)
      
      !// FIRST GET PX
      if (ibar /= jbar) then
          Px(1:lambda_dim,1:mu_dim) = -transpose(cycles(1:lambda_dim,1:mu_dim,index2(ibar-1,jbar)))
      else
          Px(1:lambda_dim,1:mu_dim) = -identity_matrix(lambda_dim)
      endif           
      
      !// NOW GET PY, STORE A TEMP MATRIX IN 
      call contracted_cycle_stateless(jbar, lambda_singles, lambda_singles-1,ibar,0,0,lambda_singles,mu_singles,Py,cycles,sft,spin_matrix)
      Py = Py - Px
      
  elseif (loop_type == 7) then
  
      !// {13} LOOP IN THE INTERNAL SPACE
      ibar = s1+s2
      jbar = s1+1
      
      lambda_dim = fsn(lambda_singles)
      mu_dim = fsn(mu_singles)
      
      !// FIRST GET PX
      if (ibar /= jbar) then
          Px(1:lambda_dim,1:mu_dim) = transpose(cycles(1:lambda_dim,1:mu_dim,index2(ibar-1,jbar)))
      else
          Px(1:lambda_dim,1:mu_dim) = identity_matrix(lambda_dim)
      endif           
      
      !// NOW GET PY, STORE A TEMP MATRIX IN 
      call contracted_cycle_stateless(jbar, lambda_singles, lambda_singles-1,ibar,0,0,lambda_singles,mu_singles,Py,cycles,sft,spin_matrix)
      
  elseif (loop_type == 6) then
  
      !// {35} LOOP IN THE INTERNAL SPACE
      ibar = s1+s2
      jbar = s1
      
      lambda_dim = fsn(lambda_singles)
      mu_dim = fsn(mu_singles)
      
      !// FIRST GET PX
      call contracted_cycle_stateless(jbar, ibar,0,0,jbar,0,lambda_singles,mu_singles,Px,cycles,sft,spin_matrix)
      
      !// NOW GET PY, STORE A TEMP MATRIX IN 
      call contracted_cycle_stateless(lambda_singles-2, jbar,lambda_singles-1,ibar,0,0,lambda_singles,mu_singles,Py,cycles,sft,spin_matrix)
      Py = Py*sqTwo
      
  elseif (loop_type == 5) then   
  
      !// {53} LOOP IN THE INTERNAL SPACE
      ibar = s1+s2
      jbar = s1
      
      lambda_dim = fsn(lambda_singles)
      mu_dim = fsn(mu_singles)
      
      !// FIRST GET PX
      call contracted_cycle_stateless(jbar, ibar,0,0,jbar,0,lambda_singles,mu_singles,Px,cycles,sft,spin_matrix)
      
      !// NOW GET PY, STORE A TEMP MATRIX IN 
      call contracted_cycle_stateless(lambda_singles, jbar,lambda_singles-1,ibar,0,0,lambda_singles,mu_singles,Py,cycles,sft,spin_matrix)
      Py = Py*sqTwo
      
  endif    
  
  
  !// TAKE CARE OF THE SIGN CHANGE FOR TRIPLET COUPLING, BUT DON'T DO THIS
  !// IF WE HAVE DOUBLET COUPLING IN THE EXTERNAL SPACE
  if (doublet_flag == 1) return
  if (lambda_singles-2 >= 0) then
      lambdam2_dim = fsn(lambda_singles-2)
      do i = lambdam2_dim+1, lambda_dim
          Py(i,:) = -Py(i,:)
      enddo            
  endif        
      
  if (mu_singles-2 >= 0) then
      mum2_dim     = fsn(mu_singles-2)
      do j = mum2_dim+1, mu_dim
          Py(:,j) = - Py(:,j)
      enddo        
  endif        
  
end subroutine internal_cc_driver
  
  
subroutine coupling_coeff_and_integrals(chain, member, &
                                         ibar, jbar, kbar, lbar,&
                                         lambda_singles, mu_singles,&
                                         j1,j2,j3,skip,&
                                         Jx,Jy,Px,Py)
                                         
  use spin_mod,only:contracted_cycle_stateless
  use spin_var_mod,only:cycles,sft,spin_matrix
  
  implicit none
                                           
  !!!!!!!!!!!!!!!!!!!!!!!!!!!  VARIABLE DECLARATION !!!!!!!!!!!!!!!!!!!!!!!!!!!
  integer,intent(in)::chain                  !// LOOP CHAIN
  integer,intent(in)::member                 !// LOOP WITHIN A CHAIN
  integer,intent(in)::ibar,jbar,kbar,lbar    !// ORBITAL POSITION INDICES
  integer,intent(in)::lambda_singles         !// NUMBER OF SINGLES IN MU AND LAMBDA PATH
  integer,intent(in)::mu_singles
  !integer,intent(in)::length                   !// SIZE OF SQUARE MATRIX COEFF_TEMP
  
  logical,intent(out)::skip                   !// SET TO TRUE IF THE INTEGRALS ARE BELOW A THRESHOLD
  
  real(real8),intent(in)::j1,j2,j3           !// INTEGRALS, SORTED APPROPRIATELY
  real(real8),intent(out)::Jx,Jy              !// INTEGRALS WHICH GO WITH APPROPRIATE COUPLING COEFFICIENTS
  real(real8),intent(inout),dimension(:,:):: Px,Py  !// COUPLING COEFFICIENTS 
  
  real(real8),dimension(:,:),allocatable::locContracted ! some scratch space
  integer::nsfl,nsfr,maxD
  integer::status
  
  !!!!!!!!!!!!!!!!!!!!!!!!!!! START OF ROUTINE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  ! WE HAVE A CONTRACT WITH CLIENT CODE NOW, THAT IT ACTUALLY RESPECTS AND CHECKS skip
  ! MEANING: WE ARE NOT RESPONSIBLE ANYMORE TO THEN ALSO RETURN ZERO'D INTEGRALS/COUPLING COEFFS
  !jx = real(0.0,real8)
  !jy = real(0.0,real8)
  !Px = real(0.0,real8)
  !Py = real(0.0,real8)
  
  skip = .false.
  
  nsfl = fsn(lambda_singles)
  nsfr = fsn(mu_singles)
  maxD = max(nsfl,nsfr)
  
  allocate(locContracted(maxD,maxD),stat=status)
  call allocatecheck(status,"coupling_coeff_and_integrals")
  
  if (chain <= 3) then
       
      !// C1,C2,C3 LOOPS
      if (member <= 2) then
          
          !// PX = P3, PY = P2
          
          if (abs(j3) <= integral_threshold.and.abs(j2) <= integral_threshold) then
              skip = .true.
              return
          endif
          
          !// FIRST PX
          call contracted_cycle_stateless(kbar,ibar,lbar,jbar,0,0,lambda_singles,mu_singles,Px,cycles,sft,spin_matrix)
          Jx = j3
          
          !// NOW PY
          call contracted_cycle_stateless(kbar,jbar+1,lbar,ibar,0,0,lambda_singles,mu_singles,Py,cycles,sft,spin_matrix)
          Jy = j2
          
      elseif (member == 3.or.member == 4) then
          
          !// PX = -P3, PY = P1 = P2+P3
          
          if (abs(j3) <= integral_threshold.and.abs(j1) <= integral_threshold) then
              skip = .true.
              return
          endif
          
          !// FIRST PX
          call contracted_cycle_stateless(kbar,ibar,lbar,jbar,0,0,lambda_singles,mu_singles,Px,cycles,sft,spin_matrix)
          Jx =  j3    
          Px(1:maxD,1:maxD) = -Px(1:maxD,1:maxD)
          
          !// NOW PY
          call contracted_cycle_stateless(kbar,jbar+1,lbar,ibar,0,0,lambda_singles,mu_singles,Py,cycles,sft,spin_matrix)
          Jy = j1
          
          call contracted_cycle_stateless(kbar,ibar,lbar,jbar,0,0,lambda_singles,mu_singles,locContracted,cycles,sft,spin_matrix)
          Py(1:maxD,1:maxD) = Py(1:maxD,1:maxD) + locContracted
          
      elseif (member >= 5) then
          
          
          !// PX = -P2, PY = P1 = P2+P3
          if (abs(j2) <= integral_threshold.and.abs(j1) <= integral_threshold) then
              skip = .true.
              return
          endif
          
          
          !// FIRST PX
          call contracted_cycle_stateless(kbar,jbar+1,lbar,ibar,0,0,lambda_singles,mu_singles,Px,cycles,sft,spin_matrix)
          Jx =  j2    
          Px(1:maxD,1:maxD) = -Px(1:maxD,1:maxD)
          
          !// NOW PY
          call contracted_cycle_stateless(kbar,jbar+1,lbar,ibar,0,0,lambda_singles,mu_singles,Py,cycles,sft,spin_matrix)
          Jy =  j1
          
          call contracted_cycle_stateless(kbar,ibar,lbar,jbar,0,0,lambda_singles,mu_singles,locContracted,cycles,sft,spin_matrix)
          Py(1:maxD,1:maxD) = Py(1:maxD,1:maxD) + locContracted
          
      endif
      
  elseif (chain == 4) then
      
      !// C8 LOOPS
      if (member <= 2) then
          
          !// PX = P1, PY = P3
          
          if (abs(j3) <= integral_threshold.and.abs(j1) <= integral_threshold) then
              skip = .true.
              return
          endif
          
          !// FIRST PX
          call contracted_cycle_stateless(jbar,ibar,lbar,kbar,jbar,lbar,lambda_singles,mu_singles,Px,cycles,sft,spin_matrix)
          Jx =  j1
          
          !// NOW PY
          call contracted_cycle_stateless(kbar+1,ibar,lbar,jbar,kbar+1,lbar,lambda_singles,mu_singles,Py,cycles,sft,spin_matrix)
          Jy =  j3
          
      elseif (member == 3.or.member == 4) then
          
          !// PX = P1, PY = P2
          
          if (abs(j2) <= integral_threshold.and.abs(j1) <= integral_threshold) then
              skip = .true.
              return
          endif
          
          !// FIRST PX
          call contracted_cycle_stateless(jbar,ibar,lbar,kbar,jbar,lbar,lambda_singles,mu_singles,Px,cycles,sft,spin_matrix)
          Jx =  j1
          
          !// NOW PY
          call contracted_cycle_stateless(lbar,ibar,jbar,kbar,jbar,lbar,lambda_singles,mu_singles,Py,cycles,sft,spin_matrix)
          Jy =  j2
          
      elseif (member >= 5) then
          
          !// PX = P3, PY = P2 
          
          if (abs(j2) <= integral_threshold.and.abs(j3) <= integral_threshold) then
              skip = .true.
              return
          endif
          
          !// FIRST PX
          call contracted_cycle_stateless(kbar+1,ibar,lbar,jbar,kbar+1,lbar,lambda_singles,mu_singles,Px,cycles,sft,spin_matrix)
          Jx =  j3
          
          !// NOW PY
          call contracted_cycle_stateless(lbar,ibar,jbar,kbar,jbar,lbar,lambda_singles,mu_singles,Py,cycles,sft,spin_matrix)
          Jy =  j2
          
      endif
      
  elseif (chain == 5) then
      
      !// C4 LOOPS
      if (member == 1) then
          
          !// PX = P1, PY = P2
          
          if (abs(j2) <= integral_threshold.and.abs(j1) <= integral_threshold) then
              skip = .true.
              return
          endif
          
          !// FIRST PX
          call contracted_cycle_stateless(lbar,kbar,jbar,ibar,jbar,0,lambda_singles,mu_singles,Px,cycles,sft,spin_matrix)
          Jx =  j1
          
          !// NOW PY
          call contracted_cycle_stateless(lbar,ibar,kbar,jbar,kbar+1,0,lambda_singles,mu_singles,Py,cycles,sft,spin_matrix)
          Jy =  j2
          
      elseif (member == 2) then
          
          !// PX = -P1, PY = P2' = P1 + P3
          if (abs(j2) <= integral_threshold.and.abs(j1) <= integral_threshold) then
              skip = .true.
              return
          endif
          
          !// FIRST PX
          call contracted_cycle_stateless(lbar,kbar,jbar,ibar,jbar,0,lambda_singles,mu_singles,Px,cycles,sft,spin_matrix)
          Jx =  j1
          Px(1:maxD,1:maxD) = -Px(1:maxD,1:maxD)
          
          !// NOW PY
          call contracted_cycle_stateless(lbar,kbar,jbar,ibar,jbar,0,lambda_singles,mu_singles,Py,cycles,sft,spin_matrix)
          Jy =  j2
          
          call contracted_cycle_stateless(lbar,jbar+1,kbar,ibar,kbar+1,0,lambda_singles,mu_singles,locContracted,cycles,sft,spin_matrix)
          Py(1:maxD,1:maxD) = Py(1:maxD,1:maxD) + locContracted
          
      elseif (member == 3) then
          
          !// PX = P1, PY = P3
          
          if (abs(j3) <= integral_threshold.and.abs(j1) <= integral_threshold) then
              skip = .true.
              return
          endif
          
          !// FIRST PX
          call contracted_cycle_stateless(lbar,kbar,jbar,ibar,jbar,0,lambda_singles,mu_singles,Px,cycles,sft,spin_matrix)
          Jx =  j1
          
          !// NOW PY
          call contracted_cycle_stateless(lbar,jbar+1,kbar,ibar,kbar+1,0,lambda_singles,mu_singles,Py,cycles,sft,spin_matrix)
          Jy =  j3
          
      elseif (member == 4) then
          
          !// PX = -P1, PY = P3' = P1 + P2
          
          if (abs(j3) <= integral_threshold.and.abs(j1) <= integral_threshold) then
              skip = .true.
              return
          endif
          
          !// FIRST PX
          call contracted_cycle_stateless(lbar,kbar,jbar,ibar,jbar,0,lambda_singles,mu_singles,Px,cycles,sft,spin_matrix)
          Jx =  j1
          Px(1:maxD,1:maxD) = -Px(1:maxD,1:maxD)
          
          !// NOW PY
          call contracted_cycle_stateless(lbar,kbar,jbar,ibar,jbar,0,lambda_singles,mu_singles,Py,cycles,sft,spin_matrix)
          Jy =  j3
          
          call contracted_cycle_stateless(lbar,ibar,kbar,jbar,kbar+1,0,lambda_singles,mu_singles,locContracted,cycles,sft,spin_matrix)
          Py(1:maxD,1:maxD) = Py(1:maxD,1:maxD) + locContracted
          
      elseif (member == 5) then
          
          !// PX = P2, PY = P3
          
          if (abs(j3) <= integral_threshold.and.abs(j2) <= integral_threshold) then
              skip = .true.
              return
          endif
          
          !// FIRST PX
          call contracted_cycle_stateless(lbar,ibar,kbar,jbar,kbar+1,0,lambda_singles,mu_singles,Px,cycles,sft,spin_matrix)
          Jx =  j2
          
          !// NOW PY
          call contracted_cycle_stateless(lbar,jbar+1,kbar,ibar,kbar+1,0,lambda_singles,mu_singles,Py,cycles,sft,spin_matrix)
          Jy =  j3
          
      elseif (member == 6) then
          
          !// PX = -P2, PY = P3' = P1+P2
          
          if (abs(j3) <= integral_threshold.and.abs(j2) <= integral_threshold) then
              skip = .true.
              return
          endif
          
          !// FIRST PX
          call contracted_cycle_stateless(lbar,ibar,kbar,jbar,kbar+1,0,lambda_singles,mu_singles,Px,cycles,sft,spin_matrix)
          Jx =  j2
          Px(1:maxD,1:maxD) = -Px(1:maxD,1:maxD)
          
          !// NOW PY
          call contracted_cycle_stateless(lbar,kbar,jbar,ibar,jbar,0,lambda_singles,mu_singles,Py,cycles,sft,spin_matrix)
          Jy =  j3
          
          call contracted_cycle_stateless(lbar,ibar,kbar,jbar,kbar+1,0,lambda_singles,mu_singles,locContracted,cycles,sft,spin_matrix)
          Py(1:maxD,1:maxD) = Py(1:maxD,1:maxD) + locContracted
          
      endif
      
  elseif (chain == 6) then
      
      !// C5 LOOPS.  THESE ONES ARE JUST THE SAME AS THE C4 LOOPS EXCEPT IN P2 AND
      !// P3 WE USE D1 = KBAR INSTEAD OF D1 = KBAR + 1.  ADDITIONALLY, WE NEED
      !// TO USE LBAR+2 FOR P2 AND P3.  THIS IS ANOTHER ERRATA IN WLODEK'S PAPER.
      if (member == 1) then
          
          !// PX = P1, PY = P2
          
          if (abs(j1) <= integral_threshold.and.abs(j2) <= integral_threshold) then
              skip = .true.
              return
          endif
          
          !// FIRST PX
          call contracted_cycle_stateless(lbar,kbar,jbar,ibar,jbar,0,lambda_singles,mu_singles,Px,cycles,sft,spin_matrix)
          Jx =  j1
          
          !// NOW PY
          call contracted_cycle_stateless(lbar+2,ibar,kbar,jbar,kbar,0,lambda_singles,mu_singles,Py,cycles,sft,spin_matrix)
          Jy =  j2
          
      elseif (member == 2) then
          
          !// PX = -P1, PY = P2' = P1 + P3
          
          if (abs(j1) <= integral_threshold.and.abs(j2) <= integral_threshold) then
              skip = .true.
              return
          endif
          
          !// FIRST PX
          call contracted_cycle_stateless(lbar,kbar,jbar,ibar,jbar,0,lambda_singles,mu_singles,Px,cycles,sft,spin_matrix)
          Jx =  j1
          Px(1:maxD,1:maxD) = -Px(1:maxD,1:maxD)
          
          !// NOW PY
          call contracted_cycle_stateless(lbar,kbar,jbar,ibar,jbar,0,lambda_singles,mu_singles,Py,cycles,sft,spin_matrix)
          Jy =  j2
          
          call contracted_cycle_stateless(lbar+2,jbar+1,kbar,ibar,kbar,0,lambda_singles,mu_singles,locContracted,cycles,sft,spin_matrix)
          Py(1:maxD,1:maxD) = Py(1:maxD,1:maxD) + locContracted
          
      elseif (member == 3) then
          
          !// PX = P1, PY = P3
          
          if (abs(j1) <= integral_threshold.and.abs(j3) <= integral_threshold) then
              skip = .true.
              return
          endif
          
          !// FIRST PX
          call contracted_cycle_stateless(lbar,kbar,jbar,ibar,jbar,0,lambda_singles,mu_singles,Px,cycles,sft,spin_matrix)
          Jx =  j1
          
          !// NOW PY
          call contracted_cycle_stateless(lbar+2,jbar+1,kbar,ibar,kbar,0,lambda_singles,mu_singles,Py,cycles,sft,spin_matrix)
          Jy =  j3
          
      elseif (member == 4) then
          
          !// PX = -P1, PY = P3' = P1 + P2
          
          if (abs(j1) <= integral_threshold.and.abs(j3) <= integral_threshold) then
              skip = .true.
              return
          endif
          
          !// FIRST PX
          call contracted_cycle_stateless(lbar,kbar,jbar,ibar,jbar,0,lambda_singles,mu_singles,Px,cycles,sft,spin_matrix)
          Jx =  j1
          Px(1:maxD,1:maxD) = -Px(1:maxD,1:maxD)
          
          !// NOW PY
          call contracted_cycle_stateless(lbar,kbar,jbar,ibar,jbar,0,lambda_singles,mu_singles,Py,cycles,sft,spin_matrix)
          Jy =  j3
          
          call contracted_cycle_stateless(lbar+2,ibar,kbar,jbar,kbar,0,lambda_singles,mu_singles,locContracted,cycles,sft,spin_matrix)
          Py(1:maxD,1:maxD) = Py(1:maxD,1:maxD) + locContracted
          
      elseif (member == 5) then
          
          !// PX = P2, PY = P3
          
          if (abs(j2) <= integral_threshold.and.abs(j3) <= integral_threshold) then
              skip = .true.
              return
          endif
          
          !// FIRST PX
          call contracted_cycle_stateless(lbar+2,ibar,kbar,jbar,kbar,0,lambda_singles,mu_singles,Px,cycles,sft,spin_matrix)
          Jx =  j2
          
          !// NOW PY
          call contracted_cycle_stateless(lbar+2,jbar+1,kbar,ibar,kbar,0,lambda_singles,mu_singles,Py,cycles,sft,spin_matrix)
          Jy =  j3
          
      elseif (member == 6) then
      
          !// PX = -P2, PY = P3' = P1+P2
          
          if (abs(j2) <= integral_threshold.and.abs(j3) <= integral_threshold) then
              skip = .true.
              return
          endif
          
          !// FIRST PX
          call contracted_cycle_stateless(lbar+2,ibar,kbar,jbar,kbar,0,lambda_singles,mu_singles,Px,cycles,sft,spin_matrix)
          Jx =  j2
          Px(1:maxD,1:maxD) = -Px(1:maxD,1:maxD)
          
          !// NOW PY
          call contracted_cycle_stateless(lbar,kbar,jbar,ibar,jbar,0,lambda_singles,mu_singles,Py,cycles,sft,spin_matrix)
          Jy =  j3
          
          call contracted_cycle_stateless(lbar+2,ibar,kbar,jbar,kbar,0,lambda_singles,mu_singles,locContracted,cycles,sft,spin_matrix)
          Py(1:maxD,1:maxD) = Py(1:maxD,1:maxD) + locContracted
          
      endif
      
  elseif (chain >= 7) then
      
      !// C6, C7 LOOPS
      
      !// SPECIAL NOTE:  IF YOU LOOK AT WLODEK'S PAPER YOU MIGHT
      !// THINK THAT THIS SECTION IS NOT REQUIRED AND THAT IT COULD
      !// BE ABSORBED INTO THE BLOCK ABOVE.  HOWEVER, THERE IS A 
      !// MISPRINT IN HIS PAPER.  FOR THESE LOOPS WE NEED TO USE LBAR+2
      !// IN THE LINE UP PERMUTATIONS INSTEAD OF LBAR.  THUS WE NEED
      !// A SEPARATE BLOCK BECAUSE THE PERMUTATIONS ARE DIFFERENT.  THIS
      !// ERROR IS SIMILAR TO THE ERROR WE SAW FOR THE C5 LOOPS, EXCEPT IN
      !// THIS CASE IT APPLIES TO ALL PERMUTATIONS.  NOT JUST P2 AND P3.  
      if (member == 1) then
          
          !// PX = P1, PY = P2
          
          if (abs(j2) <= integral_threshold.and.abs(j1) <= integral_threshold) then
              skip = .true.
              return
          endif
          
          !// FIRST PX
          call contracted_cycle_stateless(lbar+2,kbar,jbar,ibar,jbar-1,0,lambda_singles,mu_singles,Px,cycles,sft,spin_matrix)
          Jx =  j1
          
          !// NOW PY
          call contracted_cycle_stateless(lbar+2,ibar,kbar,jbar,kbar,0,lambda_singles,mu_singles,Py,cycles,sft,spin_matrix)
          Jy =  j2
          
      elseif (member == 2) then
          
          !// PX = -P1, PY = P2' = P1 + P3
          
          if (abs(j2) <= integral_threshold.and.abs(j1) <= integral_threshold) then
              skip = .true.
              return
          endif
          
          !// FIRST PX
          call contracted_cycle_stateless(lbar+2,kbar,jbar,ibar,jbar-1,0,lambda_singles,mu_singles,Px,cycles,sft,spin_matrix)
          Jx =  j1
          Px(1:maxD,1:maxD) = -Px(1:maxD,1:maxD)
          
          !// NOW PY
          call contracted_cycle_stateless(lbar+2,kbar,jbar,ibar,jbar-1,0,lambda_singles,mu_singles,Py,cycles,sft,spin_matrix)
          Jy =  j2
          
          call contracted_cycle_stateless(lbar+2,jbar+1,kbar,ibar,kbar,0,lambda_singles,mu_singles,locContracted,cycles,sft,spin_matrix)
          Py(1:maxD,1:maxD) = Py(1:maxD,1:maxD) + locContracted
          
      elseif (member == 3) then
          
          !// PX = P1, PY = P3
          
          if (abs(j3) <= integral_threshold.and.abs(j1) <= integral_threshold) then
              skip = .true.
              return
          endif
          
          !// FIRST PX
          call contracted_cycle_stateless(lbar+2,kbar,jbar,ibar,jbar-1,0,lambda_singles,mu_singles,Px,cycles,sft,spin_matrix)
          Jx =  j1
          
          !// NOW PY
          call contracted_cycle_stateless(lbar+2,jbar+1,kbar,ibar,kbar,0,lambda_singles,mu_singles,Py,cycles,sft,spin_matrix)
          Jy =  j3
          
      elseif (member == 4) then
          
          !// PX = -P1, PY = P3' = P1 + P2
          
          if (abs(j3) <= integral_threshold.and.abs(j1) <= integral_threshold) then
              skip = .true.
              return
          endif
          
          !// FIRST PX
          call contracted_cycle_stateless(lbar+2,kbar,jbar,ibar,jbar-1,0,lambda_singles,mu_singles,Px,cycles,sft,spin_matrix)
          Jx =  j1
          Px(1:maxD,1:maxD) = -Px(1:maxD,1:maxD)
          
          !// NOW PY
          call contracted_cycle_stateless(lbar+2,kbar,jbar,ibar,jbar-1,0,lambda_singles,mu_singles,Py,cycles,sft,spin_matrix)
          Jy =  j3
          
          call contracted_cycle_stateless(lbar+2,ibar,kbar,jbar,kbar,0,lambda_singles,mu_singles,locContracted,cycles,sft,spin_matrix)
          Py(1:maxD,1:maxD) = Py(1:maxD,1:maxD) + locContracted
          
      elseif (member == 5) then
          
          !// PX = P2, PY = P3
          
          if (abs(j3) <= integral_threshold.and.abs(j2) <= integral_threshold) then
              skip = .true.
              return
          endif
          
          !// FIRST PX
          call contracted_cycle_stateless(lbar+2,ibar,kbar,jbar,kbar,0,lambda_singles,mu_singles,Px,cycles,sft,spin_matrix)
          Jx =  j2
          
          !// NOW PY
          call contracted_cycle_stateless(lbar+2,jbar+1,kbar,ibar,kbar,0,lambda_singles,mu_singles,Py,cycles,sft,spin_matrix)
          Jy =  j3
          
      elseif (member == 6) then
          
          !// PX = -P2, PY = P3' = P1+P2
          
          if (abs(j3) <= integral_threshold.and.abs(j2) <= integral_threshold) then
              skip = .true.
              return
          endif
          
          !// FIRST PX
          call contracted_cycle_stateless(lbar+2,ibar,kbar,jbar,kbar,0,lambda_singles,mu_singles,Px,cycles,sft,spin_matrix)
          Jx =  j2
          Px(1:maxD,1:maxD) = -Px(1:maxD,1:maxD)
          
          !// NOW PY
          call contracted_cycle_stateless(lbar+2,kbar,jbar,ibar,jbar-1,0,lambda_singles,mu_singles,Py,cycles,sft,spin_matrix)
          Jy =  j3
          
          call contracted_cycle_stateless(lbar+2,ibar,kbar,jbar,kbar,0,lambda_singles,mu_singles,locContracted,cycles,sft,spin_matrix)
          Py(1:maxD,1:maxD) = Py(1:maxD,1:maxD) + locContracted
          
      endif
      
  endif
  
  deallocate(locContracted,stat=status)
  call deallocatecheck(status,"coupling_coeff_and_integrals")
  
end subroutine coupling_coeff_and_integrals

!*****************************************************************
!*****************************************************************
subroutine three_i_seg_loopdrv(civec, sigmavec, lambda_path,mod2vars, cho_data)

  use locist_var_mod,only:locist_scratch
  use two_seg_var_mod

  implicit none

  type(orbital_path),intent(inout)::lambda_path
  type(threefourmod2vars),intent(inout)::mod2vars
  type(blockedLockVectorType),intent(inout):: civec, sigmavec
  type(cholesky_data),intent(in)::cho_data
  
  type(graph_search_state)::graph
  type(threeIntScr),dimension(:),allocatable::scr

  integer::allocatestatus,aijk_count,i,offset
  
#ifdef TIGER_USE_OMP
   integer::numthreads
   numthreads = numberOfThreads
#else
   integer,parameter::thread=1,numthreads=1
#endif
  
  offset = 0
  
  allocate(scr(numthreads),stat=allocatestatus)
  call allocatecheck(allocatestatus,"three_i_seg_loopdrv_scr")
  do i=1,numthreads
     allocate(scr(i)%virt_lam_allow(num_external),scr(i)%virt_mu_allow(num_external),scr(i)%Px(fsn(open_shells),fsn(open_shells)), &
     scr(i)%Py(fsn(open_shells),fsn(open_shells)),scr(i)%aijk_buf(num_external,3),scr(i)%constraints(3,6),stat=allocatestatus)
     call allocatecheck(allocatestatus,"three_i_seg_loopdrv_scr")
     if(integralDirect.and. .false.) then
       allocate(scr(i)%iajk_int(num_external),scr(i)%ikaj_int(num_external),scr(i)%ijka_int(num_external),stat=allocatestatus)
       call allocatecheck(allocatestatus,"three_i_seg_loopdrv_scrII")
     endif
  enddo
  
  !!!!!!!!!!!!!!!!!!!!!!! VARIABLE INITIALIZATION !!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !// INITIALIZE DERIVED TYPES
  lambda_path%occupations = 0
  lambda_path%singles = 0
  lambda_path%arc_weights = 0
  do i=1,numthreads
     scr(i)%constraints = -1
  enddo
  lambda_path%encountered = .false.
  lambda_path%num_singles = 0

  mod2vars%ijka_flag = .true.      !// THIS VARIABLE GIVES THE CHAIN REQUIRED FOR (IJ|KA)

  !!!!!!!!!!!!!!!!!!!!!!!!!!! START OF ROUTINE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  aijk_count = 1

  call init_tree_search(graph, 0, 0, num_internal, num_elec-2)
  do while ( get_internal_path(lambda_path, graph))
     if(integralDirect.and. .false.) then
       call threeiseg3s_direct(civec, sigmavec, lambda_path,scr,cho_data)
     else
       call threeiseg3s(civec, sigmavec, mod2vars%iter_count,lambda_path,scr,aijk_count,offset)
     endif
  end do

  !// INITIALIZE DERIVED TYPES
  lambda_path%occupations = 0
  lambda_path%singles = 0
  lambda_path%arc_weights = 0
  do i=1,numthreads
     scr(i)%constraints = -1
  enddo
  lambda_path%encountered = .false.
  lambda_path%num_singles = 0

  call init_tree_search(graph, 0, 0, num_internal, num_elec-1)
  do while ( get_internal_path(lambda_path, graph))
     if(integralDirect.and. .false.) then
       call threeiseg3s_direct(civec, sigmavec, lambda_path,scr,cho_data)
     else
       call threeiseg3s(civec, sigmavec, mod2vars%iter_count,lambda_path,scr,aijk_count,offset)
     endif
  end do

  !// INITIALIZE DERIVED TYPES
  lambda_path%occupations = 0
  lambda_path%singles = 0
  lambda_path%arc_weights = 0
  do i=1,numthreads
     scr(i)%constraints = -1
  enddo
  lambda_path%encountered = .false.
  lambda_path%num_singles = 0

  call init_tree_search(graph, 0, 0, num_internal, num_elec)
  do while ( get_internal_path(lambda_path, graph))
     if(integralDirect.and. .false.) then
       call threeiseg3s_direct(civec, sigmavec, lambda_path,scr,cho_data)
     else
       call threeiseg3s(civec, sigmavec, mod2vars%iter_count,lambda_path,scr,aijk_count,offset)
     endif
  end do
  
  ! deallocation guaranteed by fortran standard

end subroutine three_i_seg_loopdrv
!*****************************************************************
subroutine threeiseg3s_direct(civec, sigmavec,lambda_path,scr,cho_data)

  use locist_var_mod,only:locist_scratch

  implicit none

  type(orbital_path),intent(inout)::lambda_path
  type(threeIntScr),dimension(:),intent(inout)::scr
  type(cholesky_data),intent(in)::cho_data
  type(blockedLockVectorType) :: civec, sigmavec 

  integer::chain                  !// LOOP CHAIN
  integer::member_loop            !// LOOP WITHIN A CHAIN
  integer::current_vertex         !// USED IN BUILDING MU PATH
  integer::step_type              !// KEEPS TRACK OF STEP IN MU PATH CONSTRUCTION
  integer::path_elecs             !// CUMULATIVE OCCUPATION IN MU PATH
  integer::top_level              !// LEVEL OF FIRST LOOP SEGMENT
  integer::mu_levels              !// LABELS LEVELS IN MU PATH
  integer::constraint_count       !// KEEP TRACK OF CONSTRAINTS IN BUILDING MU PATH
  integer::start_elec             !// OCCUPATION WHERE INTERNAL CSF MEETS UP WITH EXTERNAL SPACE
  integer::a                     !// USED TO INDEX EXTERNAL ORBITALS
  integer::lam_step_1,lam_step_2,lam_step_3          

  integer:: k,p,q,i_orb,j_orb                        !// LOOP VARIABLES
  integer::level_1,level_2,level_3       
  integer::idum2

  real(real8),parameter :: zero = real(0.0,real8)
  
  real(real8),dimension(:),allocatable::ij_vec
  real(real8),dimension(:),pointer::ik_vec,aj_vec,ia_vec,kj_vec,ak_vec
  
  real(real8),external::ddot
  integer::stat,cho_p,cho_p1,cho_p2,cho_p3,cho_p4,cho_p5
  
#ifdef TIGER_USE_OMP
  integer::threadID
#else
  integer,parameter::threadID=1
#endif

!********************************************************

  lambda_path%weight = sum(lambda_path%arc_weights(0:num_internal)) 
  start_elec = sum( lambda_path%occupations(0:num_internal) )
  if (skip_this_internal(lambda_path%weight,start_elec)) return   
  
  allocate(ij_vec(numcho),stat=stat)
  call allocatecheck(stat,"ij_vec threeiseg3s_direct")
 
 do p = 1, lambda_path%num_singles 
     i_orb = lambda_path%singles(p)
     
     do q = p+1,lambda_path%num_singles
        j_orb = lambda_path%singles(q) 

        if ( ignorable_pair(j_orb,i_orb) ) cycle
        
        ! read in ij_vec (kinda as a cache)
        cho_p = max(i_orb,j_orb)
        cho_p = cho_p*(cho_p-1)/2+min(i_orb,j_orb)
        cho_p = cho_data%mo_ind_inv(cho_p)
        if(.not.cdVecsInMemory) then
          call for_double_buf_readblock(mo_int_no, cho_p, ij_vec, 1)
        else
          ij_vec(:) = cho_data%cho_vectors(:,cho_p)
        endif
                   
        ! HERE WE WANT TO PARALLELIZE. REALLY. (in local mode, num_internal will be longer than num_singles)
        !$omp parallel do &
        !$omp default(none) &
        !$omp schedule(static) &
        !$omp private(level_1,level_2,level_3,top_level,lam_step_1,lam_step_2,lam_step_3,path_elecs,current_vertex, &
        !$omp constraint_count,threadID,step_type,idum2,cho_p1,cho_p2,cho_p3,ik_vec,aj_vec,ia_vec,kj_vec,ak_vec, &
        !$omp cho_p4,cho_p5) &
        !$omp shared(civec,sigmavec,lambda_path,scr,ignorable_pair,i_orb,j_orb,y1,y2,num_internal,partial_loops3_vec, &
        !$omp integralDirect, sphere_based_integral_truncations,num_orbitals,cho_data,ij_vec,numcho, &
        !$omp cdVecsInMemory,fullyIntegralDirect,num_external,cho_p,integral_threshold)

        do k = 1,num_internal
        
#ifdef TIGER_USE_OMP
          threadID = OMP_get_thread_num()+1
#endif

          if (ignorable_pair(k,i_orb) ) cycle
          if (ignorable_pair(k,j_orb) ) cycle
          if ( k .eq. i_orb .or. k .eq. j_orb ) cycle
          if (lambda_path%occupations(k) .eq. 1 .and. k .le. j_orb) cycle
          
          cho_p1 = max(i_orb,k)
          cho_p1 = cho_p1*(cho_p1-1)/2+min(i_orb,k)
          cho_p1 = cho_data%mo_ind_inv(cho_p1)
          cho_p2 = max(j_orb,k)
          cho_p2 = cho_p2*(cho_p2-1)/2+min(j_orb,k)
          cho_p2 = cho_data%mo_ind_inv(cho_p2)
             
          
          if(.not.cdVecsInMemory) then
             ! get the i/j/k pointers from the IOBuffer
             ! ik
             call for_double_buf_get_constpointer(mo_int_no, cho_p1, ik_vec, threadID)
             ! kj
             call for_double_buf_get_constpointer(mo_int_no, cho_p2, kj_vec, threadID)
          endif
          

          if(cdVecsInMemory) then
          
            do a = num_internal+1,num_orbitals
            
              ! ia
              cho_p3 = a*(a-1)/2+i_orb
              cho_p3 = cho_data%mo_ind_inv(cho_p3)
              
              ! ja
              cho_p4 = a*(a-1)/2+j_orb
              cho_p4 = cho_data%mo_ind_inv(cho_p4)
              
              ! ka
              cho_p5 = a*(a-1)/2+k
              cho_p5 = cho_data%mo_ind_inv(cho_p5)
              
              idum2 = a-num_internal
              ! JMD: yes, as always in TigerCI when it comes to the CD 'enhancements' carried out prior to my time: WTF?!
              !      I have no idea (and no responsibility!) why the indices are once more absolutely cocked up
              !      also, please note that this code ALWAYS does CS prescreening on the MO CD vector level.
              ! (ik|aj)
              if(cho_data%cho_norms(cho_p1)*cho_data%cho_norms(cho_p4) >= integral_threshold) then
                scr(threadID)%iajk_int(idum2) = ddot(numcho,cho_data%cho_vectors(1,cho_p1),1,cho_data%cho_vectors(1,cho_p4),1)
              else
                scr(threadID)%iajk_int(idum2) = 0.0d0
              endif
              ! (ia|kj)
              if(cho_data%cho_norms(cho_p3)*cho_data%cho_norms(cho_p2) >= integral_threshold) then
                scr(threadID)%ikaj_int(idum2) = ddot(numcho,cho_data%cho_vectors(1,cho_p3),1,cho_data%cho_vectors(1,cho_p2),1)
              else
                scr(threadID)%ikaj_int(idum2) = 0.0d0
              endif
              ! (ij|ak)
              if(cho_data%cho_norms(cho_p)*cho_data%cho_norms(cho_p5) >= integral_threshold) then
                scr(threadID)%ijka_int(idum2) = ddot(numcho,ij_vec,1,cho_data%cho_vectors(1,cho_p5),1)
              else
                scr(threadID)%ijka_int(idum2) = 0.0d0
              endif
            
            enddo
            
          else
            !stuff is in the IOBuffer, it gets a bit more involved
            do a = num_internal+1,num_orbitals
            
              ! ia
              cho_p3 = a*(a-1)/2+i_orb
              cho_p3 = cho_data%mo_ind_inv(cho_p3)
              call for_double_buf_get_constpointer(mo_int_no, cho_p3, ia_vec, threadID)
              
              ! ja
              cho_p4 = a*(a-1)/2+j_orb
              cho_p4 = cho_data%mo_ind_inv(cho_p4)
              call for_double_buf_get_constpointer(mo_int_no, cho_p4, aj_vec, threadID)
              
              ! ka
              cho_p5 = a*(a-1)/2+k
              cho_p5 = cho_data%mo_ind_inv(cho_p5)
              call for_double_buf_get_constpointer(mo_int_no, cho_p5, ak_vec, threadID)
              
              idum2 = a-num_internal
              ! JMD: yes, as always in TigerCI when it comes to the CD 'enhancements' carried out prior to my time: WTF?!
              !      I have no idea (and no responsibility!) why the indices are once more absolutely cocked up
              !      also, please note that this code ALWAYS does CS prescreening on the MO CD vector level.
              ! (ik|aj)
              if(cho_data%cho_norms(cho_p1)*cho_data%cho_norms(cho_p4) >= integral_threshold) then
                scr(threadID)%iajk_int(idum2) = ddot(numcho,ik_vec,1,aj_vec,1)
              else
                scr(threadID)%iajk_int(idum2) = 0.0d0
              endif
              ! (ia|kj)
              if(cho_data%cho_norms(cho_p3)*cho_data%cho_norms(cho_p2) >= integral_threshold) then
                scr(threadID)%ikaj_int(idum2) = ddot(numcho,ia_vec,1,kj_vec,1)
              else
                scr(threadID)%ikaj_int(idum2) = 0.0d0
              endif
              ! (ij|ak)
              if(cho_data%cho_norms(cho_p)*cho_data%cho_norms(cho_p5) >= integral_threshold) then
                scr(threadID)%ijka_int(idum2) = ddot(numcho,ij_vec,1,ak_vec,1)
              else
                scr(threadID)%ijka_int(idum2) = 0.0d0
              endif
              
              ! return stuff
              call for_double_buf_return_pointer(mo_int_no, cho_p3, threadID)
              call for_double_buf_return_pointer(mo_int_no, cho_p4, threadID)
              call for_double_buf_return_pointer(mo_int_no, cho_p5, threadID)
            
            enddo
          endif

          level_2 = i_orb

          level_3 = max(j_orb,k)                        
          level_1 = min(i_orb,k) 

          if (level_1 == i_orb) then
             level_2 = min(j_orb,k)
          endif

          scr(threadID)%constraints(2,1)=level_1
          scr(threadID)%constraints(2,2)=level_2
          scr(threadID)%constraints(2,3)=level_3
          top_level = level_1 
     

          lam_step_1 = lambda_path%occupations(level_1)
          lam_step_2 = lambda_path%occupations(level_2)
          lam_step_3 = lambda_path%occupations(level_3)

             if ( k .gt. j_orb) then
                scr(threadID)%aijk_buf(:,1) = scr(threadID)%ijka_int(:) 
                scr(threadID)%aijk_buf(:,2) = scr(threadID)%ikaj_int(:) 
                scr(threadID)%aijk_buf(:,3) = scr(threadID)%iajk_int(:) 
             else if (k .lt. i_orb) then
                scr(threadID)%aijk_buf(:,1) = scr(threadID)%iajk_int(:) 
                scr(threadID)%aijk_buf(:,2) = scr(threadID)%ijka_int(:) 
                scr(threadID)%aijk_buf(:,3) = scr(threadID)%ikaj_int(:) 
             else
                scr(threadID)%aijk_buf(:,1) = scr(threadID)%iajk_int(:)
                scr(threadID)%aijk_buf(:,2) = scr(threadID)%ikaj_int(:) 
                scr(threadID)%aijk_buf(:,3) = scr(threadID)%ijka_int(:) 
             endif
             
!^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
          do chain = 1,8

            member_loop_lX: do member_loop = 1,3

              if (lam_step_1 .ne. partial_loops3_vec(chain,member_loop,1,1) ) cycle 
              if (lam_step_2 .ne. partial_loops3_vec(chain,member_loop,2,1) ) cycle  
              if (lam_step_3 .ne. partial_loops3_vec(chain,member_loop,3,1) ) cycle  

              scr(threadID)%loop_type = 3*(chain-1)+member_loop                   

              scr(threadID)%rt_loop_weight = 0                                

!// SET CONSTRAINTS FOR MU PATHS
              scr(threadID)%constraints(3,1:3) = partial_loops3_vec(chain,member_loop,1:3,2)

              constraint_count = 1
              path_elecs = sum(lambda_path%occupations(0:top_level-1))

              do mu_levels = top_level, num_internal

                 current_vertex = vertex(mu_levels-1,path_elecs)

                 !// CHECK TO SEE IF THIS IS A CONSTRAINED LEVEL AND GET THE STEP_TYPE
                 if ((mu_levels)==scr(threadID)%constraints(2,constraint_count)) then
                    step_type = scr(threadID)%constraints(3,constraint_count)
                    constraint_count = constraint_count + 1
                 else
                    step_type = lambda_path%occupations(mu_levels) 
                 endif

                 !// TRY TO ADD THE STEP
                 if (step_type == 2) then
                    if (add2(mu_levels-1,path_elecs)) then
                       path_elecs = path_elecs + 2
                       scr(threadID)%rt_loop_weight = scr(threadID)%rt_loop_weight +&
                                           abs(y2(current_vertex))
                    else
                       cycle member_loop_lX
                    endif

                 elseif(step_type == 1) then

                    if (add1(mu_levels-1,path_elecs)) then
                       path_elecs = path_elecs + 1
                       scr(threadID)%rt_loop_weight = scr(threadID)%rt_loop_weight +&
                                           abs(y1(current_vertex))
                    else
                       cycle member_loop_lX
                    endif

                elseif(step_type == 0) then

                   if (.not.add0(mu_levels-1,path_elecs)) cycle member_loop_lX

               endif

             enddo


             !// FOR THE RT_LOOP_WEIGHT ADD IN THE WEIGHTS OF THE RELEVANT PARTS
             !// OF THE HEAD AND TAIL PATHS.  THIS WILL END UP BEING THE MU PATH WEIGHT
             scr(threadID)%rt_loop_weight = scr(threadID)%rt_loop_weight +&
                               sum(lambda_path%arc_weights(0:top_level-1))


             !//  TEST TO SEE IF WE SHOULD EXIT RIGHT NOW FOR LOCAL CI
             if (skip_this_internal(scr(threadID)%rt_loop_weight,path_elecs)) cycle member_loop_lX

             call three_i_seg_loopdrv_sigma(civec, sigmavec, lambda_path,scr(threadID)%loop_type,scr(threadID)%rt_loop_weight,scr(threadID)%constraints, &
                  scr(threadID)%virt_lam_allow,scr(threadID)%virt_mu_allow,scr(threadID)%Px,scr(threadID)%Py,scr(threadID)%aijk_buf)

           enddo member_loop_lX !  member_loops

        enddo !  chains
        
        if(.not.cdVecsInMemory) then
          ! return the i/j/k pointer to the IOBuffer
          call for_double_buf_return_pointer(mo_int_no, cho_p1, threadID)
          call for_double_buf_return_pointer(mo_int_no, cho_p2, threadID)
        endif

      enddo !  k (1->num_internal)
      !$omp end parallel do

     enddo !  j_orb num singles

 enddo !  i_orb num singles_count
 
end subroutine threeiseg3s_direct
!*****************************************************************
subroutine threeiseg3s(civec, sigmavec, iteration,lambda_path,scr,aijk_count,offset)

  use locist_var_mod,only:locist_scratch

  implicit none

  integer,intent(in)::iteration
  type(orbital_path),intent(inout)::lambda_path
  type(threeIntScr),dimension(:),intent(inout)::scr
  integer,intent(inout)::aijk_count
  integer,intent(inout)::offset ! offset is only used in the OpenMP case and gives us something to pointer in
  type(blockedLockVectorType) :: civec, sigmavec 

  integer::chain                  !// LOOP CHAIN
  integer::member_loop            !// LOOP WITHIN A CHAIN
  integer::current_vertex         !// USED IN BUILDING MU PATH
  integer::step_type              !// KEEPS TRACK OF STEP IN MU PATH CONSTRUCTION
  integer::path_elecs             !// CUMULATIVE OCCUPATION IN MU PATH
  integer::top_level              !// LEVEL OF FIRST LOOP SEGMENT
  integer::mu_levels              !// LABELS LEVELS IN MU PATH
  integer::constraint_count       !// KEEP TRACK OF CONSTRAINTS IN BUILDING MU PATH
  integer::start_elec             !// OCCUPATION WHERE INTERNAL CSF MEETS UP WITH EXTERNAL SPACE
  integer::a                     !// USED TO INDEX EXTERNAL ORBITALS
  integer::lam_step_1,lam_step_2,lam_step_3          

  integer:: k,p,q,i_orb,j_orb                        !// LOOP VARIABLES
  integer::level_1,level_2,level_3       
  integer::idum,idum2      
  integer::iajk_start,ikaj_start,ijka_start

  integer::allocatestatus,deallocatestatus
  
  real(real8),dimension(:,:),allocatable::iajk_int,ikaj_int,ijka_int
  real(real8),parameter :: zero = real(0.0,real8)
  integer::ij_ind
  
#ifdef TIGER_USE_OMP
  integer::threadID,x
  integer::numthreads
  threadID = OMP_get_thread_num()+1
  numthreads = numberOfThreads
#else
  integer,parameter::threadID=1
  offset = -1 ! to silence compiler :-)
#endif

!********************************************************

  lambda_path%weight = sum(lambda_path%arc_weights(0:num_internal)) 
  start_elec = sum( lambda_path%occupations(0:num_internal) )
  if (skip_this_internal(lambda_path%weight,start_elec)) return
  
  allocate(iajk_int(num_external,num_internal),ikaj_int(num_external,num_internal),ijka_int(num_external,num_internal),stat=allocatestatus)
  call allocatecheck(allocatestatus,"scratch matrices threeiseg3s")
  
  if (iteration .eq. 1) then
     
  do p = 1, lambda_path%num_singles 
     i_orb = lambda_path%singles(p) 

     do q = p+1,lambda_path%num_singles
        j_orb = lambda_path%singles(q) 

        if ( ignorable_pair(j_orb,i_orb) ) cycle
           
           iajk_int = zero
           ikaj_int = zero
           ijka_int = zero
           ij_ind = j_orb*(j_orb-1)/2+i_orb
           read(unit=368,rec=ij_ind) iajk_start
           read(unit=370,rec=ij_ind) ikaj_start
           read(unit=372,rec=ij_ind) ijka_start
           
           idum = 0
           do k = 1,num_internal
              if (ignorable_pair(k,i_orb) ) cycle
              if (ignorable_pair(k,j_orb) ) cycle
 
              do a = num_internal+1,num_orbitals
                 if (ignorable_pair(a,k) ) cycle
                 if (ignorable_pair(a,i_orb) ) cycle
                 if (ignorable_pair(a,j_orb) ) cycle

                 idum2 = a-num_internal
                 idum = idum + 1
                 call for_double_buf_readElement(cd_iajk_no,iajk_start+idum,iajk_int(idum2,k),threadID)
                 call for_double_buf_readElement(cd_ikaj_no,ikaj_start+idum,ikaj_int(idum2,k),threadID)
                 call for_double_buf_readElement(cd_ijka_no,ijka_start+idum,ijka_int(idum2,k),threadID)
             enddo
           enddo

        do k = 1,num_internal
        
#ifdef TIGER_USE_OMP
#ifdef DEBUG_TIGER
          write(*,*) "DEBUG: Trying to put the following into the threeiseg_no OMP aux file ",threeiseg_no,offset+k,aijk_count,1
          flush(6)
#endif
          ! record aijk_count for later usage
          call for_int_buf_writeElement(threeiseg_no,offset+k,aijk_count,1)
#endif

          if (ignorable_pair(k,i_orb) ) cycle
          if (ignorable_pair(k,j_orb) ) cycle
          if ( k .eq. i_orb .or. k .eq. j_orb ) cycle
          if (lambda_path%occupations(k) .eq. 1 .and. k .le. j_orb) cycle

          level_2 = i_orb

          level_3 = max(j_orb,k)                        
          level_1 = min(i_orb,k) 

          if (level_1 == i_orb) then
             level_2 = min(j_orb,k)
          endif

          scr(1)%constraints(2,1)=level_1
          scr(1)%constraints(2,2)=level_2
          scr(1)%constraints(2,3)=level_3
#ifdef TIGER_USE_OMP
          ! take care of the bloody constraints
          do x = 2, numthreads
             scr(x)%constraints(2,1)=level_1
             scr(x)%constraints(2,2)=level_2
             scr(x)%constraints(2,3)=level_3
          enddo
#endif
          top_level = level_1 
     

          lam_step_1 = lambda_path%occupations(level_1)
          lam_step_2 = lambda_path%occupations(level_2)
          lam_step_3 = lambda_path%occupations(level_3)

!^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Generate Integrals from Cholesky Vectors                                                                  ^
!^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
             if ( k .gt. j_orb) then
                scr(1)%aijk_buf(:,1) = ijka_int(:,k) 
                scr(1)%aijk_buf(:,2) = ikaj_int(:,k) 
                scr(1)%aijk_buf(:,3) = iajk_int(:,k) 
             else if (k .lt. i_orb) then
                scr(1)%aijk_buf(:,1) = iajk_int(:,k) 
                scr(1)%aijk_buf(:,2) = ijka_int(:,k) 
                scr(1)%aijk_buf(:,3) = ikaj_int(:,k) 
             else
                scr(1)%aijk_buf(:,1) = iajk_int(:,k)
                scr(1)%aijk_buf(:,2) = ikaj_int(:,k) 
                scr(1)%aijk_buf(:,3) = ijka_int(:,k) 
             endif
             
             call for_double_buf_writeblock(ijka_test_no, aijk_count  , scr(1)%aijk_buf(:,1), 1)
             call for_double_buf_writeblock(ijka_test_no, aijk_count+1, scr(1)%aijk_buf(:,2), 1)
             call for_double_buf_writeblock(ijka_test_no, aijk_count+2, scr(1)%aijk_buf(:,3), 1)
             aijk_count = aijk_count + 3

!^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

          !$omp parallel do &
          !$omp default(none) &
          !$omp schedule(static) &
          !$omp private(threadID,constraint_count,path_elecs,step_type,current_vertex) &
          !$omp shared(civec,sigmavec,scr,lam_step_1,lam_step_2,lam_step_3,partial_loops3_vec,lambda_path,y2,numthreads, &
          !$omp num_internal,y1,top_level)
          do chain = 1,8
          
#ifdef TIGER_USE_OMP
            threadID = OMP_get_thread_num()+1
#endif

            member_loop_l: do member_loop = 1,3

              if (lam_step_1 .ne. partial_loops3_vec(chain,member_loop,1,1) ) cycle 
              if (lam_step_2 .ne. partial_loops3_vec(chain,member_loop,2,1) ) cycle  
              if (lam_step_3 .ne. partial_loops3_vec(chain,member_loop,3,1) ) cycle  

              scr(threadID)%loop_type = 3*(chain-1)+member_loop                   

              scr(threadID)%rt_loop_weight = 0                                

!// SET CONSTRAINTS FOR MU PATHS
              scr(threadID)%constraints(3,1:3) = partial_loops3_vec(chain,member_loop,1:3,2)

              constraint_count = 1
              path_elecs = sum(lambda_path%occupations(0:top_level-1))

              do mu_levels = top_level, num_internal

                 current_vertex = vertex(mu_levels-1,path_elecs)

                 !// CHECK TO SEE IF THIS IS A CONSTRAINED LEVEL AND GET THE STEP_TYPE
                 if ((mu_levels)==scr(threadID)%constraints(2,constraint_count)) then
                    step_type = scr(threadID)%constraints(3,constraint_count)
                    constraint_count = constraint_count + 1
                 else
                    step_type = lambda_path%occupations(mu_levels) 
                 endif

                 !// TRY TO ADD THE STEP
                 if (step_type == 2) then
                    if (add2(mu_levels-1,path_elecs)) then
                       path_elecs = path_elecs + 2
                       scr(threadID)%rt_loop_weight = scr(threadID)%rt_loop_weight +&
                                           abs(y2(current_vertex))
                    else
                       cycle member_loop_l
                    endif

                 elseif(step_type == 1) then

                    if (add1(mu_levels-1,path_elecs)) then
                       path_elecs = path_elecs + 1
                       scr(threadID)%rt_loop_weight = scr(threadID)%rt_loop_weight +&
                                           abs(y1(current_vertex))
                    else
                       cycle member_loop_l
                    endif

                elseif(step_type == 0) then

                   if (.not.add0(mu_levels-1,path_elecs)) cycle member_loop_l

               endif

             enddo


             !// FOR THE RT_LOOP_WEIGHT ADD IN THE WEIGHTS OF THE RELEVANT PARTS
             !// OF THE HEAD AND TAIL PATHS.  THIS WILL END UP BEING THE MU PATH WEIGHT
             scr(threadID)%rt_loop_weight = scr(threadID)%rt_loop_weight +&
                               sum(lambda_path%arc_weights(0:top_level-1))


             !//  TEST TO SEE IF WE SHOULD EXIT RIGHT NOW FOR LOCAL CI
             if (skip_this_internal(scr(threadID)%rt_loop_weight,path_elecs)) cycle member_loop_l

             call three_i_seg_loopdrv_sigma(civec, sigmavec, lambda_path,scr(threadID)%loop_type,scr(threadID)%rt_loop_weight,scr(threadID)%constraints, &
                  scr(threadID)%virt_lam_allow,scr(threadID)%virt_mu_allow,scr(threadID)%Px,scr(threadID)%Py,scr(1)%aijk_buf)

            enddo member_loop_l !  member_loops

        enddo !  chains
        !$omp end parallel do

      enddo !  k (1->num_internal)
#ifdef TIGER_USE_OMP
      offset = offset + num_internal
#endif
      
     enddo !  j_orb num singles

 enddo !  i_orb num singles 
 
 else ! iteration 2 or higher
 
 do p = 1, lambda_path%num_singles 
     i_orb = lambda_path%singles(p) 

     do q = p+1,lambda_path%num_singles
        j_orb = lambda_path%singles(q) 

        if ( ignorable_pair(j_orb,i_orb) ) cycle
        
        ! HERE WE WANT TO PARALLELIZE. REALLY.
        !$omp parallel do &
        !$omp default(none) &
        !$omp private(level_1,level_2,level_3,top_level,lam_step_1,lam_step_2,lam_step_3,path_elecs,current_vertex, &
        !$omp constraint_count,threadID,step_type,aijk_count) &
        !$omp shared(civec,sigmavec,lambda_path,scr,ignorable_pair,i_orb,j_orb,y1,y2,num_internal,partial_loops3_vec,offset, &
        !$omp integralDirect, sphere_based_integral_truncations, ijka_int, ikaj_int, iajk_int)
        do k = 1,num_internal
        
#ifdef TIGER_USE_OMP
          threadID = OMP_get_thread_num()+1
          ! read aijk_count ! can be removed!
          call for_int_buf_readElement(threeiseg_no,offset+k,aijk_count,threadID)
#endif

          if (ignorable_pair(k,i_orb) ) cycle
          if (ignorable_pair(k,j_orb) ) cycle
          if ( k .eq. i_orb .or. k .eq. j_orb ) cycle
          if (lambda_path%occupations(k) .eq. 1 .and. k .le. j_orb) cycle

          level_2 = i_orb

          level_3 = max(j_orb,k)                        
          level_1 = min(i_orb,k) 

          if (level_1 == i_orb) then
             level_2 = min(j_orb,k)
          endif

          scr(threadID)%constraints(2,1)=level_1
          scr(threadID)%constraints(2,2)=level_2
          scr(threadID)%constraints(2,3)=level_3
          top_level = level_1 
     

          lam_step_1 = lambda_path%occupations(level_1)
          lam_step_2 = lambda_path%occupations(level_2)
          lam_step_3 = lambda_path%occupations(level_3)

!^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Read Integrals from Cholesky Vectors                                                                  ^
!^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

          call for_double_buf_readblock(ijka_test_no, aijk_count  , scr(threadID)%aijk_buf(:,1), threadID)
          call for_double_buf_readblock(ijka_test_no, aijk_count+1, scr(threadID)%aijk_buf(:,2), threadID)
          call for_double_buf_readblock(ijka_test_no, aijk_count+2, scr(threadID)%aijk_buf(:,3), threadID)
          aijk_count = aijk_count + 3

!^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
          do chain = 1,8

            member_loop_lX: do member_loop = 1,3

              if (lam_step_1 .ne. partial_loops3_vec(chain,member_loop,1,1) ) cycle 
              if (lam_step_2 .ne. partial_loops3_vec(chain,member_loop,2,1) ) cycle  
              if (lam_step_3 .ne. partial_loops3_vec(chain,member_loop,3,1) ) cycle  

              scr(threadID)%loop_type = 3*(chain-1)+member_loop                   

              scr(threadID)%rt_loop_weight = 0                                

!// SET CONSTRAINTS FOR MU PATHS
              scr(threadID)%constraints(3,1:3) = partial_loops3_vec(chain,member_loop,1:3,2)

              constraint_count = 1
              path_elecs = sum(lambda_path%occupations(0:top_level-1))

              do mu_levels = top_level, num_internal

                 current_vertex = vertex(mu_levels-1,path_elecs)

                 !// CHECK TO SEE IF THIS IS A CONSTRAINED LEVEL AND GET THE STEP_TYPE
                 if ((mu_levels)==scr(threadID)%constraints(2,constraint_count)) then
                    step_type = scr(threadID)%constraints(3,constraint_count)
                    constraint_count = constraint_count + 1
                 else
                    step_type = lambda_path%occupations(mu_levels) 
                 endif

                 !// TRY TO ADD THE STEP
                 if (step_type == 2) then
                    if (add2(mu_levels-1,path_elecs)) then
                       path_elecs = path_elecs + 2
                       scr(threadID)%rt_loop_weight = scr(threadID)%rt_loop_weight +&
                                           abs(y2(current_vertex))
                    else
                       cycle member_loop_lX
                    endif

                 elseif(step_type == 1) then

                    if (add1(mu_levels-1,path_elecs)) then
                       path_elecs = path_elecs + 1
                       scr(threadID)%rt_loop_weight = scr(threadID)%rt_loop_weight +&
                                           abs(y1(current_vertex))
                    else
                       cycle member_loop_lX
                    endif

                elseif(step_type == 0) then

                   if (.not.add0(mu_levels-1,path_elecs)) cycle member_loop_lX

               endif

             enddo


             !// FOR THE RT_LOOP_WEIGHT ADD IN THE WEIGHTS OF THE RELEVANT PARTS
             !// OF THE HEAD AND TAIL PATHS.  THIS WILL END UP BEING THE MU PATH WEIGHT
             scr(threadID)%rt_loop_weight = scr(threadID)%rt_loop_weight +&
                               sum(lambda_path%arc_weights(0:top_level-1))


             !//  TEST TO SEE IF WE SHOULD EXIT RIGHT NOW FOR LOCAL CI
             if (skip_this_internal(scr(threadID)%rt_loop_weight,path_elecs)) cycle member_loop_lX

             call three_i_seg_loopdrv_sigma(civec, sigmavec, lambda_path,scr(threadID)%loop_type,scr(threadID)%rt_loop_weight,scr(threadID)%constraints, &
                  scr(threadID)%virt_lam_allow,scr(threadID)%virt_mu_allow,scr(threadID)%Px,scr(threadID)%Py,scr(threadID)%aijk_buf)

           enddo member_loop_lX !  member_loops

        enddo !  chains

      enddo !  k (1->num_internal)
      !$omp end parallel do
#ifdef TIGER_USE_OMP
      offset = offset + num_internal
#endif
      ! TILL HERE TO BE PARALLELIZED

     enddo !  j_orb num singles

 enddo !  i_orb num singles_count
 
 endif ! iterations
 
 deallocate(iajk_int,ikaj_int,ijka_int,stat=deallocatestatus)
 call deallocatecheck(deallocatestatus,"scratch matrices threeiseg3s")


end subroutine threeiseg3s
!*****************************************************************
subroutine singles_to_2seg_indices(chain, s1, s2, s3, s4,&
                                     ibar,jbar,kbar,lbar)
                                     
  implicit none
  
  !//  THIS ROUTINE IS VERY SIMPLE.  WE JUST TAKE NUMBERS OF SINGLES
  !//  AND GET IBAR, JBAR, KBAR, LBAR FROM THEM.  HOWEVER, THERE IS ONE
  !//  BIG CAVEAT HERE.  FOR CHAINS 1,5 (CHAIN = 1,6, RESPECTIVELY)
  !//  WE ARE PASSING NUMBERS OF SINGLES FOR FOR THE MU PATH.  THIS MUST BE 
  !//  TAKEN INTO ACCOUNT IN THE COMPUTATION OF IBAR, JBAR, KBAR, AND LBAR.  
  !//  THIS ROUTINE LOOKS JUST LIKE SINGLES_TO_3SEG_INDICES, SO BE CAREFUL
  !//  THAT YOU ARE LOOKING AT THE APPROPRIATE ROUTINE.  
  
  !!!!!!!!!!!!!!!!!!!!!!!!!!!  VARIABLE DECLARATION !!!!!!!!!!!!!!!!!!!!!!!!!!!
  integer,intent(in)::chain                      !// LABELS THE CHAIN OF LOOPS
  integer,intent(in)::s1,s2,s3,s4                !// NUMBERS OF SINGLES
  integer,intent(out)::ibar,jbar,kbar,lbar        !// WHAT WE ARE AFTER
  
  !!!!!!!!!!!!!!!!!!!!!!!!!!! START OF ROUTINE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !// NOW CONVERT THE SINGLES TO IBAR, JBAR, KBAR, LBAR    
  if (chain == 1) then
      
      !// C1 IBAR>JBAR>KBAR>LBAR
      ibar = s1 + s2 + s3 + s4
      jbar = s1 + s2 + s3 - 1
      kbar = s1 + s2 
      lbar = s1 
      
  elseif (chain == 2) then    
  
      !// C2 IBAR>KBAR>JBAR>LBAR
      ibar = s1 + s2 + s3 + s4
      jbar = s1 + s2 
      kbar = s1 + s2 + s3 + 1
      lbar = s1 + 1
      
  elseif (chain == 3) then    
  
      !// C3 KBAR>IBAR>JBAR>LBAR
      ibar = s1 + s2 + s3
      jbar = s1 + s2 
      kbar = s1 + s2 + s3 + s4
      lbar = s1 + 1
      
  elseif (chain == 4) then    
  
      !// C8 IBAR>JBAR>KBAR>LBAR
      ibar = s1 + s2 + s3 +s4
      jbar = s1 + s2 + s3
      kbar = s1 + s2
      lbar = s1     
      
  elseif (chain == 5) then    
  
      !// C4 IBAR>JBAR>KBAR>LBAR
      ibar = s1 + s2 + s3 +s4
      jbar = s1 + s2 + s3
      kbar = s1 + s2
      lbar = s1 + 1
      
  elseif (chain == 6) then    
  
      !// C5 IBAR>JBAR>LBAR>KBAR
      ibar = s1 + s2 + s3 + s4 + 2
      jbar = s1 + s2 + s3 + 1
      kbar = s1 + 1
      lbar = s1 + s2 
      
  elseif (chain == 7) then    
  
      !// C6 KBAR>JBAR>LBAR>IBAR
      ibar = s1 + s2 + s3 +s4
      jbar = s1 + s2
      kbar = s1 
      lbar = s1 + s2 + s3 - 1
      
  elseif (chain == 8) then    
  
      !// C7 KBAR>JBAR>IBAR>LBAR
      ibar = s1 + s2 + s3
      jbar = s1 + s2
      kbar = s1 
      lbar = s1 + s2 + s3 + s4 - 2
      
  endif    
  
end subroutine singles_to_2seg_indices
!*****************************************************************
subroutine three_i_seg_loopdrv_sigma(civec, sigmavec, lambda_path,loop_type,rt_loop_weight,constraints,virt_lam_allow,virt_mu_allow,Px,Py,aijk_buf)

  !// IN THIS ROUTINE I BUILD UP THE COMPLEMENT TO THE THREE SEGMENT OPEN LOOPS
  !// WHICH RESIDE ENTIRELY IN THE INTERNAL SPACE.  FROM HERE WE CALL THE
  !// ROUTINE TO DO THE MULTIPLICATION AS WELL.  BEFORE THIS IS DONE WE
  !// MUST CALL THE ROUTINE TO DO COMPUTE THE COUPLING COEFFICIENTS.  THESE
  !// ROUTINES WILL BE HACKS OF THE ROUTINE USED IN THE FOUR SEGMENT MODULE.
  !// THIS ROUTINE IS A HACK OF FOUR_INTERNAL_SEG_COMPLEMENT
  !// AUTHORS: DEREK WALTER AND ARUN VENKATNATHAN

  !!!!!!!!!!!!!!!!!!!!!!!!!!!  VARIABLE DECLARATION !!!!!!!!!!!!!!!!!!!!!!!!!!

  use time_var_mod

  implicit none

  type(orbital_path),intent(in)::lambda_path
  integer,intent(in)::rt_loop_weight,loop_type
  integer,dimension(:,:),intent(in),allocatable::constraints ! caused by the infamous intel fix
  integer,dimension(:),intent(inout)::virt_lam_allow,virt_mu_allow
  real(real8),dimension(:,:),intent(inout)::Px,Py,aijk_buf
  type(blockedLockVectorType) :: civec, sigmavec 

  integer::chain                  !// LOOP CHAIN
  integer::member_loop            !// LOOP WITHIN A CHAIN
  integer::internal_singles       !// NUMBER OF SINGLES IN INTERNAL PATH OF PATH
  integer::start_elec             !// OCCUPATION WHERE INTERNAL CSF MEETS UP WITH EXTERNAL SPACE
  integer::a                     !// USED TO INDEX EXTERNAL ORBITALS
  integer::s1,s2,s3,s4            !// NUMBERS OF SINGLES IN DIFFERENT LOOP SEGMENTS
  integer:: i,j
  integer::nm2_weight,nm1_weight,v_weight         !// NM2 STANDS FOR N-2,NM1 = N-1,
  integer::nm2_singles,nm1_singles,v_singles      !// AND V = VALENCE
  integer::nm2_dim,nm1_dim,v_dim
  logical::doublet_valence                        !// FLAG = TRUE OF WE MUST DO
                                                  !// N-1/VALENCE INTERACTIONS
  logical:: swap_singles                          !// SET TO TRUE OF WE MUST SWAP THE
                                                  !// NUMBERS OF SINGLES
  
  integer:: Px_index,Py_index                     !// INDEXING FOR INTEGRALS  
  integer::v_address                              !// ADDRESS FOR VALENCE STATES
  integer::a_address                              !// ADDRESS FOR DOUBLET STATES
  integer::aa_address,ab_address                  !// ADDRESS FOR N-2 STATES
  integer:: v_start
  integer:: a_start
  integer:: aa_start
  integer:: ab_start
  integer:: mode_1                                !// SYMMETRIC OR ANTISYMMETRIC SCEPPER
  integer::v_spin,a_spin,ab_spin

  integer::lam_length,lam_lengthC2                               
  integer::mu_length                               
  integer::int_index,index_xy                     !// INDICES FOR INTEGRALS AND COUPLING COEFF'S 
  
  real(real8)::cc,cc2                             !// COUPLING COEFFICIENT
  real(real8),parameter::sqrt2=real(sqrt(real(2.0,real8)),real8),zero=real(0.0,real8),two=real(2.0,real8)

  integer::a1
  integer::idum,idum2

!////// EXTRA DECLARATIONS

  integer::common_virt_length,k_dum
  
  !!!!!!!! FROM HERE MOVE TO SCRATCH SPACE???? PROFILE !!!!
  integer,dimension(:),allocatable::common_virt,virt_lam_long,virt_lam_pos,virt_mu_long,virt_mu_pos,&
                                   common_virt_lam_pos,common_virt_mu_pos
              
  real(real8),dimension(:),allocatable::ci_sort
  real(real8),dimension(:,:),allocatable::aijk_vec
  real(real8),dimension(:,:),allocatable::sigma_nm2_lambda_ten,scep_ci_1_ten,lam_ten_sort
  !!!!TO HERE!!!!
  integer::allocatestatus,deallocatestatus
  
  real(kind=real8),external::ddot
#ifdef TIGER_USE_OMP
  real(real8),dimension(:),allocatable::tmp_ten,tmp_ten2
  integer::threadID,numthreads
  threadID = OMP_get_thread_num()+1
  numthreads = numberOfThreads
#else
  integer,parameter::threadID=1,numthreads=1
#endif

  allocate(aijk_vec(num_external,3),common_virt(num_orbitals),virt_lam_long(num_orbitals), &
        virt_lam_pos(num_orbitals),virt_mu_long(num_orbitals),virt_mu_pos(num_orbitals),&
        common_virt_lam_pos(num_orbitals),common_virt_mu_pos(num_orbitals),stat=allocatestatus)
  call allocatecheck(allocatestatus,"three_i_seg_loopdrv_sigma")

! START AUTOGENERATED INITIALIZATION
lam_lengthc2 = 0
nm1_weight = 0
nm2_weight = 0
swap_singles = .false.
px_index = 0
v_weight = 0
py_index = 0
doublet_valence = .false.
! END AUTOGENERATED INITIALIZATION 
 
  !// ALLOCATION FOR INTEGRALS
 

  !!!!!!!!!!!!!!!!!!!!!!! VARIABLE INITIALIZATION !!!!!!!!!!!!!!!!!!!!!!!!!!!!
  v_singles = 0
  nm2_singles = 0
  nm1_singles = 0
 
  if (mod(loop_type,3) /= 0) then
      chain = loop_type/3+1
  else
      chain = loop_type/3
  endif    
  member_loop = loop_type - 3*(chain-1)
  
  
  start_elec = sum(lambda_path%occupations(0:num_internal))
  internal_singles = lambda_path%num_singles
  
  !!!!!!!!!!!!!!!!!!!!!!!!!!! START OF ROUTINE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !//
  !// GET NUMBERS OF SINGLES.  WE CAN'T GET THE
  !// IBAR,JBAR,KBAR,LBAR, ETC. BECAUSE WE ARE GOING
  !// TO USE THE PARTIAL PATH FOR MULTIPLE LOOPS
  !//
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!

  call get_numbers_of_singles2(s1,s2,s3,s4,lambda_path%occupations,constraints)

  !// REORGANIZE OUR DATA IN PREPARATION FOR THE VECTORIZED 
  !// MULTIPLICATIONS
  call aijk_logic_hider(chain,member_loop,start_elec,internal_singles, & 
                        lambda_path%weight+1,rt_loop_weight+1, & 
                        nm2_singles,nm1_singles,v_singles,& 
                        nm2_weight,nm1_weight,v_weight, & 
                        Px_index,Py_index,doublet_valence, & 
                        swap_singles)

  !// GET DIMENSIONS    

  nm2_dim = fsn(nm2_singles)
  nm1_dim = fsn(nm1_singles)

  if (.not.doublet_valence) then
          
      !// IF THE NUMBER OF DIMENSIONS IS ALLOWED, COMPUTE
      !// COUPLING COEFFICIENTS AND DO MULTIPLICATIONS
      dim1: if (nm2_dim /= 0.and. nm1_dim /=0) then

          call coupling_coeff_driver_3_vec(s1,s2,s3,&
                                                 chain, member_loop,&
                                                 nm2_singles,nm1_singles,&
                                                 Px,Py,&
                                                 swap_singles)
  
          !// LOCATE THE STARTING SECTION OF THE CI VECTOR.  REMEMBER THE CI
          !// VECTOR SHOULD BE FORMATTED BY SPIN FUNCTIONS AT THIS POINT.
          !// A_ADDRESS  => INDEXES CONFIGURATIONS HAVING ONE VIRTUAL SINGLY OCCUPIED
          !// AB_ADDRESS => CONFIGURATIONS HAVING TWO DIFFERENT
          !//               VIRTUALS SINGLY OCCUPIED
          !// AA_ADDRESS => INDEXES CONFIGURATIONS HAVING ONE VIRTUAL DOUBLY OCCUPIED
          
          a_address  = internal_index_vector1(nm1_weight)
          ab_address = internal_index_vector2(nm2_weight)
          aa_address = internal_index_vector3(nm2_weight)
          
          if ((ab_address > 0 .or. aa_address > 0) .and. a_address > 0) then 
             

              lam_length     = num_allowed_virtuals(nm2_weight,"D") 
              lam_lengthC2 = (lam_length*(lam_length-1)/2)
              call get_virtuals(nm2_weight,"D",virt_lam_allow)

              mu_length     = num_allowed_virtuals(nm1_weight,"S")  
              call get_virtuals(nm1_weight,"S",virt_mu_allow)


              common_virt = 0
              virt_lam_long = 0
              virt_lam_pos = 0
              virt_mu_long = 0
              virt_mu_pos = 0

             do i = 1, lam_length
                idum = virt_lam_allow(i)
                virt_lam_long(idum) = idum 
                virt_lam_pos(idum) = i
             enddo

             do i = 1, mu_length
                idum = virt_mu_allow(i)
                virt_mu_long(idum) = idum 
                virt_mu_pos(idum) = i
             enddo


            common_virt_length = 0
            common_virt_lam_pos = 0
            common_virt_mu_pos = 0
            do i = 1, lam_length
               idum = virt_lam_allow(i)
               if ( virt_lam_long(idum) == virt_mu_long(idum) ) then
                  common_virt_length = common_virt_length + 1
                  common_virt(common_virt_length) = idum 
                  common_virt_lam_pos(common_virt_length) = virt_lam_pos(idum)
                  common_virt_mu_pos(common_virt_length) = virt_mu_pos(idum)
               endif
            enddo

            if (common_virt_length .eq. 0 ) return
            
            aijk_vec = 0.0D0
            
            ! allocate scratch space
            !!!!!! ULTIMATELY, REMOVE !!!!!!
            allocate(sigma_nm2_lambda_ten(lam_length,lam_length), &
              scep_ci_1_ten(lam_length,lam_length),ci_sort(common_virt_length), &
              lam_ten_sort(common_virt_length,lam_length),stat=allocatestatus)
            call allocatecheck(allocatestatus,"sigma_nm2_lambda_ten,scep_ci_1_ten")      
#ifdef TIGER_USE_OMP
            allocate(tmp_ten(common_virt_length),stat=allocatestatus)
            call allocatecheck(allocatestatus,"tmp_ten_omp")
#endif
            do i = 1,3
               do a=1,lam_length
                  a1 = virt_lam_allow(a)
                  aijk_vec(a,i) = aijk_buf(a1-num_internal,i)
               enddo
            enddo

            do ab_spin =1,nm2_dim
              
                  mode_1 = -2
                  if (ab_spin <=  fsn(nm2_singles-2)) mode_1 = 1

                  ab_start = ab_address + (ab_spin-1)*lam_lengthC2
                  aa_start = aa_address + (ab_spin-1)*(lam_length)

                  if (mode_1 .eq. 1) then
                      call scepper_diag_p1(scep_ci_1_ten,civec%v,ab_start,lam_length,civec%v,aa_start)
                  elseif (mode_1 .eq. -2) then
                      call scepper_diag_m2(scep_ci_1_ten,civec%v,ab_start,lam_length)
                  endif

                  lam_ten_sort = zero
                  do a_spin=1,nm1_dim
                      
                      a_start = a_address + (a_spin-1)*(mu_length)
                      
#ifdef TIGER_USE_OMP
                      tmp_ten = 0.0
#endif

                      do index_xy = 1,2 
                          
                          if (index_xy == 1) then 
                              cc = Px(ab_spin,a_spin)
                              int_index = Px_index
                          elseif (index_xy == 2) then 
                              cc = Py(ab_spin,a_spin)
                              int_index = Py_index
                          endif
                          
                          if (abs(cc) > integral_threshold) then
             
!//////////////////////////////////////////////////////////////////////////////////////////

                          do k_dum = 1, common_virt_length
                             idum2 = common_virt_lam_pos(k_dum)
                             idum = common_virt_mu_pos(k_dum)
                             ci_sort(k_dum)=civec%v(a_start+idum-1)
#ifdef TIGER_USE_OMP
                             tmp_ten(k_dum) = tmp_ten(k_dum) + cc*ddot(lam_length,aijk_vec(1,int_index),1,scep_ci_1_ten(1,idum2),1)
#else
                             sigmavec%v(a_start+idum-1) = sigmavec%v(a_start+idum-1) + cc*ddot(lam_length,aijk_vec(1,int_index),1,scep_ci_1_ten(1,idum2),1)
#endif
                          enddo

!/////////////////////////////////////////////////////////////////////////////////////////////////////////
                          
                          ! multiply
                          do j = 1,lam_length
                             call daxpy(common_virt_length,cc*aijk_vec(j,int_index),ci_sort(1),1,lam_ten_sort(1,j),1)
                          enddo
                          
!/////////////////////////////////////////////////////////////////////////////////////////////////////////////
                              
                          endif
                          
                      enddo
                      
#ifdef TIGER_USE_OMP
                      !call setSigmaLocks(a_start,a_start+mu_length-1)
                      call setLocks(sigmavec%l,a_start,a_start+mu_length-1)
                      do k_dum=1,common_virt_length
                          idum = common_virt_mu_pos(k_dum)
                          ! why are we allowed to do this? because the OMP specification explicitly refers to a "specific storage location" which is just what we want
                          !b$bomp atomic update
                          sigmavec%v(a_start+idum-1) = sigmavec%v(a_start+idum-1) + tmp_ten(k_dum)
                      enddo
                      !call unsetSigmaLocks(a_start,a_start+mu_length-1)
                      call unsetLocks(sigmavec%l,a_start,a_start+mu_length-1)
#endif
                      
                  enddo
                  
                  ! actually, we want to shuffle here...
                  sigma_nm2_lambda_ten = zero
                  ! shuffle, kind of nasty as we essentially stride w/ lam_length/common_virt_length
                  do i = 1,common_virt_length
                     idum = common_virt_lam_pos(i)
                     !>todo evaluate if daxpy() is faster for this, but due to the removal of temporaries, this should be the more stable solution
                     call daxpy(lam_length,1.0,lam_ten_sort(i,1),common_virt_length,sigma_nm2_lambda_ten(idum,1),lam_length)
                     !sigma_nm2_lambda_ten(idum,:,threadID) = lam_ten_sort(i,:,threadID)
                  enddo

                  if (mode_1 .eq. 1) then                  
                      call unscepper_diag_sigma_atomic_p1(sigma_nm2_lambda_ten,sigmavec,ab_start,lam_length,aa_start)
                  elseif (mode_1 .eq. -2) then
                      call unscepper_diag_sigma_atomic_m12(sigma_nm2_lambda_ten,sigmavec,ab_start,lam_length)
                  endif
              
              enddo

             ! deallocate scratch space
             deallocate(sigma_nm2_lambda_ten,scep_ci_1_ten,ci_sort,stat=deallocatestatus)
             call deallocatecheck(deallocatestatus,"sigma_nm2_lambda_tenscep_ci_1_ten")
#ifdef TIGER_USE_OMP
             deallocate(tmp_ten,stat=deallocatestatus)
             call deallocatecheck(deallocatestatus,"tmp_ten")
#endif
              
          endif
          
      endif dim1
     
 
  elseif (doublet_valence) then 
      !// IF THE NUMBER OF DIMENSIONS IS ALLOWED, COMPUTE
      !// COUPLING COEFFICIENTS AND DO MULTIPLICATIONS
      

      call coupling_coeff_driver_3_vec(s1,s2,s3,&
           chain, member_loop,&
           nm1_singles,v_singles,&
           Px,Py,&
           swap_singles)
      
      nm1_dim = fsn(nm1_singles)
      v_dim   = fsn(v_singles) 
      
      dim2: if (nm1_dim /= 0.and. v_dim /=0) then
          
          !// LOCATE THE STARTING SECTION OF THE CI VECTOR.  REMEMBER THE CI
          !// VECTOR SHOULD BE FORMATTED BY SPIN FUNCTIONS AT THIS POINT.
          !// V_ADDRESS  => INDEXES CONFIGURATIONS CORRESPONDING TO VALENCE STATES
          !// A_ADDRESS  => INDEXES CONFIGURATIONS HAVING ONE VIRTUAL SINGLY OCCUPIED
         

          v_address  = internal_index_vector0(v_weight)
          a_address  = internal_index_vector1(nm1_weight)
          
          if (a_address > 0 .and. v_address > 0) then 
              
              mu_length     = num_allowed_virtuals(nm1_weight,"S") 
              call get_virtuals(nm1_weight,"S",virt_mu_allow)
      
              aijk_vec = 0.0D0
#ifdef TIGER_USE_OMP
              allocate(tmp_ten(v_dim),tmp_ten2(mu_length),stat=allocatestatus)
              call allocatecheck(allocatestatus,"tmp_ten_omp2")
              tmp_ten=0.0
#endif
              
              do i = 1,3 
                 do a=1,mu_length
                    a1 = virt_mu_allow(a)
                    aijk_vec(a,i) = aijk_buf(a1-num_internal,i)
                 enddo
              enddo

              do a_spin =1,nm1_dim

                 a_start = a_address + (a_spin-1)*mu_length
#ifdef TIGER_USE_OMP
                 tmp_ten2 = 0.0
#endif
                  
                 do v_spin=1,v_dim
                    !// SET THE STARTING AND ENDING POSITIONS OF THE CI VECTOR
                    v_start  =  v_address + v_spin - 1
                    ! end is same as start
                      
                    do index_xy = 1,2 
                          
                        if (index_xy == 1) then 
                            cc = Px(a_spin,v_spin)
                            int_index = Px_index
                        elseif (index_xy == 2) then 
                            cc = Py(a_spin,v_spin)
                            int_index = Py_index
                        endif
                          
                        if (abs(cc) > integral_threshold) then
                              
                          !// NOW WE HAVE THE SIGMAVECTOR OVER PAO BASIS (N-1)
                          !WE NEED TO DO SOMETHING ABOUT INTEGRALS
                          cc2 = cc*civec%v(v_start)
#ifdef TIGER_USE_OMP
                          call daxpy(mu_length,cc2,aijk_vec(1,int_index),1,tmp_ten2,1)
#else
                          call daxpy(mu_length,cc2,aijk_vec(1,int_index),1,sigmavec%v(a_start),1)
#endif
                          !// NOW WE HAVE THE SIGMAVECTOR OVER PAO BASIS (VALENCE)
                          !WE NEED TO DO SOMETHING ABOUT INTEGRALS
#ifdef TIGER_USE_OMP
                          tmp_ten(v_spin) = tmp_ten(v_spin) + cc*ddot(mu_length,aijk_vec(1,int_index),1,civec%v(a_start),1)
#else
                          sigmavec%v(v_start) = sigmavec%v(v_start) + cc*ddot(mu_length,aijk_vec(1,int_index),1,civec%v(a_start),1)
#endif
                        endif
                        
                    enddo
                 enddo
                 
#ifdef TIGER_USE_OMP
                 !call setSigmaLocks(a_start,a_start+mu_length-1)
                 call setLocks(sigmavec%l,a_start,a_start+mu_length-1) 
                 sigmavec%v(a_start:a_start+mu_length-1) = sigmavec%v(a_start:a_start+mu_length-1) + tmp_ten2
                 !call unsetSigmaLocks(a_start,a_start+mu_length-1)
                 call unsetLocks(sigmavec%l,a_start,a_start+mu_length-1)
#endif
                 
              enddo
              
#ifdef TIGER_USE_OMP
              ! gather all the information from above
              !call setSigmaLocks(v_address,v_address+v_dim-1)
              call setLocks(sigmavec%l,v_address,v_address+v_dim-1)
              sigmavec%v(v_address:v_address+v_dim-1) = sigmavec%v(v_address:v_address+v_dim-1) + tmp_ten
              !call unsetSigmaLocks(v_address,v_address+v_dim-1)
              call unsetLocks(sigmavec%l,v_address,v_address+v_dim-1)
              
              deallocate(tmp_ten,tmp_ten2,stat=deallocatestatus)
#endif
              
          endif
          
      endif dim2
  endif
  
  deallocate(aijk_vec,common_virt,virt_lam_long, &
        virt_lam_pos,virt_mu_long,virt_mu_pos,&
        common_virt_lam_pos,common_virt_mu_pos,stat=deallocatestatus)
  call deallocatecheck(deallocatestatus,"three_i_seg_loopdrv_sigma")
  
end subroutine three_i_seg_loopdrv_sigma
!****************************************************************

!****************************************************************
!*****************************************************************
subroutine coupling_coeff_driver_3_vec(s1,s2,s3,&
                                               chain, member,&
                                               left_singles,right_singles,&
                                               Px,Py,&
                                               swap_singles)
                                               
   implicit none
                                   
  !// THIS SUBROUTINE JUST HIDES THE LOGIC OF THE CALL TO THE
  !// MATRIX ELEMENT ROUTINE.  SOME OF THIS LOGIC IS RATHER COMPLICATED
  !// BUT IT WILL WORK, FAST I HOPE.
  
  !!!!!!!!!!!!!!!!!!!!!!!!!!!  VARIABLE DECLARATION !!!!!!!!!!!!!!!!!!!!!!!!!!!
  
  integer,intent(in)::s1,s2,s3           !// NUMBER OF SINGLES
  integer::ibar,jbar,kbar     !// ORBITAL INDICES
  integer::sbar                !// NO IF SINGLES IN LAMBDA
  integer,intent(in)::chain               !// THE LOOP CHAIN
  integer,intent(in)::member              !// THE MEMBER LOOP WITHIN THE CHAIN
  integer,intent(in)::left_singles         !// SINGLES IN THE LAMBDA AND MU PATHS
  integer,intent(in)::right_singles 
  integer::lambda_singles      !// SINGLES IN THE LAMBDA AND MU PATHS
  integer::mu_singles 
 ! integer::length                !// SIZE OF MATRIX ELEMENT ARRAY
  
  logical::swap_singles
  
  real(real8),dimension(:,:),intent(inout)::Px,Py   !// WHAT WE ARE COMPUTING
  real(real8),parameter::two=real(2.0,real8),sqrt2=real(sqrt(two),real8)
  integer::nsfl,nsfr,maxD
  
  !!!!!!!!!!!!!!!!!!!!!!!!!!! START OF ROUTINE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  
      call singles_to_3seg_indices_vec(chain, s1, s2, s3,&
                                       ibar,jbar,kbar)
      nsfl = fsn(left_singles)
      nsfr = fsn(right_singles)
      maxD = max(nsfl,nsfr)
  
      lambda_singles = left_singles 
      mu_singles     = right_singles
      if  (swap_singles) then 
  
          lambda_singles = right_singles 
          mu_singles     = left_singles
  
      endif 
  
      sbar = lambda_singles  
      call compute_coupling_coeff_vec(chain, member,&
                                             ibar,jbar,kbar,sbar,&
                                             lambda_singles,mu_singles,&
                                             Px,Py)                                 
          
      if (chain == 8) then 
          Px(1:maxD,1:maxD) = sqrt2*Px(1:maxD,1:maxD)
          Py(1:maxD,1:maxD) = sqrt2*Py(1:maxD,1:maxD)
      endif 
  
      if (swap_singles) then 
          Px(1:maxD,1:maxD) = transpose(Px(1:maxD,1:maxD))
          Py(1:maxD,1:maxD) = transpose(Py(1:maxD,1:maxD))
      endif 
  
end subroutine coupling_coeff_driver_3_vec
  
  
!*****************************************************************
subroutine singles_to_3seg_indices_vec(chain, s1, s2, s3,&
                                         ibar,jbar,kbar)
                                         
  implicit none
  
  !//  THIS ROUTINE IS VERY SIMPLE.  WE JUST TAKE NUMBERS OF SINGLES
  !//  AND GET IBAR, JBAR, KBAR, LBAR FROM THEM.  
  
  !!!!!!!!!!!!!!!!!!!!!!!!!!!  VARIABLE DECLARATION !!!!!!!!!!!!!!!!!!!!!!!!!!!
  integer,intent(in)::chain                      !// LABELS THE CHAIN OF LOOPS
  integer,intent(in)::s1,s2,s3                  !// NUMBERS OF SINGLES
  integer,intent(out)::ibar,jbar,kbar             !// WHAT WE ARE AFTER
  
  !!!!!!!!!!!!!!!!!!!!!!!!!!! START OF ROUTINE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !// NOW CONVERT THE SINGLES TO IBAR, JBAR, KBAR    
  !// FOR INDICES SEE CPR PAPER.
  !// IF U WANT TO CHECK FOR C1' FOR E.G.  SEE C3 FOR FOUR SEGMENT LOOP BUT C1 FOR INDICES.
  
  if (chain == 1 .or. chain == 5) then
      
      !// C3 NON-VECTORIZED I>J>K  [ C1' and C1" ]
      ibar = s1 + s2 + s3
      jbar = s1 + s2 
      kbar = s1 + 1
  
  elseif (chain == 2 .or. chain == 6) then    
  
      !// C5 NON-VECTORIZED I>K>J  [ C2' and C2" ]
      ibar = s1 + s2 + s3
      kbar = s1 + s2
      jbar = s1 
      
  elseif (chain == 3 .or. chain == 7) then       
  
      !// C6 NON-VECTORIZED K>I>J  [ C3'and C3" ]
      kbar = s1 + s2 + s3 -1
      ibar = s1 + s2 
      jbar = s1
      
  elseif (chain == 4 .or. chain == 8) then      
  
      !// C8 NON-VECTORIZED I>J>K  [ C4' and C4" ]
      ibar = s1 + s2 + s3
      jbar = s1 + s2
      kbar = s1     
     
  elseif (chain == 10) then 
  
       !// [323] B2 - 3 
       
       ibar = s1   
  
  elseif (chain == 11) then 
  
       !// [233] B2 - 5
  
       ibar = s1 + s2 
  
  elseif (chain == 12) then 
  
       !// [565] B2 - 4 
  
       ibar = s1 
  
  elseif (chain == 13) then 
  
       !// [655] B2 - 6
  
       ibar = s1 + s2  
  
  endif    
  
end subroutine singles_to_3seg_indices_vec
  
  
!*****************************************************************
subroutine compute_coupling_coeff_vec(chain, member,&
                                           ibar,jbar,kbar,sbar,&
                                           lambda_singles,mu_singles,&
                                           Px,Py)
               
  use spin_mod,only:contracted_cycle_stateless
  use spin_var_mod,only:cycles,spin_matrix,sft
  
  implicit none
  
  !// THIS SUBROUTINE COMPUTES COUPLING COEFFICIENTS FOR THE FOUR SEGMENT
  !// LOOPS HAVING THREE SEGMENTS IN THE INTERNAL SPACE, STORING THEM IN Px
  !// AND Py AS APPROPRIATE.  CPR PAPER HAS SOME TYPOs. FOR e.g CHAIN = 4 and
  !// CHAIN = 8, THE P2 IN CPR PAPER IS P3 AND VICE VERSA FOR CHAIN = 7, Py
  !// SHOULD HAVE KBAR+2 IN ALL MEMBERS IN THIS CHAIN FOR FIRST ARGUMENT TO
  !// CALL CONTRACTED_CYCLE
  
  !!!!!!!!!!!!!!!!!!!!!!!!!!!  VARIABLE DECLARATION !!!!!!!!!!!!!!!!!!!!!!!!!!!                                         
  integer,intent(in)::chain                      !// THE LOOP CHAIN
  integer,intent(in)::member                     !// THE MEMBER WITHIN THE CHAIN
  integer,intent(in)::ibar,jbar,kbar            !// ORBITAL INDICES
  integer,intent(in)::sbar                       !// NO IF SINGLES IN LAMBDA
  integer,intent(in)::lambda_singles             !// SINGLES IN LAMBDA AND MU PATHS
  integer,intent(in)::mu_singles
  !integer,intent(in)::length                       !// DIMENSION OF COUPLING COEFFICIENT MATRIX
  
  real(real8),dimension(:,:),intent(inout)::Px,Py   !// COUPLING COEFFICIENT MATRICES
  real(real8),dimension(:,:),allocatable::locContracted !//some fast scratch
  real(real8),parameter::sqrt2 = real(sqrt(real(2.0,real8)),real8)
  real(real8),parameter::two = real(2.0,real8)
  real(real8),parameter::zero = real(0.0,real8)
  
  integer::status,nsfl,nsfr,maxD
                                           
  !!!!!!!!!!!!!!!!!!!!!!!!!!! START OF ROUTINE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  
  nsfl = fsn(lambda_singles)
  nsfr = fsn(mu_singles)
  maxD = max(nsfl,nsfr)
  
  allocate(locContracted(maxD,maxD),stat=status)
  call allocatecheck(status,"compute_coupling_coeff_vec")
  
  if (chain <= 3) then
       
       !// C1',C2',C3' LOOPS
       if (member == 1) then
       
        !// PX = P1, PY = P3
          
        !// FIRST PX
        call contracted_cycle_stateless(kbar,jbar,sbar,ibar,0,0,lambda_singles,mu_singles,Px,cycles,sft,spin_matrix)
          
        !// NOW PY
        call contracted_cycle_stateless(kbar,ibar-1,sbar,jbar,0,0,lambda_singles,mu_singles,Py,cycles,sft,spin_matrix)
  
        elseif (member == 2) then
       
        !// PX = -P1, PY = P2 = P1 + P3 
          
        !// FIRST PX
        call contracted_cycle_stateless(kbar,jbar,sbar,ibar,0,0,lambda_singles,mu_singles,Px,cycles,sft,spin_matrix)
        Px(1:maxD,1:maxD) = -Px(1:maxD,1:maxD)
          
        !// NOW PY
        Py(1:maxD,1:maxD) = -Px(1:maxD,1:maxD) 
  
        call contracted_cycle_stateless(kbar,ibar-1,sbar,jbar,0,0,lambda_singles,mu_singles,locContracted,cycles,sft,spin_matrix)
        Py(1:maxD,1:maxD) = Py(1:maxD,1:maxD) + locContracted
  
        elseif (member == 3) then
       
        !// PX = -P3, PY = P2 = P1 + P3 
          
        !// FIRST PX
        call contracted_cycle_stateless(kbar,ibar-1,sbar,jbar,0,0,lambda_singles,mu_singles,Px,cycles,sft,spin_matrix)
        Px(1:maxD,1:maxD) = -Px(1:maxD,1:maxD)
          
        !// NOW PY
        Py(1:maxD,1:maxD) = -Px(1:maxD,1:maxD) 
  
        call contracted_cycle_stateless(kbar,jbar,sbar,ibar,0,0,lambda_singles,mu_singles,locContracted,cycles,sft,spin_matrix)
        Py(1:maxD,1:maxD) = Py(1:maxD,1:maxD) + locContracted
  
       endif
  
  elseif (chain == 4 .or. chain == 8) then
       
       !// C4',C4" LOOPS
       if (member == 1) then
       
        !// PX = P1, PY = P3 (WHAT IS P2 IS P3 AND VICE VERSA IN PAPER).
          
        !// FIRST PX
        call contracted_cycle_stateless(kbar,jbar,sbar,ibar,kbar,0,lambda_singles,mu_singles,Px,cycles,sft,spin_matrix)
          
        call contracted_cycle_stateless(kbar,ibar-1,sbar,jbar,kbar,0,lambda_singles,mu_singles,Py,cycles,sft,spin_matrix)
  
        elseif (member == 2) then
       
        !// PX = P1, PY = P2 
          
        !// FIRST PX
        call contracted_cycle_stateless(kbar,jbar,sbar,ibar,kbar,0,lambda_singles,mu_singles,Px,cycles,sft,spin_matrix)
          
        !// NOW PY
        call contracted_cycle_stateless(jbar,ibar-1,sbar,kbar,jbar-1,0,lambda_singles,mu_singles,Py,cycles,sft,spin_matrix)
  
        elseif (member == 3) then
       
        !// PX = P3, PY = P2 
          
        !// FIRST PX
        call contracted_cycle_stateless(kbar,ibar-1,sbar,jbar,kbar,0,lambda_singles,mu_singles,Px,cycles,sft,spin_matrix)
          
        !// NOW PY
        call contracted_cycle_stateless(jbar,ibar-1,sbar,kbar,jbar-1,0,lambda_singles,mu_singles,Py,cycles,sft,spin_matrix)
  
       endif
  
  elseif (chain == 5 .or. chain == 6) then
  
  
       !// C1",C2" LOOPS
       if (member == 1) then
       
         !// PX = -P1, PY = P3' = P1 + P2'
          
         !// FIRST PX
         call contracted_cycle_stateless(kbar,jbar,sbar,ibar,0,0,lambda_singles,mu_singles,Px,cycles,sft,spin_matrix)
         Px(1:maxD,1:maxD) = -sqrt2*Px(1:maxD,1:maxD)
          
         !// NOW PY
         Py(1:maxD,1:maxD) = -Px(1:maxD,1:maxD)
    
         !// NOTE HERE I > K FOR COMPUTING P3'   
         call contracted_cycle_stateless(kbar,sbar,ibar-1,jbar,ibar,0,lambda_singles,mu_singles,locContracted,cycles,sft,spin_matrix)
         Py(1:maxD,1:maxD) = Py(1:maxD,1:maxD) + locContracted
         
  
       elseif (member == 2) then
       
         !// PX = P1, PY = P2'
          
         !// FIRST PX
         call contracted_cycle_stateless(kbar,jbar,sbar,ibar,0,0,lambda_singles,mu_singles,Px,cycles,sft,spin_matrix)
         Px(1:maxD,1:maxD) = sqrt2*Px(1:maxD,1:maxD)
          
         !// NOW PY
         call contracted_cycle_stateless(kbar,sbar,ibar-1,jbar,ibar,0,lambda_singles,mu_singles,Py,cycles,sft,spin_matrix)
  
      elseif (member == 3) then
       
         !// PX = P3, PY = P2'
          
         !// FIRST PX
         call contracted_cycle_stateless(kbar,ibar-1,sbar,jbar,0,0,lambda_singles,mu_singles,Px,cycles,sft,spin_matrix)
         Px(1:maxD,1:maxD) = sqrt2*Px(1:maxD,1:maxD)
          
         !// NOW PY
         call contracted_cycle_stateless(kbar,sbar,ibar-1,jbar,ibar,0,lambda_singles,mu_singles,Py,cycles,sft,spin_matrix)
  
      endif 
  
  elseif (chain == 7) then
  
        !// C3" LOOPS . USE KBAR+2  FOR COMPUTING P2' FOR CHAIN == 7 (See Py).
       if (member == 1) then
       
         !// PX = -P1, PY = P3' = P1 + P2'
          
         !// FIRST PX
         call contracted_cycle_stateless(kbar,jbar,sbar,ibar,0,0,lambda_singles,mu_singles,Px,cycles,sft,spin_matrix)
         Px(1:maxD,1:maxD) = -sqrt2*Px(1:maxD,1:maxD)
          
         !// NOW PY
         Py(1:maxD,1:maxD) = -Px(1:maxD,1:maxD)
    
         !// NOTE HERE I > K FOR COMPUTING P3'   
         call contracted_cycle_stateless(kbar+2,sbar,ibar-1,jbar,ibar-1,0,lambda_singles,mu_singles,locContracted,cycles,sft,spin_matrix)
         Py(1:maxD,1:maxD) = Py(1:maxD,1:maxD) + locContracted
         
  
       elseif (member == 2) then
       
         !// PX = P1, PY = P2'
          
         !// FIRST PX
         call contracted_cycle_stateless(kbar,jbar,sbar,ibar,0,0,lambda_singles,mu_singles,Px,cycles,sft,spin_matrix)
         Px(1:maxD,1:maxD) = sqrt2*Px(1:maxD,1:maxD)
          
         !// NOW PY
         call contracted_cycle_stateless(kbar+2,sbar,ibar-1,jbar,ibar-1,0,lambda_singles,mu_singles,Py,cycles,sft,spin_matrix)
  
      elseif (member == 3) then
       
         !// PX = P3, PY = P2'
          
         !// FIRST PX
         call contracted_cycle_stateless(kbar,ibar-1,sbar,jbar,0,0,lambda_singles,mu_singles,Px,cycles,sft,spin_matrix)
         Px(1:maxD,1:maxD) = sqrt2*Px(1:maxD,1:maxD)
          
         !// NOW PY
         call contracted_cycle_stateless(kbar+2,sbar,ibar-1,jbar,ibar-1,0,lambda_singles,mu_singles,Py,cycles,sft,spin_matrix)
  
      endif 
  
  
  elseif (chain  == 10 .or. chain == 11) then 
           
         !// PX = P2 
         call contracted_cycle_stateless(sbar,ibar,0,0,0,0,lambda_singles,mu_singles,Px,cycles,sft,spin_matrix)
         Px(1:maxD,1:maxD) = sqrt2*Px(1:maxD,1:maxD)
  
         Py(1:maxD,1:maxD) = zero 
  
  elseif (chain  == 12 .or. chain == 13) then 
           
         !// PX = -P2 
         call contracted_cycle_stateless(sbar,ibar,0,0,0,0,lambda_singles,mu_singles,Px,cycles,sft,spin_matrix)
         Px(1:maxD,1:maxD) = -Px(1:maxD,1:maxD)
  
         Py(1:maxD,1:maxD) = zero
         
  else 
  
        write(ioOutput,*) "ERROR: Unknown case in compute_coupling_coeff_vec (mod2). ",chain
        flush(ioOutput)
        stop
  endif
  
  deallocate(locContracted,stat=status)
  call deallocatecheck(status,"compute_coupling_coeff_vec")
  
end subroutine compute_coupling_coeff_vec
  
!*****************************************************************
subroutine aijk_logic_hider(chain,member,start_elec,internal_singles, & 
                              lambda_weight,mu_weight, & 
                              nm2_singles,nm1_singles,v_singles,& 
                              nm2_weight,nm1_weight,v_weight,& 
                              Px_index,Py_index,doublet_valence,& 
                              swap_singles)
                              
  implicit none
  
  !// THIS ROUTINE SETS ALL THE PARAMETER LIKE WEIGHTS, NUMBER OF SINGLES 
  !// IN EACH PATH FOR EACH ChAIN. 
  !// ALSO SETS THE INDEXING SChEME FOR INTEGRALS  FOR EACH CHAIN AND MEMBER. 
  
  integer,intent(in)::chain
  integer,intent(in)::member 
  integer,intent(in)::start_elec
  integer,intent(in)::internal_singles 
  integer,intent(in)::lambda_weight,mu_weight 
  integer,intent(out)::nm2_weight,nm1_weight,v_weight 
  integer,intent(out)::nm2_singles,nm1_singles,v_singles
  
  integer,intent(out)::Px_index,Py_index
  
  logical,intent(out)::doublet_valence 
  logical,intent(out)::swap_singles
  
  if (chain == 1 .or. chain == 2 .or. chain == 3) then  !//C1',C2',C3' 
      
      swap_singles = .true.
      
      if (start_elec == num_elec - 1) then
          
          doublet_valence = .false.
          
          nm2_weight = mu_weight 
          nm1_weight = lambda_weight  
          
          nm2_singles = internal_singles + 1        
          nm1_singles = internal_singles + 1
          
          
      elseif (start_elec == num_elec) then
          
          doublet_valence = .true.                       
          
          nm1_weight = mu_weight 
          v_weight   = lambda_weight 
          
          nm1_singles = internal_singles         
          v_singles   = internal_singles  
          
      endif
      
  elseif (chain == 4) then  !//C4' 
      
      swap_singles = .true.
      
      if (start_elec == num_elec - 1) then
          
          doublet_valence = .false.
          
          nm2_weight = mu_weight 
          nm1_weight = lambda_weight  
          
          nm2_singles = internal_singles - 1        
          nm1_singles = internal_singles + 1
          
          
      elseif (start_elec == num_elec) then
          
          doublet_valence = .true.                       
          
          nm1_weight = mu_weight 
          v_weight   = lambda_weight 
          
          nm1_singles = internal_singles - 2         
          v_singles   = internal_singles 
          
      endif
      
  elseif (chain == 5 .or. chain == 6 .or. chain == 7) then  !// C1",C2",C3" 
      
      swap_singles = .false.
      
      if (start_elec == num_elec - 2) then
  
          doublet_valence = .false.
          
          nm2_weight = lambda_weight 
          nm1_weight = mu_weight  
          
          nm2_singles = internal_singles + 2        
          nm1_singles = internal_singles 
          
              
      elseif (start_elec == num_elec -1) then
          
          doublet_valence = .true.                       
          
          nm1_weight = lambda_weight 
          v_weight   =  mu_weight 
          
          nm1_singles = internal_singles + 1        
          v_singles   = internal_singles - 1 
          
      endif
      
  elseif (chain == 8) then  !//C4" 
      
      swap_singles = .false.
      
      if (start_elec == num_elec - 2) then
          
          doublet_valence = .false.
          
          nm2_weight = lambda_weight  
          nm1_weight = mu_weight 
          
          nm2_singles = internal_singles + 2
          nm1_singles = internal_singles - 2        
          
          
      elseif (start_elec == num_elec-1) then
          
          doublet_valence = .true.                       
          
          nm1_weight   = lambda_weight 
          v_weight     = mu_weight 
          
          nm1_singles = internal_singles + 1         
          v_singles   = internal_singles - 3
          
          endif                        
          
      elseif (chain == 10 .or. chain == 11)  then   !//B2 -3 and B2 - 5 
          
          swap_singles = .false.
          
          if (start_elec == num_elec - 2) then
              
              doublet_valence = .false.
              
              nm2_weight = lambda_weight 
              nm1_weight = mu_weight  
              
              nm2_singles = internal_singles + 2        
              nm1_singles = internal_singles 
              
              
          elseif (start_elec == num_elec -1) then
              
              doublet_valence = .true.                       
              
              nm1_weight = lambda_weight 
              v_weight   =  mu_weight 
              
              nm1_singles = internal_singles + 1        
              v_singles   = internal_singles - 1 
              
          endif
          
      elseif (chain == 12 .or. chain == 13)  then  !// B2 - 4 and B2 - 6  
          
          swap_singles = .true.
          
          if (start_elec == num_elec - 1) then
              
              doublet_valence = .false.
              
              nm2_weight = mu_weight  
              nm1_weight = lambda_weight 
              
              nm2_singles = internal_singles + 1        
              nm1_singles = internal_singles + 1 
              
              
          elseif (start_elec == num_elec) then
              
              doublet_valence = .true.                       
              
              nm1_weight  = mu_weight 
              v_weight = lambda_weight 
              
              nm1_singles = internal_singles    
              v_singles   = internal_singles  
              
          endif
      endif
      
      
      !// INTEGRAL INDEXINGS SCHEME 
      
      if (chain == 1 .or. chain == 4 .or. chain == 5 .or. chain == 8) then 
          
          if (member  == 1) then 
              Px_index = 1
              Py_index = 3
          elseif (member  == 2) then 
              Px_index = 1
              Py_index = 2 
          elseif (member  == 3) then 
              Px_index = 3
              Py_index = 2
          endif
          
      elseif (chain == 2 .or. chain == 6) then 
          
          if (member  == 1) then 
              Px_index = 1
              Py_index = 2 
          elseif (member  == 2) then 
              Px_index = 1
              Py_index = 3 
          elseif (member  == 3) then 
              Px_index = 2 
              Py_index = 3 
              
          endif
          
          
  elseif (chain == 3 .or. chain == 7) then 
      
      if (member  == 1) then 
          Px_index = 3
          Py_index = 2 
      elseif (member  == 2) then 
          Px_index = 3 
          Py_index = 1 
      elseif (member  == 3) then 
          Px_index = 2 
          Py_index = 1 
      endif
      
  elseif  (chain == 10 .or. chain == 12) then 
      
      Px_index = 1 
      
  elseif  (chain == 11 .or. chain == 13) then 
      
      Px_index = 2 
      
  endif
  
end subroutine aijk_logic_hider
  
       
!*****************************************************************
!****************************************************************
subroutine two_internal_seg_ijaj_cho(civec, sigmavec, cho_data,lambda_path,loc_scr,mod2vars)

  use cholesky_structs
  use locist_var_mod,only:locist_scratch
  use two_seg_var_mod
  
  implicit none
 
  !// THIS IS THE MAIN DRIVER ROUTINE FOR THE TREATMENT OF THREE SEGMENT
  !// LOOPS WHICH HAVE TWO SEGMENTS IN THE INTERNAL SPACE.  
  
  !!!!!!!!!!!!!!!!!!!!!!!!!!!  VARIABLE DECLARATION !!!!!!!!!!!!!!!!!!!!!!!!!!!
  type(cholesky_data)::cho_data
  type(orbital_path)::lambda_path
  type(locist_scratch)::loc_scr
  type(threefourmod2vars)::mod2vars
  type(blockedLockVectorType) :: civec, sigmavec 
  
  integer::i,j                           !// LABELS THE LOOP LEVELS
  integer::loop_type                      !// LABELS THE LOOPS, DUH
  integer::ij_1
  
  mod2vars%ijka_flag = .false. 
  
  !// THE NEXT TASK HERE USES THE (IJ|KA) ROUTINES  SINCE (IJ|AJ) AND (IJ|KA)
  !// INVOLVE THE SAME INTERACTIONS.  THE VARIABLE IJKA_FLAG IS EXTREMELY CRUCIAL 
  !// AS IT DETERMINES CHAIN NUMBER. 
  
  !!!!!!!!!!!!!!!!!!!!!!! VARIABLE INITIALIZATION !!!!!!!!!!!!!!!!!!!!!!!!!!!!
  lambda_path%occupations = 0
  lambda_path%constraints = 0
  lambda_path%arc_weights = 0
  lambda_path%singles = 0
  lambda_path%num_singles = 0
  
  !!!!!!!!!!!!!!!!!!!!!!!!!!! START OF ROUTINE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !// LOOP OVER SETS OF INTERNAL ORBITALS I > J > K.  NOTE THAT THIS ORDERING
  !// OF ORBITALS DOES NOT CONFORM TO THE ORDERING OUTLINED IN DUCH'S PAPER.
  !// IT IS DONE THIS WAY FOR CONVENIENCE

  if (mod2vars%iter_count .eq. 1) then
  mod2vars%ijaj_rec = 0

  do i = 1,num_internal
      do j = 1,i-1

         if (ignorable_pair(i,j) ) cycle

         mod2vars%ij_ind = i*(i-1)/2 + j
              
          !// GET THE INTEGRALS
          
          !// NOW RUN OVER LOOP TYPE
          do loop_type = 1,4
          
              !// REINITIALIZE FOR SUPER SAFETY!
              lambda_path%occupations = 0
              lambda_path%arc_weights = 0
              lambda_path%constraints=0
              lambda_path%singles = 0
              lambda_path%num_singles = 0
              
              !// INITIALIZE THINGS FOR THE BROKEN CONSTRAINED
              !// SEARCH
              
              !// STORE THE LOOP TYPE
              lambda_path%loop_type = loop_type
              
               !// NOW LOAD CONSTRAINTS UP AND TRY TO BUILD THE LOOPS
              lambda_path%constraints(2,6) = 1  !// CONSTRAINT COUNT
              lambda_path%constraints(1,6) = LMO_3_INT_COMP !// NEXT TASK
              lambda_path%constraints(2,3) = num_internal+1
            
              !// FOR BUILDING THE MU PATH
              lambda_path%level1 = j
  
              !// LOOP LEVELS
              lambda_path%constraints(2,1:2) = (/j,i/)
                          
              !// LAMBDA, MU PATHS
              lambda_path%constraints(1,1:2) = &
                  two_seg_ijaj_loops(loop_type,1:2,1)
              lambda_path%constraints(3,1:2) = &
                  two_seg_ijaj_loops(loop_type,1:2,2)
                                  
              !// NOW DO THE SEARCH
              lambda_path%num_singles = 0
              call broken_constrained_search(lambda_path,0,0,mod2vars=mod2vars)
       
          enddo
  
      enddo
  enddo   

  endif
  
  rewind(unit=360)
  rewind(unit=361)

  mod2vars%ijaj_rec = 0


  do i = 1,num_internal
      do j = 1,i-1
  
         if (ignorable_pair(i,j) ) cycle            
         
         mod2vars%ij_ind = i*(i-1)/2 + j

          !// GET THE INTEGRALS

          call get_ijaj_cho(cho_data,i,j,mod2vars%iter_count)
   
          ij_1 = mod2vars%ij_ind
          do while (ij_1 .eq. mod2vars%ij_ind)
             call threeInternSegComplVecLmoRes(civec, sigmavec, ij_1,loc_scr,mod2vars)
          enddo
  
      enddo
  enddo   
  
end subroutine two_internal_seg_ijaj_cho
!*****************************************************************
!****************************************************************
!*****************************************************************

!*****************************************************************  
subroutine three_intern_seg_compl_vec_lmo(lambda_path,mod2vars)

  !// IN THIS ROUTINE I BUILD UP THE COMPLEMENT TO THE THREE SEGMENT OPEN LOOPS
  !// WHICH RESIDE ENTIRELY IN THE INTERNAL SPACE.  FROM HERE WE CALL THE
  !// ROUTINE TO DO THE MULTIPLICATION AS WELL.  BEFORE THIS IS DONE WE
  !// MUST CALL THE ROUTINE TO DO COMPUTE THE COUPLING COEFFICIENTS.  THESE
  !// ROUTINES WILL BE HACKS OF THE ROUTINE USED IN THE FOUR SEGMENT MODULE.
  !// THIS ROUTINE IS A HACK OF FOUR_INTERNAL_SEG_COMPLEMENT
  !// AUTHORS: DEREK WALTER AND ARUN VENKATNATHAN

  !!!!!!!!!!!!!!!!!!!!!!!!!!!  VARIABLE DECLARATION !!!!!!!!!!!!!!!!!!!!!!!!!!

  use time_var_mod
  use locist_var_mod,only:locist_scratch

  implicit none

  type(orbital_path),intent(inout)::lambda_path
  type(threefourmod2vars),intent(inout)::mod2vars

  integer::chain                  !// LOOP CHAIN
  integer::member_loop            !// LOOP WITHIN A CHAIN
  integer::internal_singles       !// NUMBER OF SINGLES IN INTERNAL PATH OF PATH
  integer::current_vertex         !// USED IN BUILDING MU PATH
  integer::step_type              !// KEEPS TRACK OF STEP IN MU PATH CONSTRUCTION
  integer::path_elecs             !// CUMULATIVE OCCUPATION IN MU PATH
  integer::top_level              !// LEVEL OF FIRST LOOP SEGMENT
  integer::mu_levels              !// LABELS LEVELS IN MU PATH
  integer::constraint_count       !// KEEP TRACK OF CONSTRAINTS IN BUILDING MU PATH
  integer::start_elec             !// OCCUPATION WHERE INTERNAL CSF MEETS UP WITH EXTERNAL SPACE
  integer::s1,s2,s3,s4            !// NUMBERS OF SINGLES IN DIFFERENT LOOP SEGMENTS
  
#ifdef TIGER_USE_OMP
  integer::ten_pointer
  ten_pointer = OMP_get_thread_num()+1
#else
  integer,parameter::ten_pointer = 1
#endif

   !// STORE THE WEIGHT OF THE LAMBDA_PATH
  lambda_path%weight = sum(lambda_path%arc_weights(0:num_internal))
  start_elec = sum(lambda_path%occupations(0:num_internal))

  if (skip_this_internal(lambda_path%weight,start_elec)) return

  !!!!!!!!!!!!!!!!!!!!!!! VARIABLE INITIALIZATION !!!!!!!!!!!!!!!!!!!!!!!!!!!!
 
  if (.not. mod2vars%ijka_flag) then 
      chain = lambda_path%loop_type  + 9
      member_loop = 1                   !// THIS STATEMENT IS NOT REQUIRED 
      
  else 
  
      if (mod(lambda_path%loop_type,3) /= 0) then
          chain = lambda_path%loop_type/3+1
      else
          chain = lambda_path%loop_type/3
      endif    
      member_loop = lambda_path%loop_type - 3*(chain-1)
  
  endif 
  
  internal_singles = lambda_path%num_singles
  
  !// INITIALIZE VARIABLES FOR BUILDING MU PATH
  top_level = lambda_path%level1
  constraint_count = 1
  lambda_path%rt_loop_weight = 0
  path_elecs = sum(lambda_path%occupations(0:top_level-1))
  
  !!!!!!!!!!!!!!!!!!!!!!!!!!! START OF ROUTINE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !//
  !// GET NUMBERS OF SINGLES.  WE CAN'T GET THE
  !// IBAR,JBAR,KBAR,LBAR, ETC. BECAUSE WE ARE GOING
  !// TO USE THE PARTIAL PATH FOR MULTIPLE LOOPS
  !//
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!
  call get_numbers_of_singles(s1,s2,s3,s4,lambda_path)!%occupations,lambda_path%constraints)
  
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !// 
  !//  BUILD THE MU PATH
  !// 
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!
  do mu_levels = top_level, num_internal
  
      current_vertex = vertex(mu_levels-1,path_elecs) 
      
      !// CHECK TO SEE IF THIS IS A CONSTRAINED LEVEL AND GET THE STEP_TYPE
      if ((mu_levels)==lambda_path%constraints(2,constraint_count)) then
          step_type = lambda_path%constraints(3,constraint_count)
          constraint_count = constraint_count + 1
      else
          step_type = lambda_path%occupations(mu_levels)
      endif
      
      !// TRY TO ADD THE STEP
      if (step_type == 2) then
          
          if (add2(mu_levels-1,path_elecs)) then
              path_elecs = path_elecs + 2
              lambda_path%rt_loop_weight = lambda_path%rt_loop_weight + &
                                           abs(y2(current_vertex))
          else
              return
          endif
          
      elseif(step_type == 1) then
  
          if (add1(mu_levels-1,path_elecs)) then
              path_elecs = path_elecs + 1
              lambda_path%rt_loop_weight = lambda_path%rt_loop_weight + &
                                           abs(y1(current_vertex))
          else
              return
          endif
          
      elseif(step_type == 0) then
          
          if (.not.add0(mu_levels-1,path_elecs)) return
          
      endif
      
  enddo
  
  
  !// FOR THE RT_LOOP_WEIGHT ADD IN THE WEIGHTS OF THE RELEVANT PARTS
  !// OF THE HEAD AND TAIL PATHS.  THIS WILL END UP BEING THE MU PATH WEIGHT
  lambda_path%rt_loop_weight = lambda_path%rt_loop_weight +&
                               sum(lambda_path%arc_weights(0:lambda_path%level1-1))
                               
     
  !//  TEST TO SEE IF WE SHOULD EXIT RIGHT NOW FOR LOCAL CI                             
  if (skip_this_internal(lambda_path%rt_loop_weight,path_elecs)) return


  mod2vars%ijaj_rec = mod2vars%ijaj_rec+1
  write(unit=405,rec=mod2vars%ijaj_rec) mod2vars%ij_ind,chain,member_loop,start_elec,internal_singles,lambda_path%weight, &
                               lambda_path%rt_loop_weight,s1,s2,s3,s4
                                 
end subroutine three_intern_seg_compl_vec_lmo
!*********************************************************************************
subroutine threeInternSegComplVecLmoRes(civec, sigmavec, ij_1,loc_scr,mod2vars)

    ! yes the naming scheme for this function is completly different than everything else
    ! I'm just not sure how to keep the symbol under 32 characters without removing the '_'
    ! - David

  !// IN THIS ROUTINE I BUILD UP THE COMPLEMENT TO THE THREE SEGMENT OPEN LOOPS
  !// WHICH RESIDE ENTIRELY IN THE INTERNAL SPACE.  FROM HERE WE CALL THE
  !// ROUTINE TO DO THE MULTIPLICATION AS WELL.  BEFORE THIS IS DONE WE
  !// MUST CALL THE ROUTINE TO DO COMPUTE THE COUPLING COEFFICIENTS.  THESE
  !// ROUTINES WILL BE HACKS OF THE ROUTINE USED IN THE FOUR SEGMENT MODULE.
  !// THIS ROUTINE IS A HACK OF FOUR_INTERNAL_SEG_COMPLEMENT
  !// AUTHORS: DEREK WALTER AND ARUN VENKATNATHAN

  !!!!!!!!!!!!!!!!!!!!!!!!!!!  VARIABLE DECLARATION !!!!!!!!!!!!!!!!!!!!!!!!!!

  use time_var_mod
  use locist_var_mod,only:locist_scratch

  implicit none

  type(orbital_path)::lambda_path
  type(locist_scratch)::loc_scr
  type(threefourmod2vars)::mod2vars
  type(blockedLockVectorType) :: civec, sigmavec 

  integer::chain                  !// LOOP CHAIN
  integer::member_loop            !// LOOP WITHIN A CHAIN
  integer::internal_singles       !// NUMBER OF SINGLES IN INTERNAL PATH OF PATH
  integer::start_elec             !// OCCUPATION WHERE INTERNAL CSF MEETS UP WITH EXTERNAL SPACE
  integer::a                     !// USED TO INDEX EXTERNAL ORBITALS
  integer::s1,s2,s3,s4            !// NUMBERS OF SINGLES IN DIFFERENT LOOP SEGMENTS
  integer:: i 
  integer::nm2_weight,nm1_weight,v_weight         !// NM2 STANDS FOR N-2,NM1 = N-1,
  integer::nm2_singles,nm1_singles,v_singles      !// AND V = VALENCE
  integer::nm2_dim,nm1_dim,v_dim
  logical::doublet_valence                        !// FLAG = TRUE OF WE MUST DO
                                                  !// N-1/VALENCE INTERACTIONS
  logical:: swap_singles                          !// SET TO TRUE OF WE MUST SWAP THE
                                                  !// NUMBERS OF SINGLES
  
  integer:: Px_index,Py_index                     !// INDEXING FOR INTEGRALS  
  integer::v_address                              !// ADDRESS FOR VALENCE STATES
  integer::a_address                              !// ADDRESS FOR DOUBLET STATES
  integer::aa_address,ab_address                  !// ADDRESS FOR N-2 STATES
  integer:: v_start,v_end
  integer:: a_start,a_end
  integer:: aa_start,aa_end
  integer:: ab_start,ab_end
  integer:: mode_1                                !// SYMMETRIC OR ANTISYMMETRIC SCEPPER
  integer::v_spin,a_spin,ab_spin

  integer::length                               
  integer::lam_length,lam_lengthC2                               
  integer::mu_length                               
  integer::int_index,index_xy                     !// INDICES FOR INTEGRALS AND COUPLING COEFF'S
  
  real(real8)::cc                                 !// COUPLING COEFFICIENT
  real(real8),parameter::sqrt2=real(sqrt(real(2.0,real8)),real8),zero=real(0.0,real8),two=real(2.0,real8)
  real(real8),dimension(:),allocatable::aijk_vec

  integer::a1,ij_1,ij_2
!////// EXTRA DECLARATIONS

  integer::common_virt_length,i_dum,j_dum,k_dum  
  integer,dimension(:),allocatable::common_virt,virt_lam_long,virt_lam_pos,virt_mu_long,virt_mu_pos,&
                                   common_virt_lam_pos,common_virt_mu_pos
                                   
  real(real8),external::ddot
  integer::status

  allocate(aijk_vec(num_external),common_virt(num_orbitals),virt_lam_long(num_orbitals),virt_lam_pos(num_orbitals), &
           virt_mu_long(num_orbitals),virt_mu_pos(num_orbitals),common_virt_lam_pos(num_orbitals), &
           common_virt_mu_pos(num_orbitals),stat=status)
  call allocatecheck(status,"threeInternSegComplVecLmoRes")

! START AUTOGENERATED INITIALIZATION 
px_index = 0
ab_address = 0
v_address = 0
v_spin = 0
member_loop = 0
lam_lengthc2 = 0
aa_address = 0
i = 0
a = 0
i_dum = 0
s3 = 0
s2 = 0
s1 = 0
s4 = 0
nm1_singles = 0
nm1_weight = 0
mu_length = 0
v_start = 0
common_virt_length = 0
a_start = 0
common_virt_lam_pos = 0
ab_spin = 0
common_virt = 0
aa_end = 0
a_end = 0
mode_1 = 0
a_address = 0
ab_end = 0
internal_singles = 0
v_dim = 0
v_end = 0
swap_singles = .false.
nm1_dim = 0
start_elec = 0
a1 = 0
virt_mu_long = 0
k_dum = 0
v_weight = 0
virt_lam_long = 0
virt_lam_pos = 0
virt_mu_pos = 0
lam_length = 0
index_xy = 0
cc = 0.0
j_dum = 0
aa_start = 0
doublet_valence = .false.
chain = 0
common_virt_mu_pos = 0
nm2_dim = 0
ab_start = 0
int_index = 0
nm2_weight = 0
a_spin = 0
nm2_singles = 0
py_index = 0
! END AUTOGENERATED INITIALIZATION 
       

  length = num_external !CHANGE THIS LATER .. DEPENDING ON PAOS.
 
  !!!!!!!!!!!!!!!!!!!!!!! VARIABLE INITIALIZATION !!!!!!!!!!!!!!!!!!!!!!!!!!!!
  v_singles = 0
  aijk_vec = 0 
  !!!!!!!!!!!!!!!!!!!!!!!!!!! START OF ROUTINE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  ij_2 = 0         ! added so that in case of I/O failure ij_2 is not uninitialized  
  mod2vars%ijaj_rec = mod2vars%ijaj_rec + 1 
  read(unit=405,rec=mod2vars%ijaj_rec,iostat=i_dum) ij_2,chain,member_loop,start_elec,internal_singles, &
                                           lambda_path%weight,lambda_path%rt_loop_weight,s1,s2,s3,s4
  if (ij_1 .ne. ij_2) then
  mod2vars%ijaj_rec = mod2vars%ijaj_rec -1
  ij_1 = ij_2
  return
  endif

  if (i_dum .ne. 0) then
  ij_1 = 0
  return
  endif

  !// REORGANIZE OUR DATA IN PREPARATION FOR THE VECTORIZED 
  !// MULTIPLICATIONS
  call aijk_logic_hider(chain,member_loop,start_elec,internal_singles, & 
                        lambda_path%weight+1,lambda_path%rt_loop_weight+1, & 
                        nm2_singles,nm1_singles,v_singles,& 
                        nm2_weight,nm1_weight,v_weight, & 
                        Px_index,Py_index,doublet_valence, & 
                        swap_singles)

  !// GET DIMENSIONS    

  if ( .not. doublet_valence) then 
  nm2_dim = fsn(nm2_singles)
  nm1_dim = fsn(nm1_singles)
  else
  nm1_dim = fsn(nm1_singles)
  v_dim = fsn(v_singles)
  endif

  if (.not.doublet_valence) then

      !// IF THE NUMBER OF DIMENSIONS IS ALLOWED, COMPUTE
      !// COUPLING COEFFICIENTS AND DO MULTIPLICATIONS
      dim1: if (nm2_dim /= 0.and. nm1_dim /=0) then
              
          call coupling_coeff_driver_3_vec(s1,s2,s3,&
                                                 chain, member_loop,&
                                                 nm2_singles,nm1_singles,&
                                                 mod2vars%Px,mod2vars%Py,&
                                                 swap_singles)
  
          !// LOCATE THE STARTING SECTION OF THE CI VECTOR.  REMEMBER THE CI
          !// VECTOR SHOULD BE FORMATTED BY SPIN FUNCTIONS AT THIS POINT.
          !// A_ADDRESS  => INDEXES CONFIGURATIONS HAVING ONE VIRTUAL SINGLY OCCUPIED
          !// AB_ADDRESS => CONFIGURATIONS HAVING TWO DIFFERENT
          !//               VIRTUALS SINGLY OCCUPIED
          !// AA_ADDRESS => INDEXES CONFIGURATIONS HAVING ONE VIRTUAL DOUBLY OCCUPIED
          
          a_address  = internal_index_vector1(nm1_weight)
          ab_address = internal_index_vector2(nm2_weight)
          aa_address = internal_index_vector3(nm2_weight)
          
          if ((ab_address > 0 .or. aa_address > 0) .and. a_address > 0) then              

              lam_length     = num_allowed_virtuals(nm2_weight,"D") 
              lam_lengthC2 = (lam_length*(lam_length-1)/2)
              call get_virtuals(nm2_weight,"D",loc_scr%virt_lam_allow)

              mu_length     = num_allowed_virtuals(nm1_weight,"S")  
              call get_virtuals(nm1_weight,"S",loc_scr%virt_mu_allow)

             if (lam_length .eq. 0) then
             write(6,*) "Something wrong here"
             stop
             endif

              common_virt = 0
              virt_lam_long = 0
              virt_lam_pos = 0
              virt_mu_long = 0
              virt_mu_pos = 0

             do i = 1, lam_length
                virt_lam_long(loc_scr%virt_lam_allow(i)) = loc_scr%virt_lam_allow(i)
                virt_lam_pos(loc_scr%virt_lam_allow(i)) = i
             enddo

             do i = 1, mu_length
                virt_mu_long(loc_scr%virt_mu_allow(i)) = loc_scr%virt_mu_allow(i)
                virt_mu_pos(loc_scr%virt_mu_allow(i)) = i
             enddo


            common_virt_length = 0
            common_virt_lam_pos = 0
            common_virt_mu_pos = 0
            do i = 1, lam_length
               if ( virt_lam_long(loc_scr%virt_lam_allow(i)) == virt_mu_long(loc_scr%virt_lam_allow(i)) ) then
                  common_virt_length = common_virt_length + 1
                  common_virt(common_virt_length) = loc_scr%virt_lam_allow(i)
                  common_virt_lam_pos(common_virt_length) = virt_lam_pos(loc_scr%virt_lam_allow(i))
                  common_virt_mu_pos(common_virt_length) = virt_mu_pos(loc_scr%virt_lam_allow(i))
               endif
            enddo

            if (common_virt_length .eq. 0 ) return

!////////////////////////////////////////////////////////////////////////////////////////////////////
               do ab_spin =1,nm2_dim
                  
                   mode_1 = -1
                   if (ab_spin <=  fsn(nm2_singles-2)) mode_1 = 1

                   ab_start = ab_address + (ab_spin-1)*lam_lengthC2
                   aa_start = aa_address + (ab_spin-1)*(lam_length)

                   if (mode_1 .eq. 1) then
                       call scepper_diag_p1(mod2vars%scep_ci_1,civec%v,ab_start,&
                                     lam_length,civec%v,aa_start)
                   elseif (mode_1 .eq. -1) then
                       call scepper_diag_m1(mod2vars%scep_ci_1,civec%v,ab_start,&
                                     lam_length)
                   endif

                   do a_spin=1,nm1_dim
                      
                      a_start = a_address + (a_spin-1)*(mu_length)
                      a_end = a_start + mu_length - 1

                      do index_xy = 1,2 
                          
                          if (index_xy == 1) then 
                              cc = mod2vars%Px(ab_spin,a_spin)
                              int_index = Px_index
                          elseif (index_xy == 2) then 
                              cc = mod2vars%Py(ab_spin,a_spin)
                              int_index = Py_index
                          endif
                          
                          if (abs(cc) > integral_threshold) then
             
                             do a=1,lam_length
                                  a1 = loc_scr%virt_lam_allow(a)
                                  aijk_vec(a) = integral_buffer(int_index,a1-num_internal)
                             enddo
 

                                  loc_scr%sigma_nm1_mu(1:mu_length) = zero 
                                  do j_dum = 1,lam_length
                                     do k_dum = 1, common_virt_length
                                        loc_scr%sigma_nm1_mu( common_virt_mu_pos(k_dum) ) = loc_scr%sigma_nm1_mu(common_virt_mu_pos(k_dum)) + &
                                                                                    cc*aijk_vec( j_dum )*&
                                                                                    mod2vars%scep_ci_1(common_virt_lam_pos(k_dum),j_dum)
                                     enddo
                                  enddo

                               sigmavec%v(a_start:a_end) = sigmavec%v(a_start:a_end) + loc_scr%sigma_nm1_mu(1:mu_length)



                                loc_scr%sigma_nm2_lambda(1:lam_length,1:lam_length) = zero

                                do i_dum = 1,common_virt_length
                                   do j_dum = 1,lam_length
                                      loc_scr%sigma_nm2_lambda(common_virt_lam_pos(i_dum),j_dum) = &
                                      cc*aijk_vec( j_dum )*civec%v(a_start+common_virt_mu_pos(i_dum)-1)
                                   enddo
                                enddo

                                if (mode_1 .eq. 1) then
                                    call unscepper_diag_p1(loc_scr%sigma_nm2_lambda,sigmavec%v,ab_start,lam_length,&
                                                sigmavec%v,aa_start)
                                elseif (mode_1 .eq. -1) then
                                    call unscepper_diag_m12(loc_scr%sigma_nm2_lambda,sigmavec%v,ab_start,lam_length)
                                endif

                              
                          endif
                          
                      enddo
                      
                  enddo
               enddo
          endif
          
      endif dim1
      
  elseif (doublet_valence) then 
      !// IF THE NUMBER OF DIMENSIONS IS ALLOWED, COMPUTE
      !// COUPLING COEFFICIENTS AND DO MULTIPLICATIONS
      
      call coupling_coeff_driver_3_vec(s1,s2,s3,&
           chain, member_loop,&
           nm1_singles,v_singles,&
           mod2vars%Px,mod2vars%Py,&
           swap_singles)
     
      nm1_dim = fsn(nm1_singles)
      v_dim   = fsn(v_singles) 
      
      dim2: if (nm1_dim /= 0.and. v_dim /=0) then
          
          !// LOCATE THE STARTING SECTION OF THE CI VECTOR.  REMEMBER THE CI
          !// VECTOR SHOULD BE FORMATTED BY SPIN FUNCTIONS AT THIS POINT.
          !// V_ADDRESS  => INDEXES CONFIGURATIONS CORRESPONDING TO VALENCE STATES
          !// A_ADDRESS  => INDEXES CONFIGURATIONS HAVING ONE VIRTUAL SINGLY OCCUPIED
          
          v_address  = internal_index_vector0(v_weight)
          a_address  = internal_index_vector1(nm1_weight)
          
          if (a_address > 0 .and. v_address > 0) then 
              
              mu_length     = num_allowed_virtuals(nm1_weight,"S") 
              call get_virtuals(nm1_weight,"S",loc_scr%virt_mu_allow)
              
              do a_spin =1,nm1_dim
                  
                 a_start = a_address + (a_spin-1)*mu_length
                 a_end = a_start + mu_length - 1
                  
                  do v_spin=1,v_dim
                      
                      !// SET THE STARTING AND ENDING POSITIONS OF THE CI VECTOR
                      v_start  =  v_address + v_spin - 1
                      v_end    =  v_start   
                      
                      do index_xy = 1,2 
                          
                          if (index_xy == 1) then 
                              cc = mod2vars%Px(a_spin,v_spin)
                              int_index = Px_index
                          elseif (index_xy == 2) then 
                              cc = mod2vars%Py(a_spin,v_spin)
                              int_index = Py_index
                          endif
                          
                          if (abs(cc) > integral_threshold) then
                              
                              do a=1,mu_length
                                  a1 = loc_scr%virt_mu_allow(a)
                                  aijk_vec(a) = integral_buffer(int_index,a1-num_internal) 
                              enddo

                              !// NOW WE HAVE THE SIGMAVECTOR OVER PAO BASIS (N-1)
                              !WE NEED TO DO SOMETHING ABOUT INTEGRALS
                              sigmavec%v(a_start:a_end) = sigmavec%v(a_start:a_end) + cc*aijk_vec(1:mu_length)*civec%v(v_start)
                              
                              !// NOW WE HAVE THE SIGMAVECTOR OVER PAO BASIS (VALENCE)
                              !WE NEED TO DO SOMETHING ABOUT INTEGRALS
                              sigmavec%v(v_start) = sigmavec%v(v_start) + cc*ddot(mu_length,aijk_vec,1,civec%v(a_start),1)
                           
                              
                          endif
                          
                      enddo
                      
                  enddo
              enddo
              
          endif
          
      endif dim2
  endif
  
  deallocate(aijk_vec,common_virt,virt_lam_long,virt_lam_pos, &
           virt_mu_long,virt_mu_pos,common_virt_lam_pos, &
           common_virt_mu_pos,stat=status)
  call deallocatecheck(status,"threeInternSegComplVecLmoRes")

end subroutine threeInternSegComplVecLmoRes
!**********************************************************************************

!*****************************************************************
subroutine fouriseg4s_fully(civec, sigmavec, cho_data,lambda_path,scr)

  use cholesky_structs

  implicit none

  type(fourIntScr),dimension(:),intent(inout)::scr
  type(cholesky_data),intent(in)::cho_data
  type(orbital_path),intent(inout)::lambda_path
  type(blockedLockVectorType),intent(inout):: civec, sigmavec

  integer::chain                  !// LOOP CHAIN
  integer::member_loop            !// LOOP WITHIN A CHAIN
  integer::current_vertex         !// USED IN BUILDING MU PATH
  integer::step_type              !// KEEPS TRACK OF STEP IN MU PATH CONSTRUCTION
  integer::path_elecs             !// CUMULATIVE OCCUPATION IN MU PATH
  integer::top_level              !// LEVEL OF FIRST LOOP SEGMENT
  integer::mu_levels              !// LABELS LEVELS IN MU PATH
  integer::constraint_count       !// KEEP TRACK OF CONSTRAINTS IN BUILDING MU PATH
  integer::start_elec             !// OCCUPATION WHERE INTERNAL CSF MEETS UP WITH EXTERNAL SPACE
  integer::lam_step_1,lam_step_2,lam_step_3,lam_step_4     
                 
  logical::built_int
  logical::new_chain

  integer::i,j,k,l,i_orb,j_orb                     !// LOOP VARIABLES   
  integer::level_1,level_2,level_3,level_4

  real(real8):: ijkl,iljk,ikjl    !// INTEGRALS

  integer:: weight,rt_loop_weight
  
#ifdef TIGER_USE_OMP
  integer::threadID
#else
  integer,parameter::threadID = 1
#endif


  weight = sum(lambda_path%arc_weights(0:num_internal))
  start_elec = sum(lambda_path%occupations(0:num_internal))

    do i = 1,lambda_path%num_singles
    
       i_orb = lambda_path%singles(i)
       do j = i+1,lambda_path%num_singles
          j_orb = lambda_path%singles(j)

          if (ignorable_pair(i_orb,j_orb) ) cycle

          !HERE PARALLELIZATION since num_internal longer than num_singles for local
          !$omp parallel do &
          !$omp default(none) &
          !$omp shared(lambda_path,ignorable_pair,scr,num_internal,full_loops, &
          !$omp y1,y2,start_elec,cho_data,weight,civec,sigmavec,i_orb,j_orb) &
          !$omp private(lam_step_1,lam_step_2,lam_step_3, &
          !$omp lam_step_4,top_level,constraint_count,rt_loop_weight, &
          !$omp chain,ijkl,iljk,ikjl,new_chain,built_int,path_elecs,current_vertex, &
          !$omp threadID,level_1,level_2,level_3,level_4,step_type)
          do k = 1, num_internal
          
#ifdef TIGER_USE_OMP
             threadID = OMP_get_thread_num() + 1
#endif

             if (ignorable_pair(i_orb,k) ) cycle
             if (ignorable_pair(j_orb,k) ) cycle
  
             if (k == i_orb .or. k == j_orb) cycle
             if (lambda_path%occupations(k) == 1 .and. k .lt. j_orb) cycle
             
     
             do l = k+1,num_internal

              if (ignorable_pair(i_orb,l) ) cycle
              if (ignorable_pair(j_orb,l) ) cycle
              if (ignorable_pair(k,l) ) cycle

              if ( l == i_orb .or. l == j_orb) cycle
              if (lambda_path%occupations(l) == 1 .and. l .lt. j_orb) cycle


              level_4 = max(l,j_orb)
              level_1 = min(i_orb,k)

              if (level_1 == i_orb) then
                 level_2 = min(j_orb,k)
              else
                 level_2 = min(i_orb,l)
              endif

              if (level_4 == l) then
                 level_3 = max(j_orb,k)
              else
                 level_3 = max(i_orb,l)
              endif


              scr(threadID)%constraints(2,1)=level_1
              scr(threadID)%constraints(2,2)=level_2
              scr(threadID)%constraints(2,3)=level_3
              scr(threadID)%constraints(2,4)=level_4
              top_level = level_1


              lam_step_1 = lambda_path%occupations(level_1)
              lam_step_2 = lambda_path%occupations(level_2)
              lam_step_3 = lambda_path%occupations(level_3)
              lam_step_4 = lambda_path%occupations(level_4)

              built_int = .false. 

              do chain = 1,8

                 new_chain = .true.

                 memloop: do member_loop = 1,6

                       if (lam_step_1 .ne. full_loops(chain,member_loop,1,1) ) cycle  
                       if (lam_step_2 .ne. full_loops(chain,member_loop,2,1) ) cycle  
                       if (lam_step_3 .ne. full_loops(chain,member_loop,3,1) ) cycle  
                       if (lam_step_4 .ne. full_loops(chain,member_loop,4,1) ) cycle  
                       rt_loop_weight = 0                               

!// SET CONSTRAINTS FOR MU PATHS
                       scr(threadID)%constraints(3,1:4) = &
                       full_loops(chain,member_loop,1:4,2)

                       constraint_count = 1
                       path_elecs = sum(lambda_path%occupations(0:top_level-1))

                       do mu_levels = top_level, num_internal

                          current_vertex = vertex(mu_levels-1,path_elecs)

!// CHECK TO SEE IF THIS IS A CONSTRAINED LEVEL AND GET THE STEP_TYPE
                          if ((mu_levels)==scr(threadID)%constraints(2,constraint_count)) then
                             step_type = scr(threadID)%constraints(3,constraint_count)
                             constraint_count = constraint_count + 1
                          else
                             step_type = lambda_path%occupations(mu_levels)  
                          endif

!// TRY TO ADD THE STEP
                          if (step_type == 2) then

                          if (add2(mu_levels-1,path_elecs)) then
                             path_elecs = path_elecs + 2
                             rt_loop_weight = rt_loop_weight +&
                                                    abs(y2(current_vertex))
                          else
                             cycle memloop
                          endif

                          elseif(step_type == 1) then

                          if (add1(mu_levels-1,path_elecs)) then
                          path_elecs = path_elecs + 1
                          rt_loop_weight = rt_loop_weight +&
                                                    abs(y1(current_vertex))
                          else
                             cycle memloop
                          endif

                          elseif(step_type == 0) then
                            if (.not.add0(mu_levels-1,path_elecs)) cycle memloop
                          endif

                       enddo
!// FOR THE RT_LOOP_WEIGHT ADD IN THE WEIGHTS OF THE RELEVANT PARTS
!// OF THE HEAD AND TAIL PATHS.  THIS WILL END UP BEING THE MU PATH WEIGHT
                       rt_loop_weight = rt_loop_weight +&
                                                 sum(lambda_path%arc_weights(0:top_level-1))

                       if (skip_these_internals(weight,rt_loop_weight,&
                          start_elec, path_elecs)) cycle

                    if ( .not. built_int) then
                       
                          ijkl = makeOneIntegralPrescreened(level_1,level_2,level_3,level_4,cho_data,threadID)
                          ikjl = makeOneIntegralPrescreened(level_1,level_3,level_4,level_2,cho_data,threadID)
                          iljk = makeOneIntegralPrescreened(level_1,level_4,level_2,level_3,cho_data,threadID)

                          built_int = .true.

                    endif

                    if (new_chain) then
                       call sort_integrals(scr(threadID)%integrals,chain,ijkl,iljk,ikjl)
                       new_chain = .false.
                    endif
                    
                    call four_i_seg_loopdrv_sigma(civec, sigmavec, lambda_path,scr(threadID)%virt_lam_allow,scr(threadID)%virt_mu_allow, & 
                         scr(threadID)%Px,scr(threadID)%Py,chain,member_loop,scr(threadID)%integrals,scr(threadID)%constraints,weight, &
                         rt_loop_weight)

                 enddo memloop !  member_loops

              enddo !  chains


           enddo  ! enddo l loop
        enddo     ! enddo k loop
        !$omp end parallel do
      enddo       ! enddo j loop
   enddo          ! enddo i loop
   
end subroutine fouriseg4s_fully


!*****************************************************************
subroutine fouriseg4s(civec, sigmavec, cho_data,lambda_path,scr,iter_count,nextIJKLRecord,nodeCounter)

  use cholesky_structs
  use locist_var_mod,only:locist_scratch

  implicit none

  type(fourIntScr),dimension(:),intent(inout)::scr
  type(cholesky_data),intent(in)::cho_data
  type(orbital_path),intent(inout)::lambda_path
  type(blockedLockVectorType),intent(inout):: civec, sigmavec 
  integer,intent(in)::iter_count
  integer,intent(inout)::nextIJKLRecord,nodeCounter

  integer::chain                  !// LOOP CHAIN
  integer::member_loop            !// LOOP WITHIN A CHAIN
  integer::current_vertex         !// USED IN BUILDING MU PATH
  integer::step_type              !// KEEPS TRACK OF STEP IN MU PATH CONSTRUCTION
  integer::path_elecs             !// CUMULATIVE OCCUPATION IN MU PATH
  integer::top_level              !// LEVEL OF FIRST LOOP SEGMENT
  integer::mu_levels              !// LABELS LEVELS IN MU PATH
  integer::constraint_count       !// KEEP TRACK OF CONSTRAINTS IN BUILDING MU PATH
  integer::start_elec             !// OCCUPATION WHERE INTERNAL CSF MEETS UP WITH EXTERNAL SPACE
  integer::lam_step_1,lam_step_2,lam_step_3,lam_step_4     
                 
  logical::built_int
  logical::new_chain

  integer::i,j,k,l,i_orb,j_orb                     !// LOOP VARIABLES   
  integer::level_1,level_2,level_3,level_4

  real(real8):: ijkl,iljk,ikjl    !// INTEGRALS


  integer::weight,rt_loop_weight

#ifdef TIGER_USE_SLOW_OMP
  integer::threadID
  threadID = OMP_get_thread_num()+1
#else
  integer,parameter::threadID = 1
#endif

#ifndef TIGER_USE_SLOW_OMP
  ! silence warning
  if(nodeCounter /= nodeCounter) then
     write(*,*) "ERROR: NaN in nodeCounter!"
     flush(6)
     stop
  endif
#endif

  weight = sum(lambda_path%arc_weights(0:num_internal))
  start_elec = sum(lambda_path%occupations(0:num_internal))
  
  if(iter_count .eq. 1) then
  
    do i = 1,lambda_path%num_singles
       
       ! we parallize here, so this is interesting... :-)
       ! we need to find a way to communicate the last add to the array from here...
#ifdef TIGER_USE_SLOW_OMP
       nodeCounter = append(omp_offsets_four_icount,nextIJKLRecord)
#endif       
       
       i_orb = lambda_path%singles(i)
       do j = i+1,lambda_path%num_singles
          j_orb = lambda_path%singles(j)

          if (ignorable_pair(i_orb,j_orb) ) cycle

          do k = 1, num_internal     

             if (ignorable_pair(i_orb,k) ) cycle
             if (ignorable_pair(j_orb,k) ) cycle
  
             if (k == i_orb .or. k == j_orb) cycle
             if (lambda_path%occupations(k) == 1 .and. k .lt. j_orb) cycle
             
     
             do l = k+1,num_internal

              if (ignorable_pair(i_orb,l) ) cycle
              if (ignorable_pair(j_orb,l) ) cycle
              if (ignorable_pair(k,l) ) cycle

              if ( l == i_orb .or. l == j_orb) cycle
              if (lambda_path%occupations(l) == 1 .and. l .lt. j_orb) cycle


              level_4 = max(l,j_orb)
              level_1 = min(i_orb,k)

              if (level_1 == i_orb) then
                 level_2 = min(j_orb,k)
              else
                 level_2 = min(i_orb,l)
              endif

              if (level_4 == l) then
                 level_3 = max(j_orb,k)
              else
                 level_3 = max(i_orb,l)
              endif


              scr(1)%constraints(2,1)=level_1
              scr(1)%constraints(2,2)=level_2
              scr(1)%constraints(2,3)=level_3
              scr(1)%constraints(2,4)=level_4
              top_level = level_1


              lam_step_1 = lambda_path%occupations(level_1)
              lam_step_2 = lambda_path%occupations(level_2)
              lam_step_3 = lambda_path%occupations(level_3)
              lam_step_4 = lambda_path%occupations(level_4)

              built_int = .false. 

              do chain = 1,8

                 new_chain = .true.

                 memloop: do member_loop = 1,6

                       if (lam_step_1 .ne. full_loops(chain,member_loop,1,1) ) cycle  
                       if (lam_step_2 .ne. full_loops(chain,member_loop,2,1) ) cycle  
                       if (lam_step_3 .ne. full_loops(chain,member_loop,3,1) ) cycle  
                       if (lam_step_4 .ne. full_loops(chain,member_loop,4,1) ) cycle  
                       rt_loop_weight = 0                               

!// SET CONSTRAINTS FOR MU PATHS
                       scr(1)%constraints(3,1:4) = &
                       full_loops(chain,member_loop,1:4,2)

                       constraint_count = 1
                       path_elecs = sum(lambda_path%occupations(0:top_level-1))

                       do mu_levels = top_level, num_internal

                          current_vertex = vertex(mu_levels-1,path_elecs)

!// CHECK TO SEE IF THIS IS A CONSTRAINED LEVEL AND GET THE STEP_TYPE
                          if ((mu_levels)==scr(1)%constraints(2,constraint_count)) then
                             step_type = scr(1)%constraints(3,constraint_count)
                             constraint_count = constraint_count + 1
                          else
                             step_type = lambda_path%occupations(mu_levels)  
                          endif

!// TRY TO ADD THE STEP
                          if (step_type == 2) then

                          if (add2(mu_levels-1,path_elecs)) then
                             path_elecs = path_elecs + 2
                             rt_loop_weight = rt_loop_weight +&
                                                    abs(y2(current_vertex))
                          else
                             cycle memloop
                          endif

                          elseif(step_type == 1) then

                          if (add1(mu_levels-1,path_elecs)) then
                          path_elecs = path_elecs + 1
                          rt_loop_weight = rt_loop_weight +&
                                                    abs(y1(current_vertex))
                          else
                             cycle memloop
                          endif

                          elseif(step_type == 0) then
                            if (.not.add0(mu_levels-1,path_elecs)) cycle memloop
                          endif

                       enddo
!// FOR THE RT_LOOP_WEIGHT ADD IN THE WEIGHTS OF THE RELEVANT PARTS
!// OF THE HEAD AND TAIL PATHS.  THIS WILL END UP BEING THE MU PATH WEIGHT
                       rt_loop_weight = rt_loop_weight +&
                                                 sum(lambda_path%arc_weights(0:top_level-1))

                       if (skip_these_internals(weight,rt_loop_weight,&
                          start_elec, path_elecs)) cycle

                       if ( .not. built_int) then
                       
                          ijkl = makeOneIntegral(level_1,level_2,level_3,level_4,cho_data,threadID)
                          ikjl = makeOneIntegral(level_1,level_3,level_4,level_2,cho_data,threadID)
                          iljk = makeOneIntegral(level_1,level_4,level_2,level_3,cho_data,threadID)
                       
                          ! write stuff out
                          call for_double_buf_writeElement(cd_ijkl_no,nextIJKLRecord,ijkl,threadID)
                          nextIJKLRecord = nextIJKLRecord + 1
                          call for_double_buf_writeElement(cd_ijkl_no,nextIJKLRecord,ikjl,threadID)
                          nextIJKLRecord = nextIJKLRecord + 1
                          call for_double_buf_writeElement(cd_ijkl_no,nextIJKLRecord,iljk,threadID)
                          nextIJKLRecord = nextIJKLRecord + 1
                                              
                          built_int = .true.

                    endif ! endif built int

                    if (new_chain) then
                       call sort_integrals(scr(1)%integrals,chain,ijkl,iljk,ikjl)
                       new_chain = .false.
                    endif

                    call four_i_seg_loopdrv_sigma(civec, sigmavec, lambda_path,scr(1)%virt_lam_allow,scr(1)%virt_mu_allow,scr(1)%Px,scr(1)%Py,chain, & 
                                  member_loop,scr(1)%integrals,scr(1)%constraints,weight,rt_loop_weight)

                 enddo memloop !  member_loops

              enddo !  chains


           enddo  ! enddo l loop
        enddo     ! enddo k loop
      enddo       ! enddo j loop
   enddo          ! enddo i loop
         
   else ! iteration > 1
   
#ifdef TIGER_USE_SLOW_OMP
      !$omp parallel do &
      !$omp default(none) &
      !$omp shared(lambda_path,ignorable_pair,num_internal,scr,sigmavec,civec,nodeCounter,omp_offsets_four_icount, &
      !$omp full_loops,weight,y1,y2,start_elec) &
      !$omp private(threadID,nextIJKLRecord,i_orb,j_orb,level_1,level_2,level_3,level_4,built_int,new_chain,top_level, &
      !$omp lam_step_1,lam_step_2,lam_step_3,lam_step_4,rt_loop_weight,constraint_count,path_elecs,step_type,ijkl,ikjl, &
      !$omp iljk,current_vertex)
#endif
      do i = 1,lambda_path%num_singles
      
#ifdef TIGER_USE_SLOW_OMP
       threadID = OMP_get_thread_num()+1
       nextIJKLRecord = getElement(omp_offsets_four_icount,nodeCounter+i)
#endif
      
       i_orb = lambda_path%singles(i)
       do j = i+1,lambda_path%num_singles
          j_orb = lambda_path%singles(j)

          if (ignorable_pair(i_orb,j_orb)) cycle

          do k = 1, num_internal     

             if (ignorable_pair(i_orb,k) ) cycle
             if (ignorable_pair(j_orb,k) ) cycle
  
             if (k == i_orb .or. k == j_orb) cycle
             if (lambda_path%occupations(k) == 1 .and. k .lt. j_orb) cycle
             
     
             do l = k+1,num_internal

              if (ignorable_pair(i_orb,l) ) cycle
              if (ignorable_pair(j_orb,l) ) cycle
              if (ignorable_pair(k,l)) cycle

              if ( l == i_orb .or. l == j_orb) cycle
              if (lambda_path%occupations(l) == 1 .and. l .lt. j_orb) cycle


              level_4 = max(l,j_orb)
              level_1 = min(i_orb,k)

              if (level_1 == i_orb) then
                 level_2 = min(j_orb,k)
              else
                 level_2 = min(i_orb,l)
              endif

              if (level_4 == l) then
                 level_3 = max(j_orb,k)
              else
                 level_3 = max(i_orb,l)
              endif


              scr(threadID)%constraints(2,1)=level_1
              scr(threadID)%constraints(2,2)=level_2
              scr(threadID)%constraints(2,3)=level_3
              scr(threadID)%constraints(2,4)=level_4
              top_level = level_1


              lam_step_1 = lambda_path%occupations(level_1)
              lam_step_2 = lambda_path%occupations(level_2)
              lam_step_3 = lambda_path%occupations(level_3)
              lam_step_4 = lambda_path%occupations(level_4)

              built_int = .false. 

              do chain = 1,8

                 new_chain = .true.

                 memloop2: do member_loop = 1,6

                       if (lam_step_1 .ne. full_loops(chain,member_loop,1,1) ) cycle  
                       if (lam_step_2 .ne. full_loops(chain,member_loop,2,1) ) cycle  
                       if (lam_step_3 .ne. full_loops(chain,member_loop,3,1) ) cycle  
                       if (lam_step_4 .ne. full_loops(chain,member_loop,4,1) ) cycle  
                       rt_loop_weight = 0                               

!// SET CONSTRAINTS FOR MU PATHS
                       scr(threadID)%constraints(3,1:4) = &
                       full_loops(chain,member_loop,1:4,2)

                       constraint_count = 1
                       path_elecs = sum(lambda_path%occupations(0:top_level-1))

                       do mu_levels = top_level, num_internal

                          current_vertex = vertex(mu_levels-1,path_elecs)

!// CHECK TO SEE IF THIS IS A CONSTRAINED LEVEL AND GET THE STEP_TYPE
                          if ((mu_levels)== scr(threadID)%constraints(2,constraint_count)) then
                             step_type = scr(threadID)%constraints(3,constraint_count)
                             constraint_count = constraint_count + 1
                          else
                             step_type = lambda_path%occupations(mu_levels)  
                          endif

!// TRY TO ADD THE STEP
                          if (step_type == 2) then

                          if (add2(mu_levels-1,path_elecs)) then
                             path_elecs = path_elecs + 2
                             rt_loop_weight = rt_loop_weight +&
                                                    abs(y2(current_vertex))
                          else
                             cycle memloop2
                          endif

                          elseif(step_type == 1) then

                          if (add1(mu_levels-1,path_elecs)) then
                          path_elecs = path_elecs + 1
                          rt_loop_weight = rt_loop_weight +&
                                                    abs(y1(current_vertex))
                          else
                             cycle memloop2
                          endif

                          elseif(step_type == 0) then
                            if (.not.add0(mu_levels-1,path_elecs)) cycle memloop2
                          endif

                       enddo
!// FOR THE RT_LOOP_WEIGHT ADD IN THE WEIGHTS OF THE RELEVANT PARTS
!// OF THE HEAD AND TAIL PATHS.  THIS WILL END UP BEING THE MU PATH WEIGHT
                       rt_loop_weight = rt_loop_weight +&
                                                 sum(lambda_path%arc_weights(0:top_level-1))

                       if (skip_these_internals(weight,rt_loop_weight,&
                          start_elec, path_elecs)) cycle

                       if ( .not. built_int) then
                       
                       ! write stuff out
                       call for_double_buf_readElement(cd_ijkl_no,nextIJKLRecord,ijkl,threadID)
                       nextIJKLRecord = nextIJKLRecord + 1
                       call for_double_buf_readElement(cd_ijkl_no,nextIJKLRecord,ikjl,threadID)
                       nextIJKLRecord = nextIJKLRecord + 1
                       call for_double_buf_readElement(cd_ijkl_no,nextIJKLRecord,iljk,threadID)
                       nextIJKLRecord = nextIJKLRecord + 1

                       built_int = .true.

                    endif ! endif built int

                    if (new_chain) then
                       call sort_integrals(scr(threadID)%integrals,chain,ijkl,iljk,ikjl)
                       new_chain = .false.
                    endif

                    call four_i_seg_loopdrv_sigma(civec, sigmavec, lambda_path,scr(threadID)%virt_lam_allow,scr(threadID)%virt_mu_allow,scr(threadID)%Px,scr(threadID)%Py,chain, &
                            member_loop,scr(threadID)%integrals,scr(threadID)%constraints,weight,rt_loop_weight)

                 enddo memloop2 !  member_loops

              enddo !  chains


           enddo  ! enddo l loop
        enddo     ! enddo k loop
      enddo       ! enddo j loop
   enddo          ! enddo i loop_type
#ifdef TIGER_USE_SLOW_OMP
   !$end parallel do
#endif
   
   endif

end subroutine fouriseg4s
!***************************************************************
subroutine four_i_seg_loopdrv_sigma(civec, sigmavec, lambda_path,virt_lam_allow,virt_mu_allow,Px,Py,chain,member_loop,integrals, &
                       constraints,weight,rt_loop_weight)

  !// IN THIS ROUTINE I BUILD UP THE COMPLEMENT TO THE FOUR SEGMENT LOOPS
  !// WHICH RESIDE ENTIRELY IN THE INTERNAL SPACE.  FROM HERE WE CALL THE
  !// ROUTINE TO DO THE MULTIPLICATION AS WELL.  BEFORE THIS IS DONE WE
  !// MUST CALL THE ROUTINE TO COMPUTE THE COUPLING COEFFICIENTS.  THESE
  !// ROUTINES WILL BE HACKS OF THE ROUTINE USED IN THE FOUR SEGMENT MODULE.  
  !!!!!!!!!!!!!!!!!!!!!!!!!!!  VARIABLE DECLARATION !!!!!!!!!!!!!!!!!!!!!!!!!!
  
  use locist_var_mod,only:locist_scratch

  implicit none
  
  real(real8),dimension(3),intent(in)::integrals
  integer,intent(in)::weight,rt_loop_weight
  type(orbital_path),intent(in)::lambda_path
  real(real8),dimension(:,:),intent(inout)::Px,Py
  integer,dimension(:),intent(inout)::virt_lam_allow,virt_mu_allow
  type(blockedLockVectorType),intent(inout):: civec, sigmavec 
  integer,dimension(:,:),intent(inout)::constraints
  
  integer,intent(in)::chain                  !// LOOP CHAIN
  integer,intent(in)::member_loop            !// LOOP WITHIN A CHAIN
  
  integer::ibar,jbar,kbar,lbar    !// ORBITAL POSITION INDICES
  integer::internal_singles       !// NUMBER OF SINGLES IN INTERNAL PATH OF PATH
  integer::lambda_singles         !// SINGLES IN LAMBDA AND MU PATH
  integer::mu_singles
  integer::lambda_dim,mu_dim      !// DIMENSIONS FOR LAMBDA AND MU CONFIGURATIONS
  integer::lambda_weight          !// WEIGHTS OF LAMBDA AND MU PATH
  integer::mu_weight             
  integer::lambda_address         !// ADDRESS OF MU AND LAMBDA PATHS
  integer::mu_address
  integer::start_elec             !// OCCUPATION WHERE INTERNAL CSF MEETS UP WITH EXTERNAL SPACE
  integer::lambda_start,mu_start  !// START ADDRESS FOR ALL CSFS HAVING THE INTERNAL CSFS

  integer::index_xy               !// LOOP VARIABLE 
  integer::i,j                    !// LOOP VARIABLES
  integer::mode_1,mode_2          !// MODES FOR SPIN COUPLINGS  
  
  real(real8)::Jx,Jy,intgrl      !// INTEGRALS 
  real(real8)::cc                !// COUPLING COEFFICIENTS
  real(real8)::tmp,tmp2

  logical::skip

  integer::mu_length1
  integer::mu_length2,mu_length2C2
  integer::lam_length1
  integer::lam_length2,lam_length2C2
!////// EXTRA DECLARATIONS

  integer::common_virt_length,lam_offset,mu_offset,i_dum,j_dum,i_x,j_x,i_y,j_y

  integer,dimension(:),allocatable::common_virt,virt_lam_long,virt_lam_pos,virt_mu_long,virt_mu_pos,&
                                   common_virt_lam_pos,common_virt_mu_pos
!  real(real8),dimension(:,:),allocatable::tmp_ten2
  real(real8)::cc_intgrl

  real(real8),parameter::zero= real(0.0,real8)
  integer::status
#ifdef TIGER_USE_OMP
  real(real8),dimension(:),allocatable::sigma_lam_slice,sigma_mu_slice
  integer::threadID
  threadID = OMP_get_thread_num() + 1
#else
  integer,parameter::threadID = 1
#endif
  
  !TODO these should be moved into scratch perhaps?
  allocate(common_virt(num_orbitals),virt_lam_long(num_orbitals),virt_lam_pos(num_orbitals), &
           virt_mu_long(num_orbitals),virt_mu_pos(num_orbitals),common_virt_lam_pos(num_orbitals), &
           common_virt_mu_pos(num_orbitals),stat=status)
  call allocatecheck(status,"four_i_seg_loopdrv_sigma")
  
!  real(real8),dimension(:,:),allocatable:,sigma_mu_slice
    
! START AUTOGENERATED INITIALIZATION 
j = 0
i = 0
lam_length2c2 = 0
lambda_dim = 0
j_y = 0
j_x = 0
mu_singles = 0
jy = 0.0
jx = 0.0
lam_offset = 0
lbar = 0
j_dum = 0
jbar = 0
lambda_weight = 0
mu_length2c2 = 0
lambda_singles = 0
mu_weight = 0
mu_offset = 0
mu_start = 0
index_xy = 0
i_x = 0
i_y = 0
mu_length1 = 0
mu_length2 = 0
intgrl = 0.0
kbar = 0
ibar = 0
lam_length2 = 0
lam_length1 = 0
mode_2 = 0
mode_1 = 0
i_dum = 0
mu_dim = 0
common_virt_length = 0
lambda_address = 0
cc_intgrl = 0.0
cc = 0.0
! END AUTOGENERATED INITIALIZATION 
 
  !!!!!!!!!!!!!!!!!!!!!!! VARIABLE INITIALIZATION !!!!!!!!!!!!!!!!!!!!!!!!!!!!

  
  start_elec = sum(lambda_path%occupations(0:num_internal))
  internal_singles = lambda_path%num_singles

  !!!!!!!!!!!!!!!!!!!!!!!!!!! START OF ROUTINE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !//
  !// GET IBAR,JBAR,KBAR,LBAR
  !//
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!
    
  call get_4_orbital_indices(ibar,jbar,kbar,lbar,chain,constraints,lambda_path%occupations)
  
  !// THREE CASES HERE: ONE FOR THE D,S,AND V VERTICES
  if (start_elec == num_elec-2) then
     
      !!!!!!!!!!!!!!!!!!!!!!!!!!!
      !// 
      !//  TWO VIRTUALS SINGLY OCCUPIED
      !// 
      !!!!!!!!!!!!!!!!!!!!!!!!!!!
      
      !// GET DIMENSIONS
      if (chain <= 3) then
          lambda_singles = internal_singles+2
          mu_singles = lambda_singles
      elseif (chain == 4) then
          lambda_singles = internal_singles+2
          mu_singles = lambda_singles-4
      else
          lambda_singles= internal_singles+2
          mu_singles = lambda_singles-2    
      endif
      
      !// WE HAVE NOW THE NUMBER OF SPIN FUNCTIONS FOR THE LAMBDA_PATH AND MU_PATH 
      
      lambda_dim = fsn(lambda_singles)
      mu_dim = fsn(mu_singles)
      
      if (lambda_dim /= 0.and.mu_dim /=0) then
      
      
          lambda_address = internal_index_vector2(weight + 1)
          mu_address     = internal_index_vector2(rt_loop_weight + 1)
        
          
          if (lambda_address > 0  .and. mu_address > 0) then
              
              !// GET THE COUPLING COEFFICIENTS AND THE CORRESPONDING INTEGRALS
              !// Jx and Jy are the integrals 
              !// Px and Py are the matrix of coupling coefficients 
             
              skip = .false.
              call coupling_coeff_and_integrals(chain, member_loop, &
                                                ibar, jbar, kbar, lbar,&
                                                lambda_singles, mu_singles,&
                                                integrals(1),&
                                                integrals(2),&
                                                integrals(3),&
                                                skip,&
                                                Jx,Jy,Px,Py)
                                                
              if(.not. skip) then
  
 
              !// NOW COMPUTE THE SIGMAVECTOR  

              lambda_weight = weight+1
              mu_weight     = rt_loop_weight+1
                  
              lam_length2  = num_allowed_virtuals(weight+1,"D") 
              lam_length2C2 = lam_length2*(lam_length2-1)/2
              mu_length2  = num_allowed_virtuals(rt_loop_weight+1,"D") 
              mu_length2C2 = mu_length2*(mu_length2-1)/2

              call get_virtuals(lambda_weight,"D",virt_lam_allow)
              call get_virtuals(mu_weight,"D",virt_mu_allow)



!/////////////////////////////////////////////////////////////// GET READY FOR SPARSE MATRIX MULTIPLICATION

              common_virt = 0
              virt_lam_long = 0
              virt_lam_pos = 0
              virt_mu_long = 0
              virt_mu_pos = 0

             do i = 1, lam_length2
                virt_lam_long(virt_lam_allow(i)) = virt_lam_allow(i)
                virt_lam_pos(virt_lam_allow(i)) = i
             enddo

             do i = 1, mu_length2
                virt_mu_long(virt_mu_allow(i)) = virt_mu_allow(i)
                virt_mu_pos(virt_mu_allow(i)) = i
             enddo

            common_virt_length = 0
            common_virt_lam_pos = 0
            common_virt_mu_pos = 0
            do i = 1, lam_length2
               if ( virt_lam_long(virt_lam_allow(i)) == virt_mu_long(virt_lam_allow(i)) ) then
                  common_virt_length = common_virt_length + 1
                  common_virt(common_virt_length) = virt_lam_allow(i)
                  common_virt_lam_pos(common_virt_length) = virt_lam_pos(virt_lam_allow(i))
                  common_virt_mu_pos(common_virt_length) = virt_mu_pos(virt_lam_allow(i))
                 ! write(*,*) "DEBUG: Common virt ",common_virt_lam_pos(common_virt_length),common_virt_mu_pos(common_virt_length)
               endif
            enddo

            if (common_virt_length .eq. 0 ) return

!////////////////////////////////////////////////////////////////////////////////////////////////////

#ifdef TIGER_USE_OMP
                  allocate(sigma_lam_slice(lam_length2C2),sigma_mu_slice(mu_length2C2),stat=status)
                  call allocatecheck(status,"sigma_lammu_slice")
#endif

                  do i = 1,lambda_dim 
                      
                      lambda_start = (i-1)*lam_length2C2+ lambda_address
#ifdef TIGER_USE_OMP
                      sigma_lam_slice = 0.d0
#endif
                      
                      do j = 1,mu_dim

                         mu_start = (j-1)*mu_length2C2 + mu_address
#ifdef TIGER_USE_OMP
                         sigma_mu_slice = 0.d0
#endif
                         
                         do index_xy = 1,2 
                              
                              if (index_xy == 1) then 
                                  cc = Px(i,j)
                                  intgrl = Jx 
                              elseif (index_xy == 2) then 
                                  cc = Py(i,j)
                                  intgrl = Jy 
                              endif
                              
                              if (abs(cc) > integral_threshold .and. abs(intgrl) > integral_threshold) then
                                 
!//////////////////////////////////////////////////// THE LMO VERSION

                                 cc_intgrl = cc*intgrl
                                 do i_dum = 1, common_virt_length
                                    i_x = common_virt_lam_pos(i_dum)
                                    i_y = common_virt_mu_pos(i_dum)
#ifdef TIGER_USE_OMP
                                    lam_offset = (i_x-1)*(i_x-2)/2
                                    mu_offset = (i_y-1)*(i_y-2)/2
#else
                                    lam_offset = (i_x-1)*(i_x-2)/2 + lambda_start -1 ! Include lambda_start-1 here
                                    mu_offset = (i_y-1)*(i_y-2)/2 + mu_start -1     ! Include mu_start-1 here
#endif
                                                                        
                                    do j_dum = 1,i_dum-1
                                       j_x = common_virt_lam_pos(j_dum)
                                       j_y = common_virt_mu_pos(j_dum)
                                       
#ifdef TIGER_USE_OMP
                                       tmp = cc_intgrl*civec%v(mu_offset + mu_start-1  +j_y)
                                       tmp2 = cc_intgrl*civec%v(lam_offset + lambda_start-1 +j_x)
                                       sigma_lam_slice(lam_offset+j_x) = sigma_lam_slice(lam_offset+j_x) + tmp
#else
                                       tmp = cc_intgrl*civec%v(mu_offset +j_y)
                                       tmp2 = cc_intgrl*civec%v(lam_offset+j_x)
                                       sigmavec%v(lam_offset+j_x) = sigmavec%v(lam_offset+j_x) + tmp
#endif

#ifdef TIGER_USE_OMP
                                       sigma_mu_slice(mu_offset+j_y) = sigma_mu_slice(mu_offset+j_y) + tmp2
#else
                                       sigmavec%v(mu_offset+j_y) = sigmavec%v(mu_offset+j_y) + tmp2
#endif
                                    enddo
                                                                        
                                 enddo
!////////////////////////////////////////////////////////////////////
                              endif
                         enddo
                         
#ifdef TIGER_USE_OMP
                         ! put the mu slice on
                         call setLocks(sigmavec%l,mu_start,mu_start+mu_length2C2-1)
                         sigmavec%v(mu_start:mu_start+mu_length2C2-1) = sigmavec%v(mu_start:mu_start+mu_length2C2-1) + sigma_mu_slice
                         call unsetLocks(sigmavec%l,mu_start,mu_start+mu_length2C2-1)
                         
#endif
                          
                      enddo
                      
#ifdef TIGER_USE_OMP
                      ! put the lambda slice on
                      call setLocks(sigmavec%l,lambda_start,lambda_start+lam_length2C2-1)
                      sigmavec%v(lambda_start:lambda_start+lam_length2C2-1) = sigmavec%v(lambda_start:lambda_start+lam_length2C2-1) + sigma_lam_slice
                      call unsetLocks(sigmavec%l,lambda_start,lambda_start+lam_length2C2-1)
#endif
                      
                  enddo
                  
#ifdef TIGER_USE_OMP
                  deallocate(sigma_lam_slice,sigma_mu_slice,stat=status)
                  call deallocatecheck(status,"sigma_lammu_slice")
#endif
                  
             endif ! skip?

          endif

        endif

      !!!!!!!!!!!!!!!!!!!!!!!!!!!
      !//
      !//  ONE VIRTUAL DOUBLY OCCUPIED
      !//
      !!!!!!!!!!!!!!!!!!!!!!!!!!!

      !// GET DIMENSIONS
      if (chain <= 3) then
          lambda_singles = internal_singles
          mu_singles = lambda_singles
      elseif (chain == 4) then
          lambda_singles = internal_singles
          mu_singles = lambda_singles-4
      else
          lambda_singles= internal_singles
          mu_singles = lambda_singles-2
      endif

      !// WE HAVE NOW THE NUMBER OF SPIN FUNCTIONS FOR THE LAMBDA_PATH AND MU_PATH

      lambda_dim = fsn(lambda_singles)
      mu_dim = fsn(mu_singles)

      if (lambda_dim /= 0.and.mu_dim /=0) then

         lambda_address = internal_index_vector3(weight + 1)
         mu_address     = internal_index_vector3(rt_loop_weight + 1)


         if (lambda_address > 0  .and. mu_address > 0) then

             !// GET THE COUPLING COEFFICIENTS AND THE CORRESPONDING INTEGRALS
             !// Jx and Jy are the integrals
             !// Px and Py are the matrix of coupling coefficients


             skip = .false.
             call coupling_coeff_and_integrals(chain, member_loop, &
                                               ibar, jbar, kbar, lbar,&
                                               lambda_singles, mu_singles,&
                                               integrals(1),&
                                               integrals(2),&
                                               integrals(3),&
                                               skip,&
                                               Jx,Jy,Px,Py)

             if(.not. skip) then

             !// NOW COMPUTE THE SIGMAVECTOR

                  lambda_weight = weight+1
                  mu_weight     = rt_loop_weight+1

                  lam_length2  = num_allowed_virtuals(weight+1,"D")
                  mu_length2  = num_allowed_virtuals(rt_loop_weight+1,"D")
                  
#ifdef TIGER_USE_OMP
                  allocate(sigma_lam_slice(lam_length2),sigma_mu_slice(mu_length2),stat=status)
                  call allocatecheck(status,"sigma_lammu_slice")
#endif

                  call get_virtuals(lambda_weight,"D",virt_lam_allow)
                  call get_virtuals(mu_weight,"D",virt_mu_allow)

                  do i = 1,lambda_dim

                    lambda_start = (i-1)*lam_length2 + lambda_address
                    
#ifdef TIGER_USE_OMP
                    sigma_lam_slice = 0.d0
#endif
                    
                    do j = 1,mu_dim

                         mu_start = (j-1)*mu_length2 + mu_address
                         
#ifdef TIGER_USE_OMP
                         sigma_mu_slice = 0.d0
#endif                   

                         do index_xy = 1,2

                          if (index_xy == 1) then
                            cc = Px(i,j)
                            intgrl = Jx
                          elseif (index_xy == 2) then
                            cc = Py(i,j)
                            intgrl = Jy
                          endif

                          if (abs(cc) > integral_threshold .and. abs(intgrl) > integral_threshold) then

                            cc_intgrl = cc*intgrl
                            do i_dum = 1, common_virt_length
                               i_x = common_virt_lam_pos(i_dum)
                               i_y = common_virt_mu_pos(i_dum)
                               tmp = cc_intgrl*civec%v(mu_start+i_y-1)
                               tmp2 = cc_intgrl*civec%v(lambda_start+i_x-1)

#ifdef TIGER_USE_OMP
                               sigma_lam_slice(i_x) = sigma_lam_slice(i_x) + tmp
                               sigma_mu_slice(i_y) = sigma_mu_slice(i_y) + tmp2
#else
                               sigmavec%v(lambda_start+i_x-1) = sigmavec%v(lambda_start+i_x-1)+ tmp
                               sigmavec%v(mu_start+i_y-1) = sigmavec%v(mu_start+i_y-1)+ tmp2
#endif

                            enddo

                          endif

                        enddo
                        
#ifdef TIGER_USE_OMP
                        ! put on mu slice
                        call setLocks(sigmavec%l,mu_start,mu_start+mu_length2-1)
                        sigmavec%v(mu_start:mu_start+mu_length2-1) = sigmavec%v(mu_start:mu_start+mu_length2-1) + sigma_mu_slice
                        call unsetLocks(sigmavec%l,mu_start,mu_start+mu_length2-1)
#endif

                      enddo
                      
#ifdef TIGER_USE_OMP
                      ! put on lambda slice
                      call setLocks(sigmavec%l,lambda_start,lambda_start+lam_length2-1)
                      sigmavec%v(lambda_start:lambda_start+lam_length2-1) = sigmavec%v(lambda_start:lambda_start+lam_length2-1) + sigma_lam_slice
                      call unsetLocks(sigmavec%l,lambda_start,lambda_start+lam_length2-1)
#endif                

                  enddo
                  
#ifdef TIGER_USE_OMP
                  deallocate(sigma_lam_slice,sigma_mu_slice,stat=status)
                  call deallocatecheck(status,"sigma_lammu_slice")
#endif
                  
               endif ! skip?

            endif

          
      endif
     
  elseif (start_elec == num_elec -1) then
  
      !!!!!!!!!!!!!!!!!!!!!!!!!!!
      !// 
      !//  ONE VIRTUAL SINGLY OCCUPIED
      !// 
      !!!!!!!!!!!!!!!!!!!!!!!!!!!
      
      !// GET DIMENSIONS
      if (chain <= 3) then
          lambda_singles = internal_singles+1
          mu_singles = lambda_singles
      elseif (chain == 4) then
          lambda_singles = internal_singles+1
          mu_singles = lambda_singles-4
      else
          lambda_singles= internal_singles+1
          mu_singles = lambda_singles-2    
      endif
      
      !// WE HAVE NOW THE NUMBER OF SPIN FUNCTIONS FOR THE LAMBDA_PATH AND MU_PATH 
      
      lambda_dim = fsn(lambda_singles)
      mu_dim = fsn(mu_singles)
      
      if (lambda_dim /= 0.and.mu_dim /=0) then
         
 
          lambda_address = internal_index_vector1(weight + 1)
          mu_address     = internal_index_vector1(rt_loop_weight + 1)

          
          if (lambda_address > 0  .and. mu_address > 0) then
              
              !// GET THE COUPLING COEFFICIENTS AND THE CORRESPONDING INTEGRALS
              !// Jx and Jy are the integrals 
              !// Px and Py are the matrix of coupling coefficients 
          
    
              skip = .false.
              call coupling_coeff_and_integrals(chain, member_loop, &
                                                ibar, jbar, kbar, lbar,&
                                                lambda_singles, mu_singles,&
                                                integrals(1),&
                                                integrals(2),&
                                                integrals(3),&
                                                skip,&
                                                Jx,Jy,Px,Py)
 
              if(.not. skip) then
 
              !// NOW COMPUTE THE SIGMAVECTOR  
              
                  lambda_weight = weight+1
                  mu_weight     = rt_loop_weight+1
                  
                  !// FETCH THE PAO OVERLAP FOR A PAIR OF CSFS
                  
                  lam_length1  = num_allowed_virtuals(weight+1,"S") 
                  mu_length1  = num_allowed_virtuals(rt_loop_weight+1,"S") 

             call get_virtuals(lambda_weight,"S",virt_lam_allow)
             call  get_virtuals(mu_weight,"S",virt_mu_allow)

!/////////////////////////////////////////////////////////////// GET READY FOR SPARSE MATRIX MULTIPLICATION

              common_virt = 0
              virt_lam_long = 0
              virt_lam_pos = 0
              virt_mu_long = 0
              virt_mu_pos = 0

             do i = 1, lam_length1
                virt_lam_long(virt_lam_allow(i)) = virt_lam_allow(i)
                virt_lam_pos(virt_lam_allow(i)) = i
             enddo

             do i = 1, mu_length1
                virt_mu_long(virt_mu_allow(i)) = virt_mu_allow(i)
                virt_mu_pos(virt_mu_allow(i)) = i
             enddo

            common_virt_length = 0
            common_virt_lam_pos = 0
            common_virt_mu_pos = 0
            do i = 1, lam_length1
               if ( virt_lam_long(virt_lam_allow(i)) == virt_mu_long(virt_lam_allow(i)) ) then
                  common_virt_length = common_virt_length + 1
                  common_virt(common_virt_length) = virt_lam_allow(i)
                  common_virt_lam_pos(common_virt_length) = virt_lam_pos(virt_lam_allow(i))
                  common_virt_mu_pos(common_virt_length) = virt_mu_pos(virt_lam_allow(i))
               endif
            enddo

            if (common_virt_length .eq. 0 ) return
            
!////////////////////////////////////////////////////////////////////////////////////////////////////

#ifdef TIGER_USE_OMP
                  allocate(sigma_lam_slice(lam_length1),sigma_mu_slice(mu_length1),stat=status)
                  call allocatecheck(status,"sigma_lammu_slice")
#endif

                  do i = 1,lambda_dim 

                      lambda_start = (i-1)*lam_length1 + lambda_address
#ifdef TIGER_USE_OMP
                      sigma_lam_slice = 0.d0
#endif
            
                      do j = 1,mu_dim
                          mu_start = (j-1)*mu_length1 + mu_address
#ifdef TIGER_USE_OMP
                          sigma_mu_slice = 0.d0
#endif

                          do index_xy = 1,2
                              if (index_xy == 1) then 
                                  cc = Px(i,j)
                                  intgrl = Jx 
                              elseif (index_xy == 2) then 
                                  cc = Py(i,j)
                                  intgrl = Jy 
                              endif
                              
                              if (abs(cc) > integral_threshold .AND. abs(intgrl) > integral_threshold) then 
                                  cc_intgrl = cc*intgrl
                                  do i_dum = 1, common_virt_length
                                     i_x = common_virt_lam_pos(i_dum)
                                     i_y = common_virt_mu_pos(i_dum)
                                     tmp = cc_intgrl*civec%v(mu_start+i_y-1)
                                     tmp2 = cc_intgrl*civec%v(lambda_start+i_x-1)

#ifdef TIGER_USE_OMP
                                     sigma_lam_slice(i_x) = sigma_lam_slice(i_x) + tmp
                                     sigma_mu_slice(i_y) = sigma_mu_slice(i_y) + tmp2
#else
                                     sigmavec%v(lambda_start+i_x-1) = sigmavec%v(lambda_start+i_x-1)+ tmp
                                     sigmavec%v(mu_start+i_y-1) = sigmavec%v(mu_start+i_y-1)+ tmp2
#endif
                                  enddo
                              endif
                              
                          enddo
                          
#ifdef TIGER_USE_OMP
                          ! put on mu slice
                          call setLocks(sigmavec%l,mu_start,mu_start+mu_length1-1)
                          sigmavec%v(mu_start:mu_start+mu_length1-1) = sigmavec%v(mu_start:mu_start+mu_length1-1) + sigma_mu_slice
                          call unsetLocks(sigmavec%l,mu_start,mu_start+mu_length1-1)
#endif
                          
                      enddo
                      
#ifdef TIGER_USE_OMP
                      ! put on lambda slice
                      call setLocks(sigmavec%l,lambda_start,lambda_start+lam_length1-1)
                      sigmavec%v(lambda_start:lambda_start+lam_length1-1) = sigmavec%v(lambda_start:lambda_start+lam_length1-1) + sigma_lam_slice
                      call unsetLocks(sigmavec%l,lambda_start,lambda_start+lam_length1-1)
#endif
                      
                  enddo
                  
#ifdef TIGER_USE_OMP
                  deallocate(sigma_lam_slice,sigma_mu_slice,stat=status)
                  call deallocatecheck(status,"sigma_lammu_slice")
#endif
                  
             endif ! skip?
          endif
          
      endif

  else
  

      !!!!!!!!!!!!!!!!!!!!!!!!!!!
      !// 
      !//  VALENCE STATE; NO EXTERNALS OCCUPIED
      !// 
      !!!!!!!!!!!!!!!!!!!!!!!!!!!
      
      !// GET DIMENSIONS
      if (chain <= 3) then
          lambda_singles = internal_singles
          mu_singles = lambda_singles
      elseif (chain == 4) then
          lambda_singles = internal_singles
          mu_singles = lambda_singles-4
      else
          lambda_singles= internal_singles
          mu_singles = lambda_singles-2    
      endif
      
      !// WE HAVE NOW THE NUMBER OF SPIN FUNCTIONS FOR THE LAMBDA_PATH AND MU_PATH 
      
      lambda_dim = fsn(lambda_singles)
      mu_dim = fsn(mu_singles)
      
      if (lambda_dim /= 0.and.mu_dim /=0) then
          
          lambda_address = internal_index_vector0(weight + 1)
          mu_address     = internal_index_vector0(rt_loop_weight + 1)
          
          if (lambda_address > 0  .and. mu_address > 0) then
              
              !// GET THE COUPLING COEFFICIENTS AND THE CORRESPONDING INTEGRALS
              !// Jx and Jy are the integrals 
              !// Px and Py are the matrix of coupling coefficients 
              
              skip = .false.
              call coupling_coeff_and_integrals(chain, member_loop, &
                                                ibar, jbar, kbar, lbar,&
                                                lambda_singles, mu_singles,&
                                                integrals(1),&
                                                integrals(2),&
                                                integrals(3),&
                                                skip,&
                                                Jx,Jy,Px,Py)
                                                
              if(.not. skip) then
  
  
#ifdef TIGER_USE_OMP
                  allocate(sigma_lam_slice(lambda_dim),sigma_mu_slice(mu_dim),stat=status)
                  call allocatecheck(status,"sigma_lammu_slice")
                  sigma_mu_slice = 0.d0
#endif
  
                  !// NOW COMPUTE THE SIGMAVECTOR
                  do i = 1,lambda_dim
                  
                      lambda_start = (i-1) + lambda_address
              
                      tmp = 0.0
                      do j = 1,mu_dim
                          
                          mu_start = (j-1) + mu_address
                      
                          do index_xy = 1,2
                              if (index_xy == 1) then 
                                  cc = Px(i,j)
                                  intgrl = Jx 
                              elseif (index_xy == 2) then 
                                  cc = Py(i,j)
                                  intgrl = Jy 
                              endif
                              
                              if (abs(cc) > integral_threshold .AND. abs(intgrl) > integral_threshold) then
                                  tmp = tmp + cc*intgrl*civec%v(mu_start)
                                  tmp2 = cc*intgrl*civec%v(lambda_start)
#ifdef TIGER_USE_OMP
                                  sigma_mu_slice(j) = sigma_mu_slice(j) + tmp2
#else
                                  sigmavec%v(mu_start) = sigmavec%v(mu_start) + tmp2
#endif
                              endif
                          enddo
                      enddo
#ifdef TIGER_USE_OMP
                      sigma_lam_slice(i) = tmp
#else
                      sigmavec%v(lambda_start) = sigmavec%v(lambda_start) + tmp
#endif
                  enddo
                  
#ifdef TIGER_USE_OMP
                  ! throw mu stuff on
                  call setLocks(sigmavec%l,mu_address,mu_address+mu_dim-1)
                  sigmavec%v(mu_address:mu_address+mu_dim-1) = sigmavec%v(mu_address:mu_address+mu_dim-1) + sigma_mu_slice
                  call unsetLocks(sigmavec%l,mu_address,mu_address+mu_dim-1)
                  
                  ! throw lambda stuff on
                  call setLocks(sigmavec%l,lambda_address,lambda_address+lambda_dim-1)
                  sigmavec%v(lambda_address:lambda_address+lambda_dim-1) = sigmavec%v(lambda_address:lambda_address+lambda_dim-1) + sigma_lam_slice
                  call unsetLocks(sigmavec%l,lambda_address,lambda_address+lambda_dim-1)
                  
                  deallocate(sigma_lam_slice,sigma_mu_slice,stat=status)
                  call deallocatecheck(status,"sigma_lammu_slice")
#endif

            endif ! skip?
                  
          endif
          
      endif
      
  endif
  
  deallocate(common_virt,virt_lam_long,virt_lam_pos, &
           virt_mu_long,virt_mu_pos,common_virt_lam_pos, &
           common_virt_mu_pos,stat=status)
  call deallocatecheck(status,"four_i_seg_loopdrv_sigma")
  
end subroutine four_i_seg_loopdrv_sigma
!*****************************************************************
!*****************************************************************
subroutine two_intern_seg_compl_vec_lmo(lambda_path,mod2vars)

  !// IN THIS SUBROUTINE WE BUILD THE COMPLEMENT TO THE TWO SEGMENT
  !// OPEN AND CLOSED LOOPS IN THE INTERNAL SPACE.  WHAT WE ARE 
  !// TREATING HERE ARE THE FOUR SEGMENT LOOPS WITH TWO SEGMENTS IN
  !// THE INTERNAL SPACE AND THE THREE SEGMENT LOOPS WITH THE J AND I
  !// SEGMENT IN THE INTERNAL SPACE.  THIS IS A SPEEDY GONZALES STYLE
  !// VECTORIZED TREATMENT.  UNLESS YOU HAVE SOME COMPELLING REASON
  !// TO DO OTHERWISE, YOU SHOULD USE THIS.  IT RULES.
  
  !!!!!!!!!!!!!!!!!!!!!!!!!!!  VARIABLE DECLARATION !!!!!!!!!!!!!!!!!!!!!!!!!!
  
  use locist_var_mod,only:locist_scratch
  
  implicit none
  
  type(orbital_path),intent(inout)::lambda_path
  type(threefourmod2vars),intent(inout)::mod2vars
  
  integer::loop_type              !// LABELS THE KIND OF LOOP
  integer::s1,s2,s3,s4
  integer::current_vertex         !// USED IN BUILDING MU PATH
  integer::step_type              !// KEEPS TRACK OF STEP IN MU PATH CONSTRUCTION
  integer::path_elecs             !// CUMULATIVE OCCUPATION IN MU PATH
  integer::top_level              !// LEVEL OF FIRST LOOP SEGMENT
  integer::mu_levels              !// LABELS LEVELS IN MU PATH
  integer::constraint_count       !// KEEP TRACK OF CONSTRAINTS IN BUILDING MU PATH
  integer::start_elec             !// OCCUPATION WHERE INTERNAL CSF MEETS UP WITH EXTERNAL SPACE
  
#ifdef TIGER_USE_OMP
  integer::threadID
  threadID = OMP_get_thread_num()+1
#else
  integer,parameter::threadID = 1
#endif

  !!!!!!!!!!!!!!!!!!!!!!! VARIABLE INITIALIZATION !!!!!!!!!!!!!!!!!!!!!!!!!!!!
  
  loop_type = lambda_path%loop_type    
  start_elec = sum(lambda_path%occupations(0:num_internal))
  
   !// STORE THE WEIGHT OF THE LAMBDA_PATH
  lambda_path%weight = sum(lambda_path%arc_weights(0:num_internal))
 
  if (skip_this_internal(lambda_path%weight,start_elec)) return 
 
  !!!!!!!!!!!!!!!!!!!!!!!!!!! START OF ROUTINE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 
  !// INITIALIZE VARIABLES FOR BUILDING MU PATH
  top_level = lambda_path%level1
  constraint_count = 1
  lambda_path%rt_loop_weight = 0
  path_elecs = sum(lambda_path%occupations(0:top_level-1))

 
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !// 
  !//  BUILD THE MU PATH
  !// 
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!
 
  do mu_levels = top_level, num_internal
  
      current_vertex = vertex(mu_levels-1,path_elecs) 
  
      !// CHECK TO SEE IF THIS IS A CONSTRAINED LEVEL AND GET THE STEP_TYPE
      if ((mu_levels)==lambda_path%constraints(2,constraint_count)) then
          step_type = lambda_path%constraints(3,constraint_count)
          constraint_count = constraint_count + 1
      else
          step_type = lambda_path%occupations(mu_levels)
      endif
      
      !// TRY TO ADD THE STEP
      if (step_type == 2) then
          
          if (add2(mu_levels-1,path_elecs)) then
              path_elecs = path_elecs + 2
              lambda_path%rt_loop_weight = lambda_path%rt_loop_weight +&
                                           abs(y2(current_vertex))
          else
              return
          endif
          
      elseif(step_type == 1) then
  
          if (add1(mu_levels-1,path_elecs)) then
              path_elecs = path_elecs + 1
              lambda_path%rt_loop_weight = lambda_path%rt_loop_weight +&
                                           abs(y1(current_vertex))
          else
              return
          endif
          
      elseif(step_type == 0) then
  
          if (.not.add0(mu_levels-1,path_elecs)) return
  
      endif
      
  enddo  
  
  !// FOR THE RT_LOOP_WEIGHT ADD IN THE WEIGHTS OF THE RELEVANT PARTS
  !// OF THE HEAD AND TAIL PATHS.  THIS WILL END UP BEING THE MU PATH WEIGHT
  lambda_path%rt_loop_weight = lambda_path%rt_loop_weight +&
                               sum(lambda_path%arc_weights(0:lambda_path%level1-1))
                               
  if (skip_this_internal(lambda_path%rt_loop_weight,path_elecs)) return
 
   !!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !//
  !// GET NUMBERS OF SINGLES.  WE CAN'T GET THE
  !// IBAR,JBAR,KBAR,LBAR, ETC. BECAUSE WE ARE GOING
  !// TO USE THE PARTIAL PATH FOR MULTIPLE LOOPS
  !//
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!

  call get_numbers_of_singles(s1,s2,s3,s4,lambda_path)!%occupations,lambda_path%constraints)

  mod2vars%ijab_rec = mod2vars%ijab_rec + 1
  call two_seg_writeData(mod2vars%ijab_rec,pseudo_two_info,threadID,mod2vars%ij_ind,s1,s2,s3,s4,lambda_path%weight,lambda_path%rt_loop_weight,&
                               lambda_path%num_singles,loop_type,start_elec)
                               
end subroutine two_intern_seg_compl_vec_lmo
!*****************************************************************

!*****************************************************************
subroutine two_int_seg_com_lmo_res(civec, sigmavec, ij_1,virt_lam_allow,virt_mu_allow, &
                ijab_rec,Px,Py,scep_integral_C,scep_integral_EX,scep_ci_1,scep_sigma_1, &
                cho_data,realI,realJ)

  !// IN THIS SUBROUTINE WE BUILD THE COMPLEMENT TO THE TWO SEGMENT
  !// OPEN AND CLOSED LOOPS IN THE INTERNAL SPACE.  WHAT WE ARE 
  !// TREATING HERE ARE THE FOUR SEGMENT LOOPS WITH TWO SEGMENTS IN
  !// THE INTERNAL SPACE AND THE THREE SEGMENT LOOPS WITH THE J AND I
  !// SEGMENT IN THE INTERNAL SPACE.  THIS IS A SPEEDY GONZALES STYLE
  !// VECTORIZED TREATMENT.  UNLESS YOU HAVE SOME COMPELLING REASON
  !// TO DO OTHERWISE, YOU SHOULD USE THIS.  IT RULES.
  
  !!!!!!!!!!!!!!!!!!!!!!!!!!!  VARIABLE DECLARATION !!!!!!!!!!!!!!!!!!!!!!!!!!
  
  use locist_var_mod,only:locist_scratch
  use iajb_mod, only:makeOneIAJB
  use ijab_mod, only:makeOneIJAB
 
 
  implicit none
  
  !type(threefourmod2vars)::mod2vars
  
  integer,dimension(:),intent(inout)::virt_lam_allow,virt_mu_allow
  !real(real8),dimension(:,:)::sigma_nm2_lambda,sigma_nm2_mu jmd: patched it out to reuse scratch space
  integer,intent(inout)::ijab_rec
  real(real8),dimension(:,:),intent(inout)::scep_integral_EX
  real(real8),dimension(:),intent(inout)::scep_integral_C
  real(real8),dimension(:,:),intent(inout)::Px,Py,scep_ci_1,scep_sigma_1
  type(blockedLockVectorType),intent(inout) :: civec, sigmavec 
  type(cholesky_data),intent(in) :: cho_data
  integer,intent(in)::realI,realJ
  
  type(orbital_path)::lambda_path
  
  integer::loop_type              !// LABELS THE KIND OF LOOP
  integer::chain, member          !// LABELS CHAIN AND MEMBER WITHIN CHAIN
  integer::s1,s2,s3,s4
  integer::allocatestatus         !// FOR DYNAMIC MEMORY
  integer::deallocatestatus
  integer::lambda_singles         !// SINGLES IN LAMBDA AND MU PATH
  integer::mu_singles
  integer::lambda_singles_int     !// SINGLES IN INTERNAL PARTS OF LAMBDA AND MU PATH
  integer::mu_singles_int
  integer::lambda_dim,mu_dim      !// DIMENSIONS FOR LAMBDA AND MU CONFIGURATIONS
  integer::lambda_weight          !// WEIGHTS OF LAMBDA AND MU PATH
  integer::mu_weight             
  integer::start_elec             !// OCCUPATION WHERE INTERNAL CSF MEETS UP WITH EXTERNAL SPACE
  integer::a,b                   !// USED TO INDEX EXTERNAL ORBITALS
  integer::lambda_spin, mu_spin   !// FOR LOOPING OVER PAIRS OF SPIN FUNCTIONS
  
  !// A FEW NOTES ABOUT THE VARIABLES BELOW.  NM1 IS SHORT FOR "N MINUS ONE",
  !// NM2 IS SHORT FOR "N MINUS TWO", AND V IS SHORT FOR "VALENCE"                
  
  !// THESE VARIABLES USED FOR N-1 VALENCE INTERACTIONS   
  integer::v_dim,nm2_dim         !// DIMENSIONS OF SPIN SPACES    
  integer::v_address, nm2_address !// ADDRESSES
  integer::aa_address
  
  !// THESE VARIABLES USED FOR N-2/N-2 INTERACTIONS
  integer::mode_1, mode_2
  
  !// THESE VARIABLES USED FOR N-1/N-1 INTERACTIONS
  integer::nm1_start_1,   nm1_start_2            !// EACH HAVING A SINGLE VIRTUAL SINGLY OCCUPIED
  integer::nm1_end_1,     nm1_end_2                                          
  integer::nm1_address_1, nm1_address_2                        
  integer::aa_dim
  
  integer::Jx_index, Jy_index                    !// FOR KEEPING TRACK OF WHICH INTEGRAL TO PAIR UP WITH PX, PY
  integer::doublet_flag                          !// SET THIS TO 1 IF YOU ARE CALLING INTERNAL CC DRIVER FOR STATES
                                                 !// WITH DOUBLET SPIN COUPLING IN THE EXTERNAL SPACE
  
  integer, parameter::upper=1                    !// FOR FILLING UPPER AND LOWER HALVES OF MATRICES                
  integer, parameter::lower=-1
  
  real(real8)::cc,cc2,tmpint                 !// TEMPORARY STORAGE OF A COUPLING COEFFICIENT
  real(real8),parameter::zero=real(0.0, real8),sqrt2=sqrt(real(2.0,real8)),two=real(2.0,real8),one=real(1.0,real8)
  real(real8)::Jx_mult,Jy_mult    !// IN CASE COUPLING COEFFICIENTS NEED TO BE MULTIPLIED BY +-1
                                       
  integer::i,k
  integer::ierror

  !!!!!!!!!!!!!!!!!! SOME MORE DECLARATIONS - ARUN

  integer::ab_lam_address,ab_mu_address
  integer::aa_lam_address,aa_mu_address          
  integer::ab_lam_start
  integer::aa_lam_start
  integer::ab_mu_start
  integer::aa_mu_start       
  integer::lam_length,mu_length,lam_lengthC2,mu_lengthC2

  real(real8),dimension(:,:),allocatable::scep_integral_EX_save,scep_integral_C_save
  integer::a1,b1,x1,x2
  integer,intent(inout)::ij_1
  integer::ij_2

!//////////// EXTRA VARIABLES

  integer::common_virt_length,i_dum,k_x,k_y
  integer,dimension(:),allocatable::common_virt,virt_lam_long,virt_lam_pos,virt_mu_long,virt_mu_pos,&
                                   common_virt_lam_pos,common_virt_mu_pos

  real(real8),dimension(:,:),allocatable:: ci_1_mat,ci_2_mat,sig_nm2_lam,sig_nm2_mu
  real(real8),dimension(:),allocatable::scr_vec1,scr_vec2
  character::trans1_1,trans1_2,trans2_1,trans2_2
  integer::dimScep1,dimScep2
  logical::intsZero
  integer::status
  integer::jumper1,jumper2
  logical::isSymmetric
#ifdef TIGER_USE_OMP
  integer::threadID
  threadID = OMP_get_thread_num()+1
#else
  integer,parameter::threadID = 1
#endif

  allocate(common_virt(num_orbitals),virt_lam_long(num_orbitals),virt_lam_pos(num_orbitals), &
           virt_mu_long(num_orbitals),virt_mu_pos(num_orbitals),&
           common_virt_lam_pos(num_orbitals),common_virt_mu_pos(num_orbitals),stat=status)
  call allocatecheck(status,"two_int_seg_com_lmo_res")
  
! START AUTOGENERATED INITIALIZATION
nm1_end_1 = 0
nm1_end_2 = 0
jy_mult = 0.0
aa_lam_address = 0
mu_spin = 0
aa_mu_start = 0
ab_mu_start = 0
lambda_weight = 0
loop_type = 0
mu_singles = 0
chain = 0
doublet_flag = 0
mu_dim = 0
nm1_address_1 = 0
jx_index = 0
mu_lengthc2 = 0
start_elec = 0
nm1_address_2 = 0
jx_mult = 0.0
nm1_start_1 = 0
nm1_start_2 = 0
ab_lam_start = 0
mode_1 = 0
ab_lam_address = 0
lam_length = 0
aa_mu_address = 0
i_dum = 0
lam_lengthc2 = 0
aa_address = 0
mu_weight = 0
ierror = 0
lambda_spin = 0
jy_index = 0
cc = 0.0
b1 = 0
lambda_dim = 0
s1 = 0
nm2_address = 0
lambda_singles_int = 0
member = 0
ab_mu_address = 0
s2 = 0
s3 = 0
s4 = 0
a1 = 0
virt_lam_pos = 0
i = 0
mode_2 = 0
k_x = 0
k_y = 0
aa_dim = 0
aa_lam_start = 0
lambda_singles = 0
mu_length = 0
v_dim = 0
k = 0
b = 0
a = 0
v_address = 0
nm2_dim = 0
mu_singles_int = 0
! END AUTOGENERATED INITIALIZATION 

  !!!!!!!!!!!!!!!!!!!!!!!!!!! START OF ROUTINE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  
  !write(*,*) "DEBUG: Reached two_int_seg_com_lmo_res..."
  !flush(6)

  ij_2 = 0   ! added so that in case of I/O failure ij_2 is not uninitialized 
  ijab_rec = ijab_rec + 1
  call two_seg_readData(ijab_rec,pseudo_two_info,threadID,ij_2,s1,s2,s3,s4,lambda_path%weight,lambda_path%rt_loop_weight,&
                                             lambda_path%num_singles,loop_type,start_elec,ierror)

  if (ij_1 .ne. ij_2) then
    ijab_rec = ijab_rec -1
    ij_1 = ij_2
    return
  endif

  if (ierror .ne. 0) then
    ij_1 = 0
    return
  endif


  if (loop_type <= 4) then
  
      !!!!!!!!!!!!!!!!!!!!!!!
      !//
      !// NOW TAKE CARE OF THE FOUR SEGMENT
      !// LOOPS BY JOINING A {11} SEGMENT TO
      !// THE END OF THE LOOP FRAGMENT
      !// 
      !!!!!!!!!!!!!!!!!!!!!!!
      
      !// GET THE NUMBER OF SINGLES 
      if (loop_type == 1) then
          lambda_singles = lambda_path%num_singles + 2
          mu_singles = lambda_singles 
      elseif (loop_type == 2) then
          lambda_singles = lambda_path%num_singles + 2
          mu_singles = lambda_singles - 4
      else 
          lambda_singles = lambda_path%num_singles + 2
          mu_singles = lambda_singles - 2
      endif        
          
      lambda_dim = fsn(lambda_singles)
      mu_dim = fsn(mu_singles)

      !// COMPUTE COUPLING COEFFICIENTS AND DO MULTIPLICATIONS
      !// IF ALLOWED
      !write(*,*) "DEBUG: loop_type4"
      dim1: if (lambda_dim /= 0.and.mu_dim /= 0) then
          
          aa_address  = internal_index_vector3(lambda_path%weight+1)
          nm2_address = internal_index_vector2(lambda_path%weight+1)
          v_address   = internal_index_vector0(lambda_path%rt_loop_weight+1)
          
          nm2_dim = lambda_dim
          v_dim   = mu_dim
          aa_dim  = fsn(lambda_singles-2)
          
          !write(*,*) "DEBUG: aa_address, nm2_address, v_address",aa_address, nm2_address, v_address
          
          if (v_address > 0 .and. (nm2_address > 0 .or. aa_address > 0)) then
 
              !// PASS IN S3+1 AND S4=1 TO TAKE INTO ACCOUNT THE
              !// SINGLES IN THE EXTERNAL SPACE
              s4 = 1
              call coupling_coefficient_driver_2( s1,s2,s3+1,s4,&
                                                 loop_type,0,&
                                                 .false.,&
                                                 chain, member,&
                                                 lambda_singles,mu_singles,&
                                                 Px,Py,&
                                                 size(Px,1))
              call get_Jx_Jy_index(member, chain, Jx_index, Jy_index, Jx_mult, Jy_mult)
              
              call do_nm2_v_multiplications_3_lmo(civec, sigmavec, nm2_address,v_address,&
                                              aa_address,&
                                              nm2_dim,v_dim,&
                                              aa_dim,&
                                              Px,lambda_path%weight+1, &
                                              loop_type,scep_integral_EX,cho_data,realI,realJ)
                                              
          endif
      endif dim1

  else
      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      !//
      !// NOW WE BUILD 6 DIFERENT KINDS OF
      !// FOUR SEGMENT LOOPS BY JOINING
      !// DIFFERENT FLAVORS OF CLOSED LOOPS
      !// IN THE EXTERNAL SPACE.
      !//
      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      
      !// GET THE NUMBER OF INTERNAL SINGLES
      if (loop_type <= 6) then
          lambda_singles_int = lambda_path%num_singles 
          mu_singles_int = lambda_singles_int -2
      else 
          lambda_singles_int = lambda_path%num_singles 
          mu_singles_int = lambda_singles_int
      endif        
      
      start_elec1: if (start_elec == num_elec-2) then
      
          !// COMPUTE THE WEIGHTS 
          lambda_weight = lambda_path%weight+1
          mu_weight     = lambda_path%rt_loop_weight+1
          
          !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
          !//
          !// GET COUPLING COEFFICIENTS
          !//
          !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
          lambda_singles = lambda_singles_int+2
          mu_singles = mu_singles_int+2
          
          lambda_dim = fsn(lambda_singles)
          mu_dim     = fsn(mu_singles)
          
          doublet_flag = 0
          call internal_cc_driver(Px,Py,size(Px,1),loop_type,s1,s2,lambda_singles,mu_singles,doublet_flag)
          
          dim2: if (lambda_dim /= 0 .and. mu_dim /= 0) then
              
              ab_lam_address = internal_index_vector2(lambda_path%weight+1)
              aa_lam_address = internal_index_vector3(lambda_path%weight+1)
              
              ab_mu_address  = internal_index_vector2(lambda_path%rt_loop_weight+1)
              aa_mu_address  = internal_index_vector3(lambda_path%rt_loop_weight+1)

              if (ab_lam_address > 0 .and. ab_mu_address > 0) then       

              lam_length     = num_allowed_virtuals(lambda_weight,"D") 
              lam_lengthC2 = lam_length*(lam_length-1)/2
              call get_virtuals_and_index(lambda_weight,"D",virt_lam_allow,jumper1)
                   
              mu_length     = num_allowed_virtuals(mu_weight,"D") 
              mu_lengthC2 = mu_length*(mu_length-1)/2
              call get_virtuals_and_index(mu_weight,"D",virt_mu_allow,jumper2)
              
              if(jumper1 .eq. jumper2 .and. lam_length .eq. mu_length) then
                 isSymmetric = .true.
              else
                 isSymmetric = .false.
              endif

              common_virt = 0
              virt_lam_long = 0
              virt_lam_pos = 0
              virt_mu_long = 0
              virt_mu_pos = 0

             do i = 1, lam_length
                i_dum = virt_lam_allow(i)
                virt_lam_long(i_dum)= i_dum 
                virt_lam_pos(i_dum)= i
             enddo

             do i = 1, mu_length
                i_dum = virt_mu_allow(i)
                virt_mu_long(i_dum)= i_dum 
                virt_mu_pos(i_dum) = i
             enddo

            common_virt_length = 0
            common_virt_lam_pos = 0
            common_virt_mu_pos = 0
            do i = 1, lam_length
               i_dum = virt_lam_allow(i)
               if ( virt_lam_long(i_dum) == virt_mu_long(i_dum) ) then
                  common_virt_length = common_virt_length + 1
                  common_virt(common_virt_length) = i_dum 
                  common_virt_lam_pos(common_virt_length) = virt_lam_pos(i_dum)
                  common_virt_mu_pos(common_virt_length) = virt_mu_pos(i_dum)
               endif
            enddo

            if ( common_virt_length .eq. 0 ) return 
              
            i_dum = max(lam_length,mu_length)
            
            allocate(ci_1_mat(lam_length,common_virt_length),ci_2_mat(mu_length,common_virt_length),sig_nm2_lam(lam_length,common_virt_length), &
            sig_nm2_mu(mu_length,common_virt_length),scep_integral_C_save(i_dum,i_dum),scep_integral_EX_save(i_dum,i_dum),stat=allocatestatus)
            call allocatecheck(allocatestatus,"two_int_seg_com_lmo_res I")
            scep_integral_C_save  = 0 
            scep_integral_EX_save = 0
            
            !>todo here, we want to do something a little different if we were to have a symmetric case? or not?
            if (loop_type == 5 .or. loop_type == 7) then

              if(.false.) then
                do a=1,lam_length
                   a1 = virt_lam_allow(a)
                    do b=1,mu_length
                      b1 = virt_mu_allow(b)
                      x1=max(b1,a1)-num_internal
                      x2=min(b1,a1)-num_internal
                      tmpint = scep_integral_C(x1*(x1-1)/2+x2)
                      if(tmpint == magic_number) then
                         ! compute
                         tmpint = makeOneIJAB(realI,realJ,a1,b1,cho_data)
                         ! store
                         scep_integral_C(x1*(x1-1)/2+x2) = tmpint
                      endif
                      scep_integral_C_save(b,a) = tmpint
                      
                      tmpint = scep_integral_EX(b1-num_internal,a1-num_internal)
                      if(tmpint == magic_number) then
                         ! compute
                         tmpint = makeOneIAJB(realI,b1,realJ,a1,cho_data)
                         ! store
                         scep_integral_EX(b1-num_internal,a1-num_internal) = tmpint
                      endif
                      scep_integral_EX_save(b,a) = tmpint
                   enddo
                enddo
              else
                do a=1,lam_length
                   a1 = virt_lam_allow(a)
                   do b=1,mu_length
                      b1 = virt_mu_allow(b)
                      x1=max(b1,a1)-num_internal
                      x2=min(b1,a1)-num_internal
                      scep_integral_C_save(b,a) = scep_integral_C(x1*(x1-1)/2+x2)
                      scep_integral_EX_save(b,a) = scep_integral_EX(b1-num_internal,a1-num_internal)
                   enddo
                enddo
              endif

            else
              if(.false.) then
              
                do b=1,mu_length
                   b1 = virt_mu_allow(b)
                   do a=1,lam_length
                      a1 = virt_lam_allow(a)
                      x1=max(b1,a1)-num_internal
                      x2=min(b1,a1)-num_internal
                      tmpint = scep_integral_C(x1*(x1-1)/2+x2)
                      if(tmpint == magic_number) then
                         ! compute
                         tmpint = makeOneIJAB(realI,realJ,a1,b1,cho_data)
                         ! store
                         scep_integral_C(x1*(x1-1)/2+x2) = tmpint
                      endif
                      scep_integral_C_save(a,b) = tmpint
                      
                      tmpint = scep_integral_EX(a1-num_internal,b1-num_internal)
                      if(tmpint == magic_number) then
                         ! compute
                         tmpint = makeOneIAJB(realI,a1,realJ,b1,cho_data)
                         ! store
                         scep_integral_EX(a1-num_internal,b1-num_internal) = tmpint
                      endif
                      scep_integral_EX_save(a,b) = tmpint
                   enddo
                enddo
              else
                do b=1,mu_length
                   b1 = virt_mu_allow(b)
                   do a=1,lam_length
                      a1 = virt_lam_allow(a)
                      x1=max(b1,a1)-num_internal
                      x2=min(b1,a1)-num_internal
                      scep_integral_C_save(a,b) = scep_integral_C(x1*(x1-1)/2+x2)
                      scep_integral_EX_save(a,b) = scep_integral_EX(a1-num_internal,b1-num_internal)
                   enddo
                enddo
              endif

            endif
            
!            if(.not.isMatrixSymmetric(scep_integral_C_save,1d-12)) then
!               write(*,*) "Darn, not symmetric. :-("
!               write(*,*) "mu weight and lambda_weight",mu_weight,lambda_weight
!               if(isSymmetric) then
!                 write(*,*) "BUT IT SHOULD HAVE BEEN!!"
!                 flush(6)
!                 stop
!               endif
!               flush(6)
!            else
!               write(*,*) "Hooray, matrix is symmetric!"
!               write(*,*) "mu weight and lambda_weight",mu_weight,lambda_weight
!               if(.not.isSymmetric) then
!                 write(*,*) "AND WE DIDN'T KNEW IT!!!"
!                 flush(6)
!               endif
!               flush(6)
!            endif

            if (loop_type == 5 .or. loop_type == 7) then
                trans1_1 = "T"
                trans1_2 = "N"
                trans2_1 = "N"
                trans2_2 = "N"
                dimScep1 = mu_length
                dimScep2 = lam_length
            else
                trans1_1 = "N"
                trans1_2 = "N"
                trans2_1 = "T"
                trans2_2 = "N"
                dimScep1 = lam_length
                dimScep2 = mu_length
            endif
 
                  !// LOOP OVER FIRST SET OF SPIN COUPLINGS.
                  do lambda_spin = 1, lambda_dim
                                    
                      if (internal_index_vector2(lambda_weight) < 0) cycle

                      ab_lam_start  = ab_lam_address + lam_lengthC2*(lambda_spin-1)
                      aa_lam_start  = aa_lam_address + lam_length*(lambda_spin-1)

                      mode_1 = -1
                      if (lambda_spin  <= fsn(lambda_singles-2)) mode_1 = 1

                      if (mode_1 .eq. 1) then
                          call scepper_diag_p1(scep_ci_1,civec%v,ab_lam_start, &
                                        lam_length, civec%v,aa_lam_start)
                      elseif (mode_1 .eq. -1) then
                          call scepper_diag_m1(scep_ci_1,civec%v,ab_lam_start, &
                                        lam_length)
                      endif

                      do  k = 1,common_virt_length
                          k_x = common_virt_lam_pos(k)
                          ci_1_mat(:,k) = scep_ci_1(1:lam_length,k_x)
                      enddo
                      
                      ! ok, classical fortran style reuse of scratch space... ;-)
                      scep_sigma_1(1:lam_length,1:lam_length) = zero
                      do mu_spin = 1,mu_dim 
                          
                          if (internal_index_vector2(mu_weight) < 0) cycle

                          ab_mu_start  = ab_mu_address + mu_lengthC2*(mu_spin-1)
                          aa_mu_start  = aa_mu_address + mu_length*(mu_spin-1)

                          mode_2 = -1
                          if (mu_spin  <= fsn(mu_singles-2)) mode_2 = 1

                          if (mode_2 .eq. 1) then                          
                              call scepper_diag_p1(scep_ci_1,civec%v,ab_mu_start,&
                                            mu_length,civec%v,aa_mu_start)
                          elseif (mode_2 .eq. -1) then
                              call scepper_diag_m1(scep_ci_1,civec%v,ab_mu_start,&
                                            mu_length)
                          endif

                          do k = 1,common_virt_length
                              k_y = common_virt_mu_pos(k)
                              ci_2_mat(:,k) = scep_ci_1(1:mu_length,k_y)
                          enddo

                          !// DON'T DO ANYTHING IF BOTH COUPLING COEFFICIENTS ARE SMALL
                          if (abs(Px(lambda_spin,mu_spin)) <= integral_threshold.and.&
                              abs(Py(lambda_spin,mu_spin)) <= integral_threshold) cycle

                     
                          !// DO THE MULTIPLICATIONS                        

                          cc = Px(lambda_spin,mu_spin)
                          cc2 = Py(lambda_spin,mu_spin)
                                                    
                          if (abs(cc) > integral_threshold) then
                          
#ifdef TIGER_SGGA_SYM
                            if(isSymmetric) then
                             ! we never need to transpose the ci_X_mats and since scep_integral_C_save is symmetric, we do not need to transpose this either
                             
                             if(lam_length /= mu_length) then
                                write(*,*) "symmetric assumption does not hold true! (1) ",lam_length,mu_length
                                flush(6)
                                stop
                             endif
                             
                             call dsymm("L","U",lam_length,common_virt_length,cc, &
                                  scep_integral_C_save,i_dum,&
                                  ci_2_mat,lam_length,&
                                  zero,sig_nm2_lam,lam_length)
                                  
                             call dsymm("L","U",lam_length,common_virt_length,cc,&
                                  scep_integral_C_save,i_dum,&
                                  ci_1_mat,lam_length,&
                                  zero,sig_nm2_mu,lam_length)
                            
                            else
#endif

                             call dgemm(trans1_1,trans1_2,lam_length,common_virt_length,mu_length,cc,&
                                  scep_integral_C_save,i_dum,&
                                  ci_2_mat,mu_length,&
                                  zero,sig_nm2_lam,lam_length)

                             call dgemm(trans2_1,trans2_2,mu_length,common_virt_length,lam_length,cc,&
                                  scep_integral_C_save,i_dum,&
                                  ci_1_mat,lam_length,&
                                  zero,sig_nm2_mu,mu_length)
                                
#ifdef TIGER_SGGA_SYM
                            endif
#endif
                              
                          else
                          
                             sig_nm2_lam = zero
                             sig_nm2_mu = zero

                          endif    



                          if (abs(cc2) > integral_threshold) then

                             call dgemm(trans1_1,trans1_2,lam_length,common_virt_length,mu_length,cc2,&
                                      scep_integral_EX_save,i_dum,&
                                      ci_2_mat,mu_length,&
                                      one,sig_nm2_lam,lam_length)

                             call dgemm(trans2_1,trans2_2,mu_length,common_virt_length,lam_length,cc2,&
                                     scep_integral_EX_save,i_dum,&
                                     ci_1_mat,lam_length,&
                                     one,sig_nm2_mu,mu_length)
                          endif

                          ! ok, classical fortran style reuse of scratch space... ;-) part II
                          scep_ci_1(1:mu_length,1:mu_length) = zero
                          do k=1,common_virt_length
                             k_x = common_virt_lam_pos(k)
                             k_y = common_virt_mu_pos(k)
                             scep_sigma_1(1:lam_length,k_x) = scep_sigma_1(1:lam_length,k_x) + sig_nm2_lam(:,k)
                             scep_ci_1(1:mu_length,k_y) = sig_nm2_mu(:,k)
                          enddo
                          
                          !call unscepper_diag_sigma_atomic(sigma_nm2_mu,sigmavec%v,ab_mu_start,&
                          if (mode_2 .eq. 1) then
                              call unscepper_diag_sigma_atomic_p1(scep_ci_1,sigmavec,ab_mu_start,&
                                              mu_length,aa_mu_start)
                          elseif (mode_2 .eq. -1) then
                              call unscepper_diag_sigma_atomic_m12(scep_ci_1,sigmavec,ab_mu_start,&
                                              mu_length)
                          endif
  
                      enddo
                      
                      !call unscepper_diag_sigma_atomic(sigma_nm2_lambda,sigmavec%v,ab_lam_start,&
                      if (mode_1 .eq. 1) then
                          call unscepper_diag_sigma_atomic_p1(scep_sigma_1,sigmavec,ab_lam_start,&
                                         lam_length,aa_lam_start)
                      elseif (mode_1 .eq. -1) then
                          call unscepper_diag_sigma_atomic_m12(scep_sigma_1,sigmavec,ab_lam_start,&
                                         lam_length)
                      endif

                  enddo

              deallocate(ci_1_mat,ci_2_mat,sig_nm2_lam,sig_nm2_mu,scep_integral_C_save,scep_integral_EX_save,stat=deallocatestatus)
              call deallocatecheck(deallocatestatus,"two_int_seg_com_lmo_res I")

              endif
              
          endif dim2
          
      elseif (start_elec == num_elec - 1) then start_elec1        

    
          !!!!!!!!!!!!!!!!!!!!!!!!!!!
          !//
          !// INTERACTIONS BETWEEN TWO N-1
          !// STATES EACH HAVING A SINGLE
          !// VIRTUAL SINGLY OCCUPIED
          !//
          !!!!!!!!!!!!!!!!!!!!!!!!!!!

          lambda_weight = lambda_path%weight+1
          mu_weight     = lambda_path%rt_loop_weight+1
          
          lambda_singles = lambda_singles_int + 1
          mu_singles = mu_singles_int + 1
      
          lambda_dim = fsn(lambda_singles)
          mu_dim = fsn(mu_singles)
          
          dim3: if (lambda_dim /= 0.and. mu_dim /= 0) then
          
              nm1_address_1 = internal_index_vector1(lambda_path%weight+1)
              nm1_address_2 = internal_index_vector1(lambda_path%rt_loop_weight+1)
              
              if (nm1_address_1 > 0 .and. nm1_address_2 > 0) then
          
                  !// PASS IN S4=1 TO TAKE INTO ACCOUNT THE
                  !// SINGLES IN THE EXTERNAL SPACE
                  doublet_flag = 1
                  call internal_cc_driver(Px,Py,size(Px,1),loop_type,s1,s2,lambda_singles,mu_singles,doublet_flag)
 
              
                  lam_length     = num_allowed_virtuals(lambda_weight,"S") 
                  call get_virtuals_and_index(lambda_weight,"S",virt_lam_allow,jumper1)
                  
                  mu_length     = num_allowed_virtuals(mu_weight,"S") 
                  call get_virtuals_and_index(mu_weight,"S",virt_mu_allow,jumper2)
                  
                  if(jumper1 .eq. jumper2 .and. lam_length .eq. mu_length) then
                     isSymmetric = .true.
                  else
                     isSymmetric = .false.
                  endif

                  i_dum = max(lam_length,mu_length)

                  allocate(scep_integral_C_save(i_dum,i_dum),scep_integral_EX_save(i_dum,i_dum),scr_vec1(i_dum),scr_vec2(i_dum),stat=allocatestatus)
                  call allocatecheck(allocatestatus,"two_int_seg_com_lmo_res")
                  scep_integral_C_save = 0 
                  scep_integral_EX_save = 0 

                  if (loop_type == 5 .or. loop_type == 7) then 
                  do a=1,lam_length
                     a1 = virt_lam_allow(a)
                     do b=1,mu_length
                        b1 = virt_mu_allow(b)
                        x1=max(a1,b1)-num_internal
                        x2=min(a1,b1)-num_internal
                        scep_integral_C_save(b,a) = scep_integral_C(x1*(x1-1)/2+x2)
                        scep_integral_EX_save(b,a) = scep_integral_EX(b1-num_internal,a1-num_internal)
                    enddo
                  enddo
                  else
                  do b=1,mu_length
                     b1 = virt_mu_allow(b)
                     do a=1,lam_length
                        a1 = virt_lam_allow(a)
                        x1=max(a1,b1)-num_internal
                        x2=min(a1,b1)-num_internal
                        scep_integral_C_save(a,b) = scep_integral_C(x1*(x1-1)/2+x2)
                        scep_integral_EX_save(a,b) = scep_integral_EX(a1-num_internal,b1-num_internal)
                     enddo
                  enddo
                  endif

                  
                  if (loop_type == 5 .or. loop_type == 7) then
                     trans1_1 = "N"
                     trans1_2 = "T"
                     trans2_1 = "N"
                     trans2_2 = "T"
                     dimScep1 = mu_length
                     dimScep2 = lam_length
                  else
                     trans1_1 = "T"
                     trans1_2 = "N"
                     trans2_1 = "T"
                     trans2_2 = "N"
                     dimScep1 = lam_length
                     dimScep2 = mu_length
                  endif
                  
                  if (internal_index_vector1(lambda_weight) >= 0 .and. internal_index_vector1(mu_weight) >= 0) then

                  !// LOOP OVER SPIN COUPLINGS AND DO MULTIPLICATIONS                               
                  do lambda_spin = 1,lambda_dim
                  
                      nm1_start_1 = nm1_address_1+ (lambda_spin-1)*lam_length
                      nm1_end_1   = nm1_start_1   + lam_length- 1

                      scr_vec2 = zero
                      do mu_spin = 1,mu_dim
                          intsZero = .true.
                      
                          nm1_start_2 = nm1_address_2 + (mu_spin-1)*mu_length
                          nm1_end_2   = nm1_start_2   + mu_length- 1

                          if (abs(Px(lambda_spin,mu_spin)) <= integral_threshold .and.&
                              abs(Py(lambda_spin,mu_spin)) <= integral_threshold) cycle
                          
                          cc = Px(lambda_spin, mu_spin)
                          if (abs(cc) > integral_threshold) then

                            !// WE MAY HAVE TO USE THE TRANSPOSE OF THE INTEGRAL MATRIX HERE
                            !// CHECK HERE .. PLEASE 
                            
#ifdef TIGER_SGGA_SYM
                            if(isSymmetric) then
                             ! since scep_integral_C_save is symmetric, we do not need to transpose this
                             
                             if(lam_length /= mu_length) then
                                write(*,*) "symmetric assumption does not hold true! (2) ",lam_length,mu_length
                                flush(6)
                                stop
                             endif
                             
                             call dsymv("U",lam_length,cc,scep_integral_C_save,lam_length,&
                                       civec%v(nm1_start_1),1,zero, &
                                       scr_vec1,1)
                                       
                             call dsymv("U",lam_length,cc,scep_integral_C_save,lam_length,&
                                       civec%v(nm1_start_2),1,one, &
                                       scr_vec2,1)
                             
                            else ! not symmetric
#endif

                             call dgemv(trans1_1,dimScep1,dimScep2,cc,scep_integral_C_save,i_dum,&
                                       civec%v(nm1_start_1),1,zero, &
                                       scr_vec1,1)
                           
                             call dgemv(trans1_2,dimScep1,dimScep2,cc,scep_integral_C_save,i_dum,&
                                       civec%v(nm1_start_2),1,one, &
                                       scr_vec2,1)
                                   
#ifdef TIGER_SGGA_SYM
                            endif
#endif
                            intsZero = .false.
                          else
                            scr_vec1 = zero
                          endif
                                                    
                          cc = Py(lambda_spin, mu_spin)
                          if (abs(cc) > integral_threshold) then

                            !// WE MAY HAVE TO USE THE TRANSPOSE OF THE INTEGRAL MATRIX HERE
                            !// CHECK HERE .. PLEASE 
                        
                            call dgemv(trans2_1,dimScep1,dimScep2,cc,scep_integral_EX_save,i_dum,&
                                       civec%v(nm1_start_1),1,one, &
                                       scr_vec1,1)

                            call dgemv(trans2_2,dimScep1,dimScep2,cc,scep_integral_EX_save,i_dum,&
                                       civec%v(nm1_start_2),1,one, &
                                       scr_vec2,1)
                            intsZero = .false.
                          endif
                          
                          if(intsZero) cycle

#ifdef TIGER_USE_OMP
                          call setLocks(sigmavec%l,nm1_start_2,nm1_end_2)
#endif
                          sigmavec%v(nm1_start_2:nm1_end_2) = sigmavec%v(nm1_start_2:nm1_end_2) + scr_vec1(1:mu_length)
#ifdef TIGER_USE_OMP
                          call unsetLocks(sigmavec%l,nm1_start_2,nm1_end_2)
#endif
                          
                      enddo
#ifdef TIGER_USE_OMP
                      call setLocks(sigmavec%l,nm1_start_1,nm1_end_1)
#endif
                      sigmavec%v(nm1_start_1:nm1_end_1) = sigmavec%v(nm1_start_1:nm1_end_1) + scr_vec2(1:lam_length)
#ifdef TIGER_USE_OMP
                      call unsetLocks(sigmavec%l,nm1_start_1,nm1_end_1)
#endif
                      
                  enddo
                  endif

              deallocate(scep_integral_C_save,scep_integral_EX_save,scr_vec1,scr_vec2,stat=deallocatestatus)
              call deallocatecheck(deallocatestatus,"two_int_seg_com_lmo_res X")
              
              endif
              
          endif dim3
   
      endif start_elec1
      
  endif
  
  !write(*,*) "DEBUG: Exiting 3 two_int_seg_com_lmo_res..."
  !flush(6)

  !// EXIT....
  
  deallocate(common_virt,virt_lam_long,virt_lam_pos,virt_mu_long,virt_mu_pos,&
                                   common_virt_lam_pos,common_virt_mu_pos,stat=status)
  call deallocatecheck(status,"two_int_seg_com_lmo_res")
  
end subroutine two_int_seg_com_lmo_res 
!**************************************************************************
!*****************************************************************
subroutine do_nm2_v_multiplications_3_lmo(civec, sigmavec, ab_address,v_address,&
                                      aa_address,&
                                      nm2_dim,v_dim,&
                                      aa_dim,&
                                      cc,lambda_weight,&
                                      loop_type,scep_integral_EX, cho_data, i, j)  

  use iajb_mod, only : makeOneIAJB

  !// THIS SUBROUTINE WILL TAKE CARE OF HTIMESC MULTIPLICATIONS FOR
  !// N-2 AND VALENCE STATES.  
                                     
  !!!!!!!!!!!!!!!!!!!!!!!!!!!  VARIABLE DECLARATION !!!!!!!!!!!!!!!!!!!!!!!!!!!                                   
  implicit none
  
  real(real8),dimension(:,:),intent(inout)::scep_integral_EX
  real(real8),dimension(:,:),intent(in)::cc        !// COUPLING COEFFICIENTS
  integer,intent(in)::lambda_weight
  integer,intent(in)::loop_type 
  type(blockedLockVectorType),intent(inout):: civec, sigmavec
  integer,intent(in)::i,j
  type(cholesky_data),intent(in)::cho_data
  
  integer,intent(in)::ab_address, v_address         !// ADDRESSES OF N-2 AND VALENCE STATES
  integer,intent(in)::aa_address
  integer,intent(in)::nm2_dim,     v_dim             !// SPIN SPACE DIMENSIONS
  integer,intent(in)::aa_dim
  
  integer::nm2_spin, v_spin               !// FOR LOOPING OVER SPIN FUNCTIONS
  integer::ab_start,aa_start
  integer::v_start
  integer::lam_length,lam_lengthC2
  integer::a,b
  integer::a1,b1

  integer::mode_1
  
  real(real8)::cc_element                 !// ELEMENT OF COUPLING COEFFICIENT ARRAY

  real(real8),parameter::sqrt2 = real(sqrt(real(2.0,real8)), real8)
  real(real8),dimension(:,:),allocatable::scep_integral_EX_save
  real(real8),dimension(:,:),allocatable::scep_ci_1,scep_sigma_1
  integer,dimension(:),allocatable::virt_lam_allow
  real(real8),dimension(:),allocatable::tmp_arr
  real(real8)::tmpint
  real(real8),external::ddot
  integer::allocatestatus,deallocatestatus

!/////////////////////////////////////////////////////////////////
  
  !!!!!!!!!!!!!!!!!!!!!!!!!!! START OF ROUTINE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  !// PUT THE REQUIRED INTEGRALS 
  lam_length     = num_allowed_virtuals(lambda_weight,"D")
  lam_lengthC2 = lam_length*(lam_length-1)/2
  
  allocate(scep_integral_EX_save(1:lam_length,1:lam_length), &
  scep_ci_1(1:lam_length,1:lam_length),scep_sigma_1(1:lam_length,1:lam_length),virt_lam_allow(1:lam_length), &
  tmp_arr(v_dim),stat=allocatestatus)
  call allocatecheck(allocatestatus,"ingrl_saves")
  
  call get_virtuals(lambda_weight,"D",virt_lam_allow)
        
  if(.false.) then
  
    do a=1,lam_length 
       a1 = virt_lam_allow(a)
       do b=1,lam_length 
          b1 = virt_lam_allow(b)
          tmpint = scep_integral_EX(a1-num_internal,b1-num_internal)
          if(tmpint == magic_number) then
            ! compute
            tmpint = makeOneIAJB(i,a1,j,b1,cho_data)
            ! store
            scep_integral_EX(a1-num_internal,b1-num_internal) = tmpint
          endif
          scep_integral_EX_save(a,b) = tmpint
      enddo
    enddo
  else
    do a=1,lam_length 
       a1 = virt_lam_allow(a)
       do b=1,lam_length 
          b1 = virt_lam_allow(b)
          scep_integral_EX_save(a,b) = scep_integral_EX(a1-num_internal,b1-num_internal)
      enddo 
    enddo
  endif
  
  if (loop_type /= 4) scep_integral_EX_save = transpose(scep_integral_EX_save)
        
  !// LOOP OVER PAIRS OF SPIN FUNCTIONS
  tmp_arr = 0.0
  do nm2_spin = 1, nm2_dim

       if (internal_index_vector2(lambda_weight) < 0) cycle

       ab_start   = ab_address+lam_lengthC2*(nm2_spin-1)
       aa_start   = aa_address + lam_length*(nm2_spin-1)

       mode_1 = -1
       if (nm2_spin <= aa_dim) mode_1 = 1

       if (mode_1 .eq. 1) then
           call scepper_diag_p1(scep_ci_1,civec%v,ab_start,lam_length,civec%v,aa_start)
       elseif (mode_1 .eq. -1) then
           call scepper_diag_m1(scep_ci_1,civec%v,ab_start,lam_length)
       endif

       do v_spin = 1, v_dim
      
          v_start    = v_address+v_spin-1
          
          cc_element = cc(nm2_spin, v_spin)
          if (abs(cc_element) <= integral_threshold)  cycle
          
          ! there used to be a diffrent logic based on nm2_spin <= aa_dim (SINGLET vs TRIPLET case)
          ! which only used a different matrix (intgrl_sin_save vs scep_integral_EX_save) for the
          ! pseudo dot product. That being said, the caller indeed used two different matrices
          ! but filled them with the same matrix. After inspection, DBK and I (JMD) decided that
          ! we can axe that behavior and save some intermediate matrices and operations.
          scep_sigma_1(:,:) = cc_element*civec%v(v_start)*scep_integral_EX_save(:,:)
          tmp_arr(v_spin) = tmp_arr(v_spin) + cc_element*ddot(lam_length*lam_length,scep_integral_EX_save,1,scep_ci_1,1)
         
#ifdef DEBUG_TIGER
          if(ab_start+lam_length-1 > total_csfs .or. ab_start+lam_length-1 > size(sigmavec%v,1)) then
            write(*,*) "DEBUG: Trying to write outside sigmavec%vtor. Information coming..."
            write(*,*) "DEBUG: ",ab_start,lam_length,total_csfs
            write(*,*) "DEBUG: ",lambda_weight
            write(*,*) "DEBUG: ",size(sigmavec%v,1)
            flush(6)
            stop
          endif
#endif
          if (mode_1 .eq. 1) then
              call unscepper_diag_sigma_atomic_p1(scep_sigma_1,sigmavec,ab_start,lam_length,aa_start)
          elseif (mode_1 .eq. -1) then
              call unscepper_diag_sigma_atomic_m12(scep_sigma_1,sigmavec,ab_start,lam_length)
          endif

      enddo
  enddo
#ifdef TIGER_USE_OMP
  !call setSigmaLocks(v_address,v_address+v_dim-1)
  call setLocks(sigmavec%l,v_address,v_address+v_dim-1)
#endif
  sigmavec%v(v_address:v_address+v_dim-1) = sigmavec%v(v_address:v_address+v_dim-1) + tmp_arr
#ifdef TIGER_USE_OMP
  !call unsetSigmaLocks(v_address,v_address+v_dim-1)
  call unsetLocks(sigmavec%l,v_address,v_address+v_dim-1)
#endif

  deallocate(scep_ci_1,scep_sigma_1,scep_integral_EX_save,virt_lam_allow,tmp_arr,stat=deallocatestatus)
  call deallocatecheck(deallocatestatus,"ingrl_saves")
                                     
end subroutine do_nm2_v_multiplications_3_lmo
!*****************************************************************
end module three_and_four_seg_mod_2

