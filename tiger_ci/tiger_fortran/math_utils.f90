! This Source Code Form is subject to the terms of the Mozilla Public
! License, v. 2.0. If a copy of the MPL was not distributed with this
! file, You can obtain one at http://mozilla.org/MPL/2.0/.
!************************************************************
!> \brief A module which contains some high level math utilities
!>
!> \author David Krisiloff
!> \date   12/17/2010
!>
!>            This module is basically a collection of random math
!>            utilities used in TigerCI. A few pieces of linear algebra
!>            code and a few LAPACK wrappers. Putting everything into one
!>            module makes it easier to organize and check interfaces
!>            (as opposed to how we were previously doing it, with many,
!>            many files)
!> 
!> NOTE !!! All the LAPACK wrappers here assume that we are using a LAPACK 
!> library with 32bit ints. If we are using 64bit ints in the LAPACK routines
!> all these types need to change. 

module math_utils
  use global_var_mod, ONLY: real8
  use utilities_mod
  implicit none

#ifdef TIGER_LAPACK_INT4
  integer, parameter :: LAPACK_INT=4
#else
  integer, parameter :: LAPACK_INT=8
#endif

contains

  function isMatrixSymmetric(matrix,threshold)
    implicit none
    logical::isMatrixSymmetric
    real(real8),dimension(:,:),intent(in):: matrix
    real(real8),intent(in)::threshold
    integer::dim1,dim2,i,j

    isMatrixSymmetric = .false.

    dim1 = size(matrix,1)
    dim2 = size(matrix,2)

    ! test if matrix is square
    if(dim1 /= dim2) return

    do i = 1, dim1-1
       do j = i+1, dim1
          if(abs(matrix(i,j)-matrix(j,i)) > threshold) then
             write(ioOutput,*) "SYMMETRY: Mismatch for i/j of size ",i,j,abs(matrix(i,j)-matrix(j,i))
             return
          endif
       enddo
    enddo

    isMatrixSymmetric = .true.

  end function isMatrixSymmetric


  !> \brief canonically orthogonalize the AO basis (see Szabo and Ostlund)
  !> \author ? 
  subroutine canonical_orthogonalize(overlap,X_matrix,num_basis,num_dependencies)

    !
    ! canonically orthogonalize the
    ! AO basis; the orthogonalized vectors
    ! will be used subsequently as a basis
    ! for diagonalization of the complex
    ! Fock matrix (i.e. with an absorbing
    ! potential); see the book of Szabo and
    ! Ostlund for additional description
    !

    implicit none

    integer, parameter::real8 = selected_real_kind(15,307)

    integer::num_basis          ! dimension of overlap matrix
    integer::i,j,k              ! loop control variables
    integer::num_dependencies   ! number of linear dependencies found in orthogonalization


    real(kind=real8)::eigenvalue_thresh ! if eigenvalues are below a certain threshold, don't
    ! use the corresponding eigenvector
    real(kind=real8)::s_value_12        ! square root of eigenvalue

    real(kind=real8), dimension(num_basis,num_basis)::overlap   ! input overlap matrix to be orthogonalized
    real(kind=real8), dimension(num_basis,num_basis)::X_matrix  ! output diagonalizing transformation matrix
    real(kind=real8), dimension(:,:), allocatable::S_vectors    ! eigenvectors of overlap
    real(kind=real8), dimension(:), allocatable::S_values       ! eigenvalues of S

    allocate(S_vectors(num_basis,num_basis),&
         S_values(num_basis))
    ! AUTOGENERATED INITALIZATION
    s_vectors = 0.0
    s_values = 0.0
    ! END AUTOGENERATED INITIALIZATION 

    !
    ! first step is diagonalization of S
    !
    call diagonalize_real_symmetric(overlap,S_values,S_vectors,num_basis)

    !
    ! load up X matrix
    !
    eigenvalue_thresh = 1.0d-04
    j = 0
    num_dependencies = 0
    do i = 1,num_basis

       if (S_values(i) < 0 .or. abs(S_values(i)) < eigenvalue_thresh) then
          num_dependencies = num_dependencies + 1
          cycle
       endif

       j = j + 1

       s_value_12 = sqrt(S_values(i))
       do k = 1, num_basis
          X_matrix(k,j) = S_vectors(k,i)/s_value_12
       enddo

    enddo

    !
    ! cleanup
    !
    deallocate(S_vectors,S_values)
  end subroutine canonical_orthogonalize

  !> \brief Performs gram-schmidt orthogonalization on a set of vectors
  !> \author Jeremy Chwee
  !> \author Johannes M Dieterich
  !> \param num_vec Number of vectors
  !> \param num_bas Number of basis functions (length of the vectors)
  !> \param vec     Matrix containing the vectors (stored in columns), on exit contains orthogonalized vectors
  !> \param overlap_mat Overlap matrix for the basis functions 
  subroutine little_gs_fast(num_vec,num_bas,vec,overlap_mat)

    implicit none
    integer:: i,j
    integer,intent(in)::num_vec,num_bas

    real(kind=real8),dimension(num_vec,num_bas),intent(inout)::vec
    real(kind=real8),dimension(num_bas)::temp_vec
    real(kind=real8),dimension(num_bas,num_bas), intent(in)::overlap_mat
    real(kind=real8)::rdummy
    real(kind=real8),external::ddot
    ! This is a modified Gram Schmidt orthogonalization routine
    ! Input k vectors,overlap matrix. Output k orthonormal vectors

    !write(*,*) "GS overlap matrix: "
    !write(*,*) overlap_mat
    !write(*,*) "GS vec matrix: "
    !write(*,*) vec

    write(*,*) "num_vec = ", num_vec
    write(*,*) "num_bas = ", num_bas
    flush(6)

    do i = 1, num_vec
       call dgemv('N',num_bas,num_bas,1.0,overlap_mat,num_bas,vec(1,i),1,0.0,temp_vec,1)
       rdummy = ddot(num_bas,vec(1,i),1,temp_vec,1)
       vec(:,i) = vec(:,i)/sqrt(rdummy)
       call dgemv('N',num_bas,num_bas,1.0,overlap_mat,num_bas,vec(1,i),1,0.0,temp_vec,1)
       do j = i+1,num_vec
          rdummy = ddot(num_bas,vec(1,j),1,temp_vec,1)
          vec(:,j) = vec(:,j) - rdummy*vec(:,i)
       enddo
    enddo

    !write(*,*) "GS orthogonalized matrix: "
    !write(*,*) vec

  end subroutine little_gs_fast


  !> \brief Diagonalize matrix by solving for the eigenvalues, looks for linear dependencies
  !> \author Jeremy Chwee
  !> \author Johannes M Dieterich
  !> \param overlap Input overlap matrix to be diagonalized
  !> \param eigenvectors On exit contains eigenvectors of overlap
  !> \param eigenvalues  On exit contains the eigenvalues of the overlap matrix
  !> \param num_basis    Number of basis functions
  !> \param num_dependencies On exit number of linear dependencies found
  !> \param opt              1 = Normal , 2 = Form inverse of the overlap matrix
  subroutine little_ortho(overlap,eigenvectors,eigenvalues,num_basis,num_dependencies,opt)

    implicit none

    integer, parameter::real8 = selected_real_kind(15,307)

    integer,intent(in)::num_basis          ! dimension of overlap matrix
    integer::i                  ! loop control variables
    integer,intent(out)::num_dependencies   ! number of linear dependencies found in orthogonalization
    integer::opt                ! returns the inverse square root of the input matrix instead
    integer,dimension(num_basis)::temp_ivec

    real(kind=real8)::eigenvalue_thresh ! if eigenvalues are below a certain threshold, don't
    ! use the corresponding eigenvector

    real(kind=real8), dimension(num_basis,num_basis)::overlap   ! input overlap matrix to be orthogonalized
    real(kind=real8), dimension(num_basis,num_basis)::eigenvectors   ! eigenvectors of overlap
    real(kind=real8), dimension(num_basis)::eigenvalues ! eigenvalues of S
    real(kind=real8), dimension(num_basis,num_basis):: temp_mat,temp_mat2
    real(kind=real8), dimension(num_basis):: temp_vec

    if (opt .eq. 1) then

       !
       ! call diagonalization routine A = UA(U-1)
       ! the output eigenvectors correspond to U
       !call rs(num_basis,num_basis,overlap,eigenvalues,matz,eigenvectors,fv1,fv2,ierr)
       !write(*,*) "Overlap matrix we are working on (opt=1): "
       !write(*,*) overlap
       call diagonalize_real_symmetric(overlap,eigenvalues,eigenvectors,num_basis)

       eigenvalue_thresh = 1.0d-04
       num_dependencies = 0
       do i = 1,num_basis
          if (eigenvalues(i) < 0 .or. abs(eigenvalues(i)) < eigenvalue_thresh) then
             num_dependencies = num_dependencies + 1
             cycle
          endif
       enddo

    else if (opt .eq. 2) then
       ! Revision
       ! Form the inverse of the matrix

       temp_mat = overlap ! Don't corrupt the input matrix
       !write(*,*) "Overlap matrix we are working on (opt=2): "
       !write(*,*) temp_mat
       call dgetrf(num_basis,num_basis,temp_mat,num_basis,temp_ivec,i)
       call dgetri(num_basis,temp_mat,num_basis,temp_ivec,temp_vec,num_basis,i)

       !
       ! call diagonalization routine A = UA(U-1)
       ! the output eigenvectors correspond to U
       call diagonalize_real_symmetric(temp_mat,eigenvalues,eigenvectors,num_basis)

       temp_mat2 = 0
       do i = 1, num_basis
          eigenvalues(i) = sqrt(eigenvalues(i))
          temp_mat2(i,i) = eigenvalues(i)
       enddo

       call dgemm("N","T",num_basis,num_basis,num_basis,1.0,temp_mat2,num_basis,eigenvectors,num_basis,0.0,temp_mat,num_basis)

       ! This is the inv_sqrt matrix
       call dgemm("N","N",num_basis,num_basis,num_basis,1.0,eigenvectors,num_basis,temp_mat,num_basis,0.0,temp_mat2,num_basis)

       eigenvectors = temp_mat2

    endif
  end subroutine little_ortho



  !> \brief Wrapper for eispack eigenvalue solver rs (real symmetric)
  !> \author ?
  !> \author Johannes M Dieterich
  !> \param input_matrix Matrix to be diagonalized
  !> \param eigenvalues  On exit matrix containing the eigenvalues
  !> \param eigenvectors On exit vector containing the eigenvectors
  !> \param n            size of input matrix
  subroutine diagonalize_real_symmetric(input_matrix,eigenvalues,eigenvectors,n)
    implicit none

    !
    ! input
    !
    integer::n                    ! size of input matrix
    Real(kind=real8)::input_matrix(n,n)     ! input matrix to diagonalize

    !
    ! output
    !
    Real(kind=real8)::eigenvectors(n,n)     ! output eigenvectors
    Real(kind=real8)::eigenvalues(n)        ! output eigenvalues
    !

    ! copy the input matrix into our "eigenvectors" matrix
    eigenvectors(:,:)=input_matrix(:,:)
    ! call DSYEV through the wrapper
    call dsyev_wrapper(.false., .true., n, eigenvectors, n, eigenvalues)

  end subroutine diagonalize_real_symmetric

  !> \brief Wrapper for LAPACK generalized eigenvalue (Ax =eBx) solver DSYGB (real symmetric)
  !> \author David Krisilof
  !> \date 12/20/2012
  !> \param eig_only If true only calculates the eigenvalues (not eigenvectors)
  !> \param lower    If true access the lower triangular parts of A and B (as opposed to the upper triangular parts)
  !> \param n        Order of A and B
  !> \param A        The matrix A (on exit contains the eigenvectors if eig_only == .false.)
  !> \param lda      Leading dimension of A  (A is A(lda,n))
  !> \param B        The matrix B
  !> \param ldb      Leading dimension of B (B is B(ldb,n))
  !> \param eigval   On exit contains the eigenvalues
  subroutine dsygv_wrapper(eig_only, lower, n, A, lda, B, ldb, eigval)
    implicit none

    ! inputs
    integer, intent(in) :: n, lda, ldb
    logical, intent(in) :: eig_only, lower
    real(kind=real8) :: A(:,:), B(:,:), eigval(:)

    ! local variables
    integer :: ierr
    integer(kind=LAPACK_INT) :: n4, lda4, ldb4, ierr4, work_size4
    real(kind=real8), allocatable :: work(:), err_copy_a(:,:), err_copy_b(:,:)
    character :: uplo, jobz

    ! set the job (eigenvalues only or include eigenvectors)
    jobz = 'V'
    if (eig_only) jobz = 'N'

    ! set the matrix packing (lower or upper)
    uplo = 'U'
    if (lower) uplo = 'L'

    ! make a copy of the matrix in case there is an error
    allocate(err_copy_a(n,n), err_copy_b(n,n))
    err_copy_a(1:n,1:n) = A(1:n,1:n)
    err_copy_b(1:n,1:n) = B(1:n,1:n)


    ! Convert the numbers in case the LAPACK interface uses a different integer size than what we default to
    n4 = int(n,LAPACK_INT)
    lda4 = int(lda,LAPACK_INT)
    ldb4 = int(ldb,LAPACK_INT)
    ierr4 = int(0,LAPACK_INT)

    ! allocate memory for the scratch space
    work_size4 = int(30,4) * n4
    allocate(work(work_size4),stat=ierr)
    call allocatecheck(ierr, "dsygv_wrapper")

    ! run DSYGV
    call DSYGV(1, jobz, uplo, n4, A, lda4, B, ldb4, eigval, work, work_size4, ierr4)
    if ( ierr4 /= 0 ) then
       write(*,*) "Error in DSYGV during diagonalization, error code =" , ierr4
       call error_matrix_write(err_copy_a, "A", 6)
       call error_matrix_write(err_copy_b, "B", 6)
       stop
    end if

    deallocate(work, err_copy_a, err_copy_b)      

  end subroutine dsygv_wrapper

  !> \brief Writes out a matrix in a format that makes it easy to copy into matlab. Useful for 
  !> printing out a matrix when something goes wrong
  subroutine error_matrix_write(matrix, name, unit)
    implicit none
    integer(kind=8), intent(in) :: unit
    character(len=*) , intent(in) :: name
    real(kind=real8), intent(in) :: matrix(:,:)
    integer :: i, j

100 format(/,/)
101 format("---------------")
102 format("   ",f30.20)
    write(unit,100)
    write(unit,*) "  ", name
    write(unit,101)
    do i = 1, size(matrix,2)
       do j = 1, size(matrix,1)
          write(unit,102) matrix(j,i)
       end do
    end do
    write(unit,100) 
  end subroutine error_matrix_write

  !> \brief Writes out a matrix in a format that makes it easy to copy into matlab. Useful for     
  !> printing out a matrix when something goes wrong                          
  subroutine error_cube_write(matrix, name, unit)
    implicit none
    integer(kind=8), intent(in) :: unit
    character(len=*) , intent(in) :: name
    real(kind=real8), intent(in) :: matrix(:,:,:)
    integer :: i, j, k

100 format(/,/)
101 format("---------------")
102 format("   ",f24.15)
    write(unit,100)
    write(unit,*) "  ", name
    write(unit,101)
    do i = 1, size(matrix,3)
       do j = 1, size(matrix,2)
          do k = 1, size(matrix,1)
             write(unit,102) matrix(k,j,i)
          end do
       end do
    end do
    write(unit,100)
  end subroutine error_cube_write

  !> \brief Wrapper for LAPACK eigenvalue solver dsyev (real symmetric)
  !> \author David Krisiloff
  !> \date   12/20/2012
  !> \param eig_only   Ask for eigenvalues only (instead of eigenvals and eigenvectors) (logical)
  !> \param lower      The lower triangular part of the matrix is stored (logical)
  !> \param N          Order of matrix A
  !> \param A          The matrix we are going to diagonalize (on exit contains the eigenvectors)
  !> \param LDA        The leading dimension of A
  !> \param eigval     On exit contains the eigenvalues
  !> 
  !> Note that all this code really does is hide the type issues (we use default int*8, LAPACK wants int*4)
  !> If you want a more abstract routine try diagonalize_real_symmetric.
  subroutine dsyev_wrapper(eig_only, lower, N, A, LDA, eigval)
    implicit none

    ! inputs
    logical, intent(in)  :: eig_only, lower
    integer, intent(in) :: N, LDA
    real(kind=real8) :: A(:,:), eigval(:)

    ! local variables
    integer(kind=LAPACK_INT) :: N4, work_size4, ierr4, LDA4 
    integer :: ierr
    real(kind=real8), allocatable :: work(:), err_copy_a(:,:)
    character :: uplo, jobz

    ! set the job (eigenvalues only or include eigenvectors)
    jobz = 'V'
    if (eig_only) jobz = 'N'

    ! Set the matrix packing (lower or upper)
    uplo = 'U'
    if (lower) uplo = 'L'

    ! make a copy of A just in case we need to print it out on an error condition
    allocate(err_copy_a(1:n,1:n))
    err_copy_a(1:n,1:n) = A(1:n,1:n)

    ! Convert the numbers in case the LAPACK interface uses a different integer size than what we default to
    N4 = int(N,LAPACK_INT)
    LDA4 = int(LDA,LAPACK_INT)
    ierr4 = 0
    work_size4 = int(30,LAPACK_INT) * N4

    ! Allocate some workspace ... size is a bit arbitrary
    allocate(work(work_size4),stat=ierr)
    call allocatecheck(ierr, "work array in dsyev_wrapper")

#ifdef DEBUG_TIGER
    write(*,*) "DSYEV WRAPPER DEBUG INFO"
    write(*,*) "- - - - - - - - - - - - -"
    write(*,*) "  is work allocated? ", allocated(work)
    write(*,*) "  JOBZ      = " , JOBZ
    write(*,*) "  UPLO      = " , UPLO
    write(*,*) "  N         = " , N4
    write(*,*) "  LDA       = " , LDA4
    write(*,*) "  work_size = " , work_size4
    write(*,*) "  actual work size = " , size(work)
    write(*,*) "  actual size of A = " , size(A)
    write(*,*) " "
    call flush(6) 
#endif

    ! Call DSYEV
    call DSYEV(JOBZ, UPLO, N4, A, LDA4, eigval, work, work_size4, ierr4)
    if ( ierr4 /= 0 ) then
       write(*,*) "Error in dsyev during diagonalization, error code =" , ierr4
       write(*,*) "Matrix we were attempting to diagonalize  was "
       call error_matrix_write(A, "A", 6)
       stop
    end if

    deallocate(work)

  end subroutine dsyev_wrapper

  !> brief Calculates the distance between 2 points in 3D space
  function distance(vec1,vec2)
    !// DISTANCE BETWEEN TWO POINTS
    real(real8)::distance
    real(real8), dimension(3)::diff_vec
    real(real8), dimension(3),intent(in)::vec1,vec2
    diff_vec = vec2-vec1
    distance = sqrt(dot_product(diff_vec,diff_vec))
  end function distance

  !> \brief Wrapper for the LAPACK pivoted cholesky decomposition routine DPSTF2
  !> \param A The matrix to be decomposed
  !> \param n Size of n
  !> \param P On exit contains the permutation matrix used for the pivoted decomposition
  !> \param nCho The effective rank of A after decomposition
  !> \param tol  Numerical tolerance (stopping criteria) for the incomplete cholesky decomposition
  subroutine dpstf2_wrapper(A, n, P, nCho, tol)
    implicit none

    ! inputs
    real(kind=8) :: tol, A(:,:)
    integer :: n, nCho, P(:)

    ! local variables
    integer(kind=LAPACK_INT) :: n4, rank4, ierr4
    integer(kind=LAPACK_INT), allocatable, dimension(:) :: piv4(:)
    real(kind=real8), dimension(:), allocatable :: scratch
    character :: uplo

    ! decomposition code (LAPACK)
    external :: dpstrf
    external :: dpstf2

    ! The reason I have a whole function for this is just because of the 
    ! weird type issues I have been having. The interface requires int(kind=LAPACK_INT)
    ! for it to work.
    n4 = int(n,LAPACK_INT)
    uplo = 'L'
    ierr4  = 0
    allocate(scratch(n*2), piv4(n))
    scratch = 0 
    piv4 = 0
    rank4 = 0

    ! Ask LAPACK to do a pivoted CD on a positive semi-definite matrix
    ! for some reason on sesame DPSTF2 is working significantly faster than DSPTRF (????)

    call dpstf2(uplo, n4, A, n4, piv4, rank4, tol, scratch, ierr4)

    ! Produce a bit of output about what happened
    write(*,*)  " "
    write(*,*) "=== cholesky factorization ==="
    write(*,*) "CD threshold = " , tol
    if ( ierr4 < 0 ) then 
       write(*,*) "DPSTRF reports error # " ,ierr4 
       write(*,*) "FATAL ERROR in cholesky decomposition"
       stop
    else if ( ierr4 > 0) then
       write(*,*) "DPSTRF completed the pivoted cholesky decomposition"
       write(*,*) "effective rank of the two-electron integrals = ", rank4
    else
       write(*,*) "DPSTRF reports status of 0"
    end if

    ! Before finishing up , recast back to my default int type
    nCho = int(rank4,8)
    P = int(piv4,8)

    deallocate(scratch, piv4)

  end subroutine dpstf2_wrapper

end module math_utils
