! This Source Code Form is subject to the terms of the Mozilla Public
! License, v. 2.0. If a copy of the MPL was not distributed with this
! file, You can obtain one at http://mozilla.org/MPL/2.0/.
module iajb_mod
use IOBuffer
contains
  subroutine make_iajb(cho_data)
    ! A subroutine to construct the (ia|jb) integrals for the sigmavector routines

    use global_var_mod
    use molecule_var_mod
    use cholesky_structs
    use wp_tov_mod
    use sort_utils
    use io_unit_numbers
#ifdef TIGER_USE_OMP
    use omp_lib
#endif
    use c_sort_finterface

    implicit none

    integer::a,b,c,d ! orbital indices
    integer::i,j
    integer::max_ia
    integer::i1,a1
    integer::ij_ind,ab_ind
    integer::ia_count,ia_count2,ia_count3,ab_count
    integer::icount      
    integer::idum,idum2    
    integer::ij_pairs,ia_pairs
    integer::rec_count,rec_count2
    integer::block_len
    integer::block_size,max_block_size
    integer::allocatestatus,deallocatestatus
    integer::length_unf,ioerr
    integer,dimension(num_internal,num_internal)::ij_block
    integer,dimension(:),allocatable::i_ind,a_ind,ij_step,iajb_bl_vec
    integer::imax
    integer,dimension(:),allocatable::ivec,ivec2,ivec3

    real(real8),allocatable,dimension(:,:)::ia_cho
    real(real8),allocatable,dimension(:)::rvec
    real(real8),dimension(numcho)::jb_vec

    real(kind=real8), external::ddot ! BLAS1 (dot product)

    logical::transform_int  ! Decides if we need to transform integrals
    type(cholesky_data)::cho_data
    integer::threadID

#ifdef TIGER_USE_OMP
    threadID = OMP_get_thread_num()+1
#else
    threadID = 1
#endif

    ! START AUTOGENERATED INITIALIZATION 
    max_ia = 0
    block_len = 0
    ia_pairs = 0
    i1 = 0
    ia_count2 = 0
    ab_ind = 0
    block_size = 0
    a = 0
    b = 0
    d = 0
    i = 0
    j = 0
    idum2 = 0
    ia_count = 0
    transform_int = .false.
    icount = 0
    imax = 0
    rec_count2 = 0
    allocatestatus = 0
    c = 0
    jb_vec = 0.0
    ab_count = 0
    rec_count = 0
    deallocatestatus = 0
    ia_count3 = 0
    ij_pairs = 0
    max_block_size = 0
    ij_ind = 0
    ij_block = 0
    a1 = 0
    idum = 0
    ! END AUTOGENERATED INITIALIZATION 
    !*******************************************************************************

    ij_pairs = 0  ! Number of kept (ij) pairs
    ij_block = 0  ! Number of (ia|jb) integrals in each (ij) block
    ab_count = 0


    inquire(iolength=length_unf) number_bas
    open(unit=iajb_ind_no,file=scratch_directory // 'iajb_ind.dat',access='direct',recl=length_unf,form='unformatted',iostat=ioerr)
    if ( ioerr /= 0 ) then
       write(*,*) "Error opening a file in make_iajb.f90"
    end if

    max_block_size = 0
    do i = 1,num_internal
       do j = 1,i-1

          if (ignorable_pair(i,j) ) cycle

          ij_pairs = ij_pairs + 1 
          ab_count = 0 

          do a = num_internal+1,num_orbitals
             if (ignorable_pair(i,a) ) cycle
             if (ignorable_pair(j,a) ) cycle

             do b = num_internal+1,num_orbitals
                if (ignorable_pair(i,b) ) cycle
                if (ignorable_pair(j,b) ) cycle
                if (ignorable_pair(a,b) ) cycle

                ab_count = ab_count + 1

             enddo
          enddo
          ij_block(i,j) = ab_count ! # of (ia|jb) integrals in this (ij) block
       enddo
    enddo

    allocate(iajb_bl_vec(ij_pairs),stat=allocatestatus)

    ! Record block size before cumulative counter

    max_block_size = 0
    a = 0
    do i = 1, num_internal
       do j = 1,i-1

          if (ignorable_pair(i,j) ) cycle
          a = a + 1

          idum = ij_block(i,j)
          iajb_bl_vec(a) = idum
          if (idum .gt. max_block_size) max_block_size = idum 

       enddo
    enddo

    icount = 0 
    do i = 1,num_internal
       do j = 1,i-1
          if (ij_block(i,j) .eq. 0) cycle
          idum = ij_block(i,j)
          ij_block(i,j) = icount 
          icount = icount + idum 
       enddo
    enddo

    ! Count # of (ia) pairs
    ia_pairs = 0
    do i = 2,num_internal
       do a = num_internal+1,num_orbitals
          if (ignorable_pair(i,a) ) cycle
          ia_pairs = ia_pairs + 1
       enddo
    enddo


    !******************************************************************************
    ! Set a maximum buffer size 
    max_ia = int(max_mem_ints/numcho)
    max_ia = max_ia - 1

    !******************************************************************************

    !  allocate(ia_cho(max_ia,numcho),stat=allocatestatus)
    allocate(ia_cho(numcho,max_ia),stat=allocatestatus)
    allocate(i_ind(max_ia),stat=allocatestatus)
    allocate(a_ind(max_ia),stat=allocatestatus)
    allocate(ij_step(num_internal*(num_internal-1)/2),stat=allocatestatus) ! Is max_ia the correct size?
    ij_step = 0 ! To keep the offset position of each ic block on disk

    allocate(rvec(max_ia),stat=allocatestatus)
    rvec = 0.0
    allocate(ivec(max_ia),ivec2(max_ia),stat=allocatestatus)
    ivec = 0
    ivec2 = 0

    !******************************************************************************
    ! Construct the (ia|jb) integrals. Buffered version.
    ! Step 1; Read max block of (ia) buffer
    ! Step 2: Go to work construct all (ia|jb) integrals with (ia) block. 
    ! Step 3: Get new (ia) block and repeat till all (ia) blocks are exhausted
    ! Step 4: Resort (ia|jb) 

    transform_int = .false.

    ia_count = 0           
    ia_count2 = 0    
    ia_count3 = 0
    rec_count = 0
    rec_count2 = 0
    block_len = 0

    do i = 2,num_internal
       imax = i
       do a = num_internal+1,num_orbitals
          if (ignorable_pair(i,a) ) cycle

          idum = a*(a-1)/2+i
          idum = cho_data%mo_ind_inv(idum)

          ! Read in max {ia} block   
          ia_count = ia_count + 1   ! For counting ia_index in (ia) buffer
          ia_count2 = ia_count2 + 1 ! Actual progress of ia loop

          if (idum .ne. 0) then
             call for_double_buf_readblock(mo_int_no, idum, ia_cho(1:numcho,ia_count), threadID)
             !read(unit=mo_int_no,rec=idum) ia_cho(1:numcho,ia_count)
          endif

          i_ind(ia_count) = i
          a_ind(ia_count) = a

          if (ia_count .eq. max_ia) then ! Buffer is now full or everything has been read into buffer
             transform_int = .true.   ! Go to transform integrals portion because buffer is full
             block_len = max_ia
          endif

          if (ia_count2 .eq. ia_pairs) then ! Everything has been read into buffer
             transform_int = .true.   ! Go to transform integrals portion because buffer is full
             block_len = ia_count 
          endif


          !*************************************************************************************** 
          if (transform_int) then ! (ia) buffer is full. Use them to construct (ia|jb) integrals

             do j =1,imax-1 ! We will construct all the (ia|jb) integrals for the current (ia) block

                do b = num_internal+1,num_orbitals

                   if (ignorable_pair(j,b) ) cycle

                   jb_vec = 0.0D0

                   idum = b*(b-1)/2+j
                   idum = cho_data%mo_ind_inv(idum)

                   if (idum .ne. 0) then
                      call for_double_buf_readblock(mo_int_no, idum, jb_vec(1:numcho), threadID)
                      !read(unit=mo_int_no,rec=idum) jb_vec(1:numcho)
                   endif

                   idum2 = 0
                   ia_count3 = 0
                   rvec = 0.0D0 

                   do d = 1,block_len

                      ia_count3 = ia_count3 + 1
                      i1 = i_ind(ia_count3) 
                      a1 = a_ind(ia_count3)

                      if (j .ge. i1) cycle ! exit ?

                      if (ignorable_pair(i1,b) ) cycle
                      if (ignorable_pair(i1,j) ) cycle 
                      if (ignorable_pair(a1,b) ) cycle
                      if (ignorable_pair(a1,j) ) cycle

                      ij_ind = (i1-1)*(i1-2)/2+j ! cpd index
                      ab_ind = (a1-1)*num_orbitals+b

                      idum2 = idum2 + 1

                      ij_step(ij_ind) = ij_step(ij_ind) + 1 ! Don't misplace this line

                      ivec(idum2) = ij_block(i1,j) + ij_step(ij_ind)

                      ivec2(idum2) = ab_ind
                      rvec(idum2) = ddot(numcho,ia_cho(1:numcho,ia_count3),1,jb_vec(1:numcho),1)
                   enddo

                   do c = 1,idum2
                      rec_count = ivec(c)
                      call for_double_buf_writeElement(cd_iajb_unsorted_no,rec_count,rvec(c),threadID)
                   enddo


                   do c = 1,idum2               ! record cpd indexes
                      rec_count = ivec(c)
                      write(unit=iajb_ind_no,rec=rec_count) ivec2(c)
                   enddo

                enddo
             enddo

             transform_int = .false.  ! Reset to false when (ia) buffer is exhausted
             i_ind = 0 
             a_ind = 0
             ia_cho = 0.0D0
             ia_count = 0

          endif ! transform_int
          !********************************************************************************************

       enddo ! a
    enddo ! i


    ! set the next round up

    deallocate(ia_cho,stat=deallocatestatus)
    deallocate(i_ind,stat=deallocatestatus)
    deallocate(a_ind,stat=deallocatestatus)
    deallocate(ij_step,stat=deallocatestatus)
    deallocate(rvec,stat=deallocatestatus)
    deallocate(ivec,ivec2,stat=deallocatestatus)

    ! Now we want to resort the (ia|jb) integrals

    allocate(rvec(max_block_size),stat=allocatestatus)
    rvec = 0.0
    allocate(ivec(max_block_size),ivec2(max_block_size),ivec3(max_block_size),stat=allocatestatus)
    ivec = 0
    ivec2 = 0
    ivec3 = 0
    
    rewind(unit=iajb_bl_no)

    ivec3 = 0
    do i = 1,max_block_size
       ivec3(i) = i
    enddo

    icount = 0
    a = 0
    do i = 1,num_internal
       do j = 1,i-1
          if (ignorable_pair(i,j) ) cycle
          a = a + 1
          block_size = iajb_bl_vec(a)
          do c = 1,block_size
             call for_double_buf_readElement(cd_iajb_unsorted_no,icount+c,rvec(c),threadID)
          enddo
          do c = 1,block_size
             read(unit=iajb_ind_no,rec=icount+c) ivec(c)
          enddo

          ivec2(1:block_size) = ivec3(1:block_size)

          !call Iquicksrt(ivec(1:block_size),ivec2(1:block_size),block_size,sort_scr(1:block_size,1:2))
          call sort_int_array_with_indeX(ivec(1:block_size),ivec2(1:block_size))

          do c = 1,block_size ! Write sorted (ia|jb) block
             idum = ivec2(c)
             call for_double_buf_writeElement(cd_iajb_no,icount+c,rvec(idum),threadID)
          enddo

          icount = icount + block_size

       enddo
    enddo

    close(unit=iajb_ind_no)

    deallocate(rvec,stat=deallocatestatus)
    deallocate(ivec,ivec2,ivec3,stat=deallocatestatus)
    deallocate(iajb_bl_vec,stat=deallocatestatus)

  end subroutine make_iajb

  function makeOneIAJB(i,a,j,b,cho_data)

    use global_var_mod
    use cholesky_structs
    use io_unit_numbers
    use molecule_var_mod

    implicit none

    integer,intent(in)::i,a,j,b
    type(cholesky_data),intent(in)::cho_data
    real(real8)::makeOneIAJB

    integer::cho_point1,cho_point2
    real(real8),parameter::zero=real(0.0,real8)
    real(real8),external::ddot

    ! a always bigger than i
    cho_point1 = a*(a-1)/2+i
    cho_point1 = cho_data%mo_ind_inv(cho_point1)

    ! b always bigger than j
    cho_point2 = b*(b-1)/2+j
    cho_point2 = cho_data%mo_ind_inv(cho_point2)

    ! we have them in memory
    ! check an adapted CS criterion
    if(cho_data%cho_norms(cho_point1)*cho_data%cho_norms(cho_point2) >= integral_threshold) then
       makeOneIAJB = ddot(numcho,cho_data%cho_vectors(:,cho_point1),1,cho_data%cho_vectors(:,cho_point2),1)
       !      makeOneIAJB = dot_product(cho_data%cho_vectors(:,cho_point1),cho_data%cho_vectors(:,cho_point2))
    else
       makeOneIAJB = zero
    endif

  end function makeOneIAJB
end module iajb_mod
