! This Source Code Form is subject to the terms of the Mozilla Public
! License, v. 2.0. If a copy of the MPL was not distributed with this
! file, You can obtain one at http://mozilla.org/MPL/2.0/.
module ijka_mod
use IOBuffer
contains
  subroutine make_ijka(cho_data)
    ! A subroutine to construct the (ij|ka) integrals for the sigmavector routines

    use global_var_mod
    use molecule_var_mod
    use cholesky_structs
    use wp_tov_mod
    use io_unit_numbers
#ifdef TIGER_USE_OMP
    use omp_lib
#endif

    implicit none

    integer::a,b,d ! orbital indices
    integer::i,j,k
    integer::max_ij
    integer::i1,j1   
    integer::ij_count,ij_count2,ij_count3,ka_count
    integer::icount     
    integer::idum,idum2,idum3
    integer::ij_pairs
    integer::rec_count,rec_count2
    integer::block_len              
    integer::allocatestatus,deallocatestatus      
    integer,dimension(num_internal,num_internal)::ij_block
    integer,dimension(:),allocatable::i_ind,j_ind,ij_step,itempvec

    real(real8),allocatable,dimension(:,:)::ij_cho
    real(real8),allocatable,dimension(:)::tempvec
    real(real8),dimension(numcho)::ka_vec

    real(kind=real8), external::ddot ! BLAS1 (dot product)

    logical::transform_int  ! Decides if we need to transform integrals
    type(cholesky_data)::cho_data

#ifdef TIGER_USE_OMP
    integer::threadID
    threadID = OMP_get_thread_num()+1
#else
    integer,parameter::threadID = 1
#endif

    ! START AUTOGENERATED INITIALIZATION 
    transform_int = .false.
    ij_count = 0
    rec_count = 0
    block_len = 0
    ij_block = 0
    ij_count3 = 0
    ij_count2 = 0
    i1 = 0
    deallocatestatus = 0
    ka_count = 0
    max_ij = 0
    ka_vec = 0.0
    allocatestatus = 0
    idum = 0
    ij_pairs = 0
    j = 0
    k = 0
    i = 0
    d = 0
    b = 0
    a = 0
    j1 = 0
    icount = 0
    idum3 = 0
    idum2 = 0
    rec_count2 = 0
    ! END AUTOGENERATED INITIALIZATION 
    !*******************************************************************************

    ij_pairs = 0  ! Number of kept (ij) pairs
    ij_block = 0  ! Number of (ij|ka) integrals in each (ij) block
    ka_count = 0

    do i = 1,num_internal
       do j = 1,i-1

          if (ignorable_pair(i,j) ) cycle

          ij_pairs = ij_pairs + 1 
          ka_count = 0 

          do k = 1, num_internal
             if (ignorable_pair(i,k) ) cycle
             if (ignorable_pair(j,k) ) cycle


             do a = num_internal+1,num_orbitals
                if (ignorable_pair(i,a) ) cycle
                if (ignorable_pair(j,a) ) cycle
                if (ignorable_pair(k,a) ) cycle

                ka_count = ka_count + 1

             enddo
          enddo
          ij_block(i,j) = ka_count ! # of (ij|ka) integrals in this (ij) block
       enddo
    enddo


    ! Now we want to make ij_block a cumulative counter
    ! Useful for writing to file as record counter

    icount = 0 
    do i = 1,num_internal
       do j = 1,i-1
          if (ij_block(i,j) .eq. 0) cycle
          idum = ij_block(i,j)
          ij_block(i,j) = icount 
          icount = icount + idum 
       enddo
    enddo

    !******************************************************************************
    ! Set a maximum buffer size, say 500MB 
    max_ij = int(max_mem_ints/numcho)
    max_ij = max_ij - 1

    !******************************************************************************

    allocate(ij_cho(numcho,max_ij),stat=allocatestatus)
    allocate(i_ind(max_ij),stat=allocatestatus)
    allocate(j_ind(max_ij),stat=allocatestatus)
    allocate(ij_step(num_internal*(num_internal+1)/2),stat=allocatestatus)
    ij_step = 0 ! To keep the offset position of each ic block on disk

    allocate(tempvec(max_ij),stat=allocatestatus)
    allocate(itempvec(max_ij),stat=allocatestatus)

    !******************************************************************************
    ! Construct the (ij|ka) integrals. Buffered version.
    ! Step 1; Read max block of (ij) buffer
    ! Step 2: Go to work construct all (ij|ka) integrals with (ij) block. 
    ! Step 3: Get new (ij) block and repeat till all (ij) blocks are exhausted
    ! Step 4: Resort (ij|ka) 

    transform_int = .false.

    ij_count = 0           
    ij_count2 = 0    
    ij_count3 = 0
    rec_count = 0
    rec_count2 = 0
    block_len = 0

    idum3 = 0

    do i = 1,num_internal
       do j = 1,i-1
          if (ignorable_pair(i,j) ) cycle

          idum = i*(i-1)/2+j
          idum = cho_data%mo_ind_inv(idum)

          ! Read in max {ij} block   

          ij_count = ij_count + 1   ! For counting ij_index in (ij) buffer
          ij_count2 = ij_count2 + 1 ! Actual progress of ij loop

          if (idum .ne. 0) then
             call for_double_buf_readblock(mo_int_no, idum, ij_cho(1:numcho,ij_count), threadID)
          endif

          i_ind(ij_count) = i
          j_ind(ij_count) = j

          if (ij_count .eq. max_ij) then ! Buffer is now full or everything has been read into buffer
             transform_int = .true.   ! Go to transform integrals portion because buffer is full
             block_len = max_ij
          endif

          if (ij_count2 .eq. ij_pairs) then ! Everything has been read into buffer
             transform_int = .true.   ! Go to transform integrals portion because buffer is full
             block_len = ij_count 
          endif


          !*************************************************************************************** 
          if (transform_int) then ! (ij) buffer is full. Use them to construct (ij|ka) integrals

             ij_step = 0             ! To keep the offset position of each ab block on disk 

             do k = 1,num_internal ! We will construct all the (ij|ka) integrals for the current (ij) block

                do a = num_internal+1,num_orbitals

                   if (ignorable_pair(k,a) ) cycle

                   ka_vec = 0.0D0

                   idum = a*(a-1)/2+k
                   idum = cho_data%mo_ind_inv(idum)

                   if (idum .ne. 0) then
                      call for_double_buf_readblock(mo_int_no, idum, ka_vec(1:numcho), threadID)
                   endif


                   ij_count3 = 0
                   idum2 = 0
                   itempvec = 0
                   tempvec = 0.0D0

                   do d = 1,block_len

                      ij_count3 = ij_count3 + 1 ! Don't misplace this line
                      i1 = i_ind(ij_count3) ! Retrieves the index of a
                      j1 = j_ind(ij_count3)
                      if (ignorable_pair(i1,k) ) cycle
                      if (ignorable_pair(i1,a) ) cycle
                      if (ignorable_pair(j1,k) ) cycle
                      if (ignorable_pair(j1,a) ) cycle

                      idum2 = idum2 + 1
                      ij_step(ij_count3) = ij_step(ij_count3) + 1 ! Don't misplace this line
                      rec_count = ij_block(i1,j1) + ij_step(ij_count3)
                      tempvec(idum2)= ddot(numcho,ij_cho(:,ij_count3),1,ka_vec,1)
                      itempvec(idum2) = rec_count

                   enddo

                   do b = 1,idum2
                      rec_count = itempvec(b)
                      call for_double_buf_writeElement(cd_ijka_no,rec_count,tempvec(b),threadID)
                   enddo

                enddo
             enddo

             transform_int = .false.  ! Reset to false when (ab) buffer is exhausted
             i_ind = 0
             j_ind = 0
             ij_cho = 0.0D0
             ij_count = 0
             !        ij_off = ij_off + max_ij ! Update the offset for which we have the (ab) block so far

          endif ! transform_int
          !********************************************************************************************

       enddo ! a
    enddo ! i

    ! Record cumulative block size
    do i = 1,num_internal
       do j = 1,i-1
          if (ignorable_pair(i,j) ) cycle
          idum = i*(i-1)/2+j
          write(unit=372,rec=idum) ij_block(i,j)
       enddo
    enddo


    deallocate(ij_cho,stat=deallocatestatus)
    deallocate(i_ind,stat=deallocatestatus)
    deallocate(j_ind,stat=deallocatestatus)
    deallocate(ij_step,stat=deallocatestatus)
    deallocate(tempvec,stat=deallocatestatus)
    deallocate(itempvec,stat=deallocatestatus)


  end subroutine make_ijka
end module ijka_mod
