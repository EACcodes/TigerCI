#ifndef ORBITALPARSERS_H
#define	ORBITALPARSERS_H

#include <armadillo>
#include <memory>
#include <unordered_map>
#include "BasisData.h"

using namespace std;
using namespace arma;

extern "C" {
    
    // get MOs
    void c_get_coefficients(int64_t& nBas, int64_t& nOrb, double *molecular_orbitals);
}

mat get_MOs();
void set_MOs(mat new_MOs);

//enum class AngMom {s, p, d, f, g};
enum AngMom {s,p,d,f};

class OrbitalParser{
public:
    OrbitalParser() {};
    virtual ~OrbitalParser() {};
    virtual void parse(string filename, BasisData *bas) = 0;
    virtual void writeMoldenFile(string filename) = 0;
};

class MoldenOrbitalParser : OrbitalParser{
public:
  MoldenOrbitalParser(bool spherical);
  void parse(string filename, BasisData *bas);

  /* Double checks that all molecular orbitals are orthonormal */
  void check_norms(BasisData *basis);

  //prints out localized orbitals generated by TigerCI
  //filename should be the ORIGINAL orbital filename
  //(don't worry, it won't be overwritten)
  void writeMoldenFile(string filename);
    
  vector<atom_t> readCoordinates(string filename);
  
private:
    size_t nbas;
    size_t norb;
    size_t numd;
    size_t numf;
    bool spherical_harmonics;
    
    /* Perumations from going from molden order of d,f,g funcs to libint's ordering*/
    vector<size_t> d_permutation;
    vector<size_t> f_permutation;
 
    /* Reads a molden file and breaks into into individual sections */
    void readMoldenFile(string filename, vector<string>& text, 
                        unordered_map<string, pair<size_t,size_t>>& sections, bool &angs);
    
    /* Sanity checks the nuclear centers. Makes sure that the basis set's nuclear centers match the molden files' nuclear centers*/
    void checkCenters(BasisData *basis, vector<string>& text,
                      unordered_map<string, pair<size_t,size_t>>& sections, bool angs);
    
    /* Sanity checks for spherical harmonics. At the moment I'm only supporting cartestian functions*/
    void checkSphericalHarmonics(unordered_map<string, pair<size_t,size_t>>& sections);
    
    /* Gets the angular momentum ordering of the basis functions (s, p , d, etc...)*/
    vector<AngMom> getFuncOrder(vector<string>& text, unordered_map<string,
                                pair<size_t,size_t>>& sections);
    
    /* Builds the permutation required to map the basis functions in molden's ordering to erkale/libint's ordering*/
    vector<size_t> buildBasisPermut(vector<AngMom> funcOrder);
    
    /* Permutes a vector on the interval [start,end] */
    template <class T>
    void permuteVector(vector<T>& v, vector<size_t>& p, size_t start);
    
    /* Reads in the MOs in the correct basis function ordering*/
    void readMOs(vector<string>& text, unordered_map<string,
                 pair<size_t,size_t>>& sections, vector<size_t> p);
    
   /* Checks that the basis set and the molecular orbitals agree on the number of AO basis functions*/
    void checkNBas(BasisData *basis, const int moldenNBas);

    /* Calculates the norm of a molecular orbital (AO basis is not orthogonal) */
    double calc_norm(vec vec1, vec vec2, mat overlap);
    
    /* XXX temporary until stringutils have been updated! */
    bool is_int(std::string & s);
    
};

#endif	/* ORBITALPARSERS_H */

